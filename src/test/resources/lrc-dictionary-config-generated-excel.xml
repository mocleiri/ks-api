<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:dict="http://student.kuali.org/xsd/dictionary-extension"
xsi:schemaLocation="
http://student.kuali.org/xsd/dictionary-extension dictionary-extension.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
">
<!-- *** Automatically Generated ***
on: Tue Feb 02 13:57:53 EST 2010
by: org.kuali.student.dictionary.writer.DictionaryModelWriter
Using:Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls   and: Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls
 -->
import src/test/resources/constraints-dictionary-config-generated-excel.xml
	
	<dict:objectStructure key="org.kuali.student.lum.lrc.dto.CreditInfo">
		<!-- Detailed information about a credit value. -->
		<dict:type key="kuali.creditType.credit.degree">
		<!-- College level credit that can typically be applied by a student to complete a degree -->
			<dict:state key="(n/a)">
			<!-- Not applicable -->
				
				<dict:field id="academic.credit.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>academic credit name</dict:name>
						<dict:desc>Name of this credit. This may have a direct relation to the combination of value and type fields.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="academic.credit.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>academic credit desc</dict:name>
						<dict:desc>Description of this credit.</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="academic.credit.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>academic.credit.desc.plain</dict:name>
												<dict:desc>academic.credit.desc.plain</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.multi.line.text"/>
													<dict:constraintRef bean="constraint.hidden"/>
													<dict:constraintRef bean="constraint.calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain" id="constraint.">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="academic.credit.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>academic.credit.desc.formatted</dict:name>
												<dict:desc>academic.credit.desc.formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.optional"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted" id="constraint.">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="academic.credit.value" key="value">
					<dict:fieldDescriptor>
						<dict:name>academic credit value</dict:name>
						<dict:desc>The number of the credits. This is typically numeric, but string is used to cover cases such as fractional and unbounded.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.single.line.text"/>
							<dict:constraintRef bean="constraint.integer"/>
							<dict:constraint key="in-line.constraint.for.dictionary.academic.credit.value" id="constraint.">
								<dict:minValue>1</dict:minValue>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="academic.credit.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>academic credit effective date</dict:name>
						<dict:desc>Date and time that this credit value became effective. This is a similar concept to the effective date on enumerated values. When an expiration date has been specified, this field must be less than or equal to the expiration date.</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="academic.credit.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>academic credit expiration date</dict:name>
						<dict:desc>Date and time that this credit value expires. This is a similar concept to the expiration date on enumerated values. If specified, this should be greater than or equal to the effective date. If this field is not specified, then no expiration date has been currently defined and should automatically be considered greater than the effective date.</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="academic.credit.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>academic credit attributes</dict:name>
						<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="academic.credit.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>academic credit type</dict:name>
						<dict:desc>Unique identifier for a credit type.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.hard.coded.academic.credit"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="academic.credit.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>academic credit internal id</dict:name>
						<dict:desc>Unique identifier for a credit value.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.id"/>
							<dict:constraintRef bean="constraint.hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key="org.kuali.student.lum.lrc.dto.GradeInfo">
		<!-- Detailed information about a grade value. -->
		<dict:type key="kuali.gradeType.Letter">
		<!-- A Letter used as a grade (e.g. A, B, C, D, F) -->
		<!-- TO DO: add to Simples -->
			<dict:state key="(n/a)">
			<!-- Not applicable -->
				
				<dict:field id="letter.grade.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>letter grade name</dict:name>
						<dict:desc>The name of the letter grade</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="letter.grade.value" key="value">
					<dict:fieldDescriptor>
						<dict:name>letter grade value</dict:name>
						<dict:desc>the value of the letter grade</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.code"/>
							<dict:constraint key="in-line.constraint.for.dictionary.letter.grade.value" id="constraint.">
								<dict:minLength>1</dict:minLength>
								<dict:maxLength>10</dict:maxLength>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="letter.grade.scaleKey" key="scaleKey">
					<dict:fieldDescriptor>
						<dict:name>letter grade scaleKey</dict:name>
						<dict:desc>Identifier of the scale for this letter grade value.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.grade.scales"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="letter.grade.rank" key="rank">
					<dict:fieldDescriptor>
						<dict:name>letter grade rank</dict:name>
						<dict:desc>Rank of the letter grade value within the scale.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="letter.grade.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>letter grade effectiveDate</dict:name>
						<dict:desc>Date and time that this letter grade value became effective. T</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="letter.grade.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>letter grade expirationDate</dict:name>
						<dict:desc>Date and time that this letter grade value expires.</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="letter.grade.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>letter grade attributes</dict:name>
						<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="letter.grade.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>letter grade type</dict:name>
						<dict:desc>Unique identifier for the letter grade type.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.type"/>
							<dict:constraintRef bean="constraint.hard.coded.letter.grade"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="letter.grade.key" key="key">
					<dict:fieldDescriptor>
						<dict:name>letter grade key</dict:name>
						<dict:desc>Unique identifier for a letter grade</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.key"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.gradeType.Pass-Fail">
		<!-- Pass or Fail -->
		<!-- TO DO: add to Simples -->
			<dict:state key="(n/a)">
			<!-- Not applicable -->
				
				<dict:field id="pass-fail.grade.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>pass-fail grade name</dict:name>
						<dict:desc>The name of the pass-fail grade</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="pass-fail.grade.value" key="value">
					<dict:fieldDescriptor>
						<dict:name>pass-fail grade value</dict:name>
						<dict:desc>the value of the pass-fail grade</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.code"/>
							<dict:constraint key="in-line.constraint.for.dictionary.pass-fail.grade.value" id="constraint.">
								<dict:minLength>1</dict:minLength>
								<dict:maxLength>10</dict:maxLength>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="pass-fail.grade.scaleKey" key="scaleKey">
					<dict:fieldDescriptor>
						<dict:name>pass-fail grade scaleKey</dict:name>
						<dict:desc>Identifier of the scale for this pass-fail grade value.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.grade.scales"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="pass-fail.grade.rank" key="rank">
					<dict:fieldDescriptor>
						<dict:name>pass-fail grade rank</dict:name>
						<dict:desc>Rank of the pass-fail grade value within the scale.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="pass-fail.grade.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>pass-fail grade effectiveDate</dict:name>
						<dict:desc>Date and time that this pass-fail grade value became effective. T</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="pass-fail.grade.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>pass-fail grade expirationDate</dict:name>
						<dict:desc>Date and time that this pass-fail grade value expires.</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="pass-fail.grade.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>pass-fail grade attributes</dict:name>
						<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="pass-fail.grade.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>pass-fail grade type</dict:name>
						<dict:desc>Unique identifier for the pass-fail grade type.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.type"/>
							<dict:constraintRef bean="constraint.hard.coded.pass-fail.grade"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="pass-fail.grade.key" key="key">
					<dict:fieldDescriptor>
						<dict:name>pass-fail grade key</dict:name>
						<dict:desc>Unique identifier for a pass-fail grade</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.key"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.gradeType.Qualitative">
		<!-- A qualitative grade type -->
		<!-- TO DO: add to Simples -->
			<dict:state key="(n/a)">
			<!-- Not applicable -->
				
				<dict:field id="qualitative.grade.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>qualitative grade name</dict:name>
						<dict:desc>The name of the qualitative grade</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="qualitative.grade.value" key="value">
					<dict:fieldDescriptor>
						<dict:name>qualitative grade value</dict:name>
						<dict:desc>the value of the qualitative grade</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.code"/>
							<dict:constraint key="in-line.constraint.for.dictionary.qualitative.grade.value" id="constraint.">
								<dict:minLength>1</dict:minLength>
								<dict:maxLength>10</dict:maxLength>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="qualitative.grade.scaleKey" key="scaleKey">
					<dict:fieldDescriptor>
						<dict:name>qualitative grade scaleKey</dict:name>
						<dict:desc>Identifier of the scale for this qualitative grade value.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.grade.scales"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="qualitative.grade.rank" key="rank">
					<dict:fieldDescriptor>
						<dict:name>qualitative grade rank</dict:name>
						<dict:desc>Rank of the qualitative grade value within the scale.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="qualitative.grade.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>qualitative grade effectiveDate</dict:name>
						<dict:desc>Date and time that this qualitative grade value became effective. T</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="qualitative.grade.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>qualitative grade expirationDate</dict:name>
						<dict:desc>Date and time that this qualitative grade value expires.</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="qualitative.grade.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>qualitative grade attributes</dict:name>
						<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="qualitative.grade.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>qualitative grade type</dict:name>
						<dict:desc>Unique identifier for the qualitative grade type.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.type"/>
							<dict:constraintRef bean="constraint.hard.coded.pass-fail.grade"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="qualitative.grade.key" key="key">
					<dict:fieldDescriptor>
						<dict:name>qualitative grade key</dict:name>
						<dict:desc>Unique identifier for a qualitative grade</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.key"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key="org.kuali.student.lum.lrc.dto.ResultComponentInfo">
		<!-- Detailed information about a result component. -->
		<dict:type key="kuali.resultComponentType.credit.degree.fixed">
		<!-- This records a single fixed number of credits that are awarded if the student passes the course. -->
		<!-- TO DO: Fix Simples name -->
			<dict:state key="active">
			<!-- resultComponent is active -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				
				<dict:field id="fixed.credits.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>fixed credits name</dict:name>
						<dict:desc>fixed credits name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="fixed.credits.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>fixed credits desc</dict:name>
						<dict:desc>fixed credits desc</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="fixed.credits.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>fixed.credits.desc.plain</dict:name>
												<dict:desc>fixed.credits.desc.plain</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.multi.line.text"/>
													<dict:constraintRef bean="constraint.hidden"/>
													<dict:constraintRef bean="constraint.calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain" id="constraint.">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="fixed.credits.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>fixed.credits.desc.formatted</dict:name>
												<dict:desc>fixed.credits.desc.formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.optional"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted" id="constraint.">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="fixed.credits.resultValueIds" key="resultValueIds">
					<dict:fieldDescriptor>
						<dict:name>fixed credits result value Ids</dict:name>
						<dict:desc>the list of ids correspondign to the available credits values for fixed credit</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.related.resultValueId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="fixed.credits.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>fixed credits effective date</dict:name>
						<dict:desc>fixed credits effective date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="fixed.credits.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>fixed credits expiration date</dict:name>
						<dict:desc>fixed credits expiration date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="fixed.credits.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>fixed credits attributes</dict:name>
						<dict:desc>fixed credits attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="fixed.credits.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>fixed credits metainfo</dict:name>
						<dict:desc>fixed credits metainfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="fixed.credits.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>fixed credits meta versionInd</dict:name>
												<dict:desc>Version number for this resultComponent info</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="fixed.credits.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>fixed credits meta createTime</dict:name>
												<dict:desc>Date-time this resultComponent was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="fixed.credits.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>fixed credits meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this resultComponent</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="fixed.credits.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>fixed credits meta updateTime</dict:name>
												<dict:desc>Date-time this resultComponent was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="fixed.credits.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>fixed credits meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this resultComponent</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="fixed.credits.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>fixed credits type</dict:name>
						<dict:desc>fixed credits type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.type"/>
							<dict:constraintRef bean="constraint.hard.coded.fixed.credit"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="fixed.credits.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>fixed credits state</dict:name>
						<dict:desc>fixed credits state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="fixed.credits.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>fixed credits internal id</dict:name>
						<dict:desc>fixed credits internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.id"/>
							<dict:constraintRef bean="constraint.hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="inactive">
			<!-- resultComponent is inactive -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				<dict:fieldRef bean="fixed.credits.name"/>
				<dict:fieldRef bean="fixed.credits.desc"/>
				<dict:fieldRef bean="fixed.credits.resultValueIds"/>
				<dict:fieldRef bean="fixed.credits.effectiveDate"/>
				<dict:fieldRef bean="fixed.credits.expirationDate"/>
				<dict:fieldRef bean="fixed.credits.attributes"/>
				<dict:fieldRef bean="fixed.credits.metaInfo"/>
				<dict:fieldRef bean="fixed.credits.type"/>
				<dict:fieldRef bean="fixed.credits.state"/>
				<dict:fieldRef bean="fixed.credits.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.resultComponentType.credit.degree.range">
		<!-- This records a range of number of credits that can be awarded for this course. -->
		<!-- TO DO: Fix Simples name -->
			<dict:state key="active">
			<!-- resultComponent is active -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				
				<dict:field id="variable.credits.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>variable credits name</dict:name>
						<dict:desc>variable credits name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="variable.credits.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>variable credits desc</dict:name>
						<dict:desc>variable credits desc</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="variable.credits.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>variable.credits.desc.plain</dict:name>
												<dict:desc>variable.credits.desc.plain</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.multi.line.text"/>
													<dict:constraintRef bean="constraint.hidden"/>
													<dict:constraintRef bean="constraint.calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain" id="constraint.">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="variable.credits.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>variable.credits.desc.formatted</dict:name>
												<dict:desc>variable.credits.desc.formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.optional"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted" id="constraint.">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="variable.credits.resultValueIds" key="resultValueIds">
					<dict:fieldDescriptor>
						<dict:name>variable credits result value Ids</dict:name>
						<dict:desc>the list of ids correspondign to the available credits values for variable credit</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.related.resultValueId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="variable.credits.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>variable credits effective date</dict:name>
						<dict:desc>variable credits effective date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="variable.credits.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>variable credits expiration date</dict:name>
						<dict:desc>variable credits expiration date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="variable.credits.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>variable credits attributes</dict:name>
						<dict:desc>variable credits attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="variable.credits.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>variable credits metainfo</dict:name>
						<dict:desc>variable credits metainfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="variable.credits.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>variable credits meta versionInd</dict:name>
												<dict:desc>Version number for this resultComponent info</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="variable.credits.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>variable credits meta createTime</dict:name>
												<dict:desc>Date-time this resultComponent was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="variable.credits.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>variable credits meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this resultComponent</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="variable.credits.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>variable credits meta updateTime</dict:name>
												<dict:desc>Date-time this resultComponent was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="variable.credits.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>variable credits meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this resultComponent</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="variable.credits.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>variable credits type</dict:name>
						<dict:desc>variable credits type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.type"/>
							<dict:constraintRef bean="constraint.hard.coded.variable.credit"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="variable.credits.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>variable credits state</dict:name>
						<dict:desc>variable credits state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="variable.credits.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>variable credits internal id</dict:name>
						<dict:desc>variable credits internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.id"/>
							<dict:constraintRef bean="constraint.hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="inactive">
			<!-- resultComponent is inactive -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				<dict:fieldRef bean="variable.credits.name"/>
				<dict:fieldRef bean="variable.credits.desc"/>
				<dict:fieldRef bean="variable.credits.resultValueIds"/>
				<dict:fieldRef bean="variable.credits.effectiveDate"/>
				<dict:fieldRef bean="variable.credits.expirationDate"/>
				<dict:fieldRef bean="variable.credits.attributes"/>
				<dict:fieldRef bean="variable.credits.metaInfo"/>
				<dict:fieldRef bean="variable.credits.type"/>
				<dict:fieldRef bean="variable.credits.state"/>
				<dict:fieldRef bean="variable.credits.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.resultComponentType.finalGrade">
		<!-- This records that a final grade is a result for this course -->
		<!-- TO DO: add to Simples -->
			<dict:state key="active">
			<!-- resultComponent is active -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				
				<dict:field id="final.grades.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>final grade name</dict:name>
						<dict:desc>final grade name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.grades.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>final grade desc</dict:name>
						<dict:desc>final grade desc</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="final.grades.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>final.grades.desc.plain</dict:name>
												<dict:desc>final.grades.desc.plain</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.multi.line.text"/>
													<dict:constraintRef bean="constraint.hidden"/>
													<dict:constraintRef bean="constraint.calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain" id="constraint.">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.grades.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>final.grades.desc.formatted</dict:name>
												<dict:desc>final.grades.desc.formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.optional"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted" id="constraint.">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.grades.resultValueIds" key="resultValueIds">
					<dict:fieldDescriptor>
						<dict:name>final grade result value Ids</dict:name>
						<dict:desc>the list of ids correspondign to the available credits values for fixed credit</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.related.resultValueId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.grades.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>final grade effective date</dict:name>
						<dict:desc>final grade effective date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.grades.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>final grade expiration date</dict:name>
						<dict:desc>final grade expiration date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.grades.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>final grade attributes</dict:name>
						<dict:desc>final grade attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.grades.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>final grade metainfo</dict:name>
						<dict:desc>final grade metainfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="final.grades.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>final grade meta versionInd</dict:name>
												<dict:desc>Version number for this resultComponent info</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.grades.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>final grade meta createTime</dict:name>
												<dict:desc>Date-time this resultComponent was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.grades.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>final grade meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this resultComponent</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.grades.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>final grade meta updateTime</dict:name>
												<dict:desc>Date-time this resultComponent was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.grades.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>final grade meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this resultComponent</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.grades.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>final grade type</dict:name>
						<dict:desc>final grade type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.type"/>
							<dict:constraintRef bean="constraint.hard.coded.final.grade"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.grades.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>final grade state</dict:name>
						<dict:desc>final grade state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="final.grades.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>final grade internal id</dict:name>
						<dict:desc>final grade internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.id"/>
							<dict:constraintRef bean="constraint.hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="inactive">
			<!-- resultComponent is inactive -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				<dict:fieldRef bean="final.grades.name"/>
				<dict:fieldRef bean="final.grades.desc"/>
				<dict:fieldRef bean="final.grades.resultValueIds"/>
				<dict:fieldRef bean="final.grades.effectiveDate"/>
				<dict:fieldRef bean="final.grades.expirationDate"/>
				<dict:fieldRef bean="final.grades.attributes"/>
				<dict:fieldRef bean="final.grades.metaInfo"/>
				<dict:fieldRef bean="final.grades.type"/>
				<dict:fieldRef bean="final.grades.state"/>
				<dict:fieldRef bean="final.grades.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.resultComponentType.finalQualitative">
		<!-- This records that a Qualitative assessment is possible for this course -->
		<!-- TO DO: add to Simples -->
			<dict:state key="active">
			<!-- resultComponent is active -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				
				<dict:field id="final.qualitative.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>final qualitative name</dict:name>
						<dict:desc>final grade name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.qualitative.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>final qualitative desc</dict:name>
						<dict:desc>final grade desc</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="final.qualitative.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>final.qualitative.desc.plain</dict:name>
												<dict:desc>final.grades.desc.plain</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.multi.line.text"/>
													<dict:constraintRef bean="constraint.hidden"/>
													<dict:constraintRef bean="constraint.calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain" id="constraint.">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.qualitative.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>final.qualitative.desc.formatted</dict:name>
												<dict:desc>final.grades.desc.formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.optional"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted" id="constraint.">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.qualitative.resultValueIds" key="resultValueIds">
					<dict:fieldDescriptor>
						<dict:name>final qualitative result value Ids</dict:name>
						<dict:desc>the list of ids correspondign to the available credits values for fixed credit</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.related.resultValueId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.qualitative.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>final qualitative effective date</dict:name>
						<dict:desc>final grade effective date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.qualitative.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>final qualitative expiration date</dict:name>
						<dict:desc>final grade expiration date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.qualitative.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>final qualitative attributes</dict:name>
						<dict:desc>final grade attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.qualitative.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>final qualitative metainfo</dict:name>
						<dict:desc>final grade metainfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="final.qualitative.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>final qualitative meta versionInd</dict:name>
												<dict:desc>Version number for this resultComponent info</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.qualitative.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>final qualitative meta createTime</dict:name>
												<dict:desc>Date-time this resultComponent was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.qualitative.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>final qualitative meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this resultComponent</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.qualitative.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>final qualitative meta updateTime</dict:name>
												<dict:desc>Date-time this resultComponent was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.qualitative.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>final qualitative meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this resultComponent</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.qualitative.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>final qualitative type</dict:name>
						<dict:desc>final grade type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.type"/>
							<dict:constraintRef bean="constraint.hard.coded.final.qualitative"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.qualitative.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>final qualitative state</dict:name>
						<dict:desc>final grade state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="final.qualitative.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>final qualitative internal id</dict:name>
						<dict:desc>final grade internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.id"/>
							<dict:constraintRef bean="constraint.hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="inactive">
			<!-- resultComponent is inactive -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				<dict:fieldRef bean="final.qualitative.name"/>
				<dict:fieldRef bean="final.qualitative.desc"/>
				<dict:fieldRef bean="final.qualitative.resultValueIds"/>
				<dict:fieldRef bean="final.qualitative.effectiveDate"/>
				<dict:fieldRef bean="final.qualitative.expirationDate"/>
				<dict:fieldRef bean="final.qualitative.attributes"/>
				<dict:fieldRef bean="final.qualitative.metaInfo"/>
				<dict:fieldRef bean="final.qualitative.type"/>
				<dict:fieldRef bean="final.qualitative.state"/>
				<dict:fieldRef bean="final.qualitative.internal.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key=".LrDefinitionInfo">
		<!-- Detailed information about a learning result definition. -->
		<dict:type key="kuali.lrc.lrd.CreditCourseFinalGrade">
		<!-- This defines getting the result of a final grade in a credi course -->
		<!-- (n/a) -->
		<!-- TODO: update simples -->
			<dict:state key="(n/a)">
			<!-- Not applicable -->
			<!-- not sure why it has no state field but it should, at least active/inactive -->
				
				<dict:field id="credit.course.with.final.grade.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>credit course with final grade name</dict:name>
						<dict:desc>credit course with final grade name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.with.final.grade.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>credit course with final grade desc</dict:name>
						<dict:desc>credit course with final grade desc</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.multi.line.text"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.with.final.grade.type" key="lrType">
					<!-- Hard coded to be "kuali.lrc.lrd.CreditCourseFinalGrade" -->
					<dict:fieldDescriptor>
						<dict:name>credit course with final grade type</dict:name>
						<dict:desc>credit course with final grade type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.type"/>
							<dict:constraintRef bean="constraint.lrd.types"/>
							<dict:constraint key="in-line.constraint.for.dictionary.credit.course.with.final.grade.type" id="constraint.">
								<dict:validChars>
								<dict:value>regex:kuali\.lrc\.lrd\.CreditCourseFinalGrade</dict:value>
								</dict:validChars>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.with.final.grade.scale" key="lrScale">
					<!-- The lrScaleTypeKey as a type is deprected so I am not sure if it is really in use or if it should really point to a different type "scaleKey"?  

This field does not make sense. The GradeKey points to the GradeInfo object that tells us what the scale is -->
					<dict:fieldDescriptor>
						<dict:name>credit course with final grade scale</dict:name>
						<dict:desc>credit course with final grade scale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.type"/>
							<dict:constraintRef bean="constraint.learning.result.scale.types"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.with.final.grade.gradeKey" key="value">
					<!-- Isn't this really an ID or KEY that points to either a GradeInfo or a CreditInfo or a CredentialInfo object similar to resultComponentInfo.resultValueIds? -->
					<dict:fieldDescriptor>
						<dict:name>credit course with final grade gradeKey</dict:name>
						<dict:desc>credit course with final grade gradeKey</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.related.gradekey"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.with.final.grade.operator" key="operator">
					<dict:fieldDescriptor>
						<dict:name>credit course with final grade operator</dict:name>
						<dict:desc>credit course with final grade operator</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.code"/>
							<dict:constraintRef bean="constraint.lrd.operators"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.with.final.grade.dynamic.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>credit course with final grade dynamic attributes</dict:name>
						<dict:desc>credit course with final grade dynamic attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.with.final.grade.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>credit course with final grade metaInfo</dict:name>
						<dict:desc>credit course with final grade metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="credit.course.with.final.grade.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>credit course with final grade meta versionInd</dict:name>
												<dict:desc>credit course with final grade meta versionInd</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="credit.course.with.final.grade.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>credit course with final grade meta createTime</dict:name>
												<dict:desc>credit course with final grade meta createTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="credit.course.with.final.grade.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>credit course with final grade meta createId</dict:name>
												<dict:desc>credit course with final grade meta createId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="credit.course.with.final.grade.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>credit course with final grade meta updateTime</dict:name>
												<dict:desc>credit course with final grade meta updateTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="credit.course.with.final.grade.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>credit course with final grade meta updateId</dict:name>
												<dict:desc>credit course with final grade meta updateId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.with.final.grade.internal.id" key="lrDefinitionId">
					<dict:fieldDescriptor>
						<dict:name>credit course with final grade internal id</dict:name>
						<dict:desc>credit course with final grade internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.id"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.lrc.lrd.OverallProgramGPA">
		<!-- This defines the calculated GPA result of enrollment in the overall program -->
		<!-- (n/a) -->
		<!-- For now we have to live without defining "Overall" even though it is a fuzzy word.. What if a person was in multiple overall programs sequentially (undergrad then grad) or parallel (dual major)?  Which program?
TODO: update simples -->
			<dict:state key="(n/a)">
			<!-- Not applicable -->
			<!-- not sure why it has no state field but it should, at least active/inactive -->
				
				<dict:field id="gpa.in.overall.program.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>gpa in overall program name</dict:name>
						<dict:desc>gpa in overall program name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="gpa.in.overall.program.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>gpa in overall program desc</dict:name>
						<dict:desc>gpa in overall program desc</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.multi.line.text"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="gpa.in.overall.program.type" key="lrType">
					<!-- Hard coded to be "kuali.lrc.lrd.OverallProgramGPA" -->
					<dict:fieldDescriptor>
						<dict:name>gpa in overall program type</dict:name>
						<dict:desc>gpa in overall program type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.type"/>
							<dict:constraintRef bean="constraint.lrd.types"/>
							<dict:constraint key="in-line.constraint.for.dictionary.gpa.in.overall.program.type" id="constraint.">
								<dict:validChars>
								<dict:value>regex:kuali\.lrc\.lrd\.OverallProgramGPA</dict:value>
								</dict:validChars>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="gpa.in.overall.program.scale" key="lrScale">
					<!-- The lrScaleTypeKey as a type is deprected so I am not sure if it is really in use or if it should really point to a different type "scaleKey"?  

This field does not make sense. The GradeKey points to the GradeInfo object that tells us what the scale is -->
					<dict:fieldDescriptor>
						<dict:name>gpa in overall program scale</dict:name>
						<dict:desc>gpa in overall program scale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.type"/>
							<dict:constraintRef bean="constraint.learning.result.scale.types"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="gpa.in.overall.program.gpa" key="value">
					<!-- Isn't this really an ID or KEY that points to either a GradeInfo or a CreditInfo or a CredentialInfo object similar to resultComponentInfo.resultValueIds? -->
					<!-- not sure the minimum GPA is stored here or on the requirement component -->
					<dict:fieldDescriptor>
						<dict:name>gpa in overall program gpa</dict:name>
						<dict:desc>gpa in overall program gpa</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.non.negative.decimal"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="gpa.in.overall.program.operator" key="operator">
					<dict:fieldDescriptor>
						<dict:name>gpa in overall program operator</dict:name>
						<dict:desc>gpa in overall program operator</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.code"/>
							<dict:constraintRef bean="constraint.lrd.operators"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="gpa.in.overall.program.dynamic.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>gpa in overall program dynamic attributes</dict:name>
						<dict:desc>gpa in overall program dynamic attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="gpa.in.overall.program.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>gpa in overall program metaInfo</dict:name>
						<dict:desc>gpa in overall program metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="gpa.in.overall.program.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>gpa in overall program meta versionInd</dict:name>
												<dict:desc>gpa in overall program meta versionInd</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="gpa.in.overall.program.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>gpa in overall program meta createTime</dict:name>
												<dict:desc>gpa in overall program meta createTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="gpa.in.overall.program.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>gpa in overall program meta createId</dict:name>
												<dict:desc>gpa in overall program meta createId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="gpa.in.overall.program.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>gpa in overall program meta updateTime</dict:name>
												<dict:desc>gpa in overall program meta updateTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="gpa.in.overall.program.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>gpa in overall program meta updateId</dict:name>
												<dict:desc>gpa in overall program meta updateId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="gpa.in.overall.program.internal.id" key="lrDefinitionId">
					<dict:fieldDescriptor>
						<dict:name>gpa in overall program internal id</dict:name>
						<dict:desc>gpa in overall program internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.id"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.lrc.lrd.OverallProgramTotalCredits">
		<!-- This defines the calculated Total Credits result of enrollment in the overall program. -->
		<!-- (n/a) -->
		<!-- For now we have to live without defining "Overall" even though it is a fuzzy word.. What if a person was in multiple overall programs sequentially (undergrad then grad) or parallel (dual major)?  Which program?
TODO: update simples -->
			<dict:state key="(n/a)">
			<!-- Not applicable -->
			<!-- not sure why it has no state field but it should, at least active/inactive -->
				
				<dict:field id="total.credits.in.overall.program.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>total credits in overall program name</dict:name>
						<dict:desc>total credits in overall program name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="total.credits.in.overall.program.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>total credits in overall program desc</dict:name>
						<dict:desc>total credits in overall program desc</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.multi.line.text"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="total.credits.in.overall.program.type" key="lrType">
					<!-- Hard coded to be "kuali.lrc.lrd.OverallProgramTotalCredits" -->
					<dict:fieldDescriptor>
						<dict:name>total credits in overall program type</dict:name>
						<dict:desc>total credits in overall program type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.type"/>
							<dict:constraintRef bean="constraint.lrd.types"/>
							<dict:constraint key="in-line.constraint.for.dictionary.total.credits.in.overall.program.type" id="constraint.">
								<dict:validChars>
								<dict:value>regex:kuali\.lrc\.lrd\.OverallProgramTotalCredits</dict:value>
								</dict:validChars>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="total.credits.in.overall.program.scale" key="lrScale">
					<!-- The lrScaleTypeKey as a type is deprected so I am not sure if it is really in use or if it should really point to a different type "scaleKey"?  

This field does not make sense. The GradeKey points to the GradeInfo object that tells us what the scale is -->
					<dict:fieldDescriptor>
						<dict:name>total credits in overall program scale</dict:name>
						<dict:desc>total credits in overall program scale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.type"/>
							<dict:constraintRef bean="constraint.learning.result.scale.types"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="total.credits.in.overall.program.gpa" key="value">
					<!-- Isn't this really an ID or KEY that points to either a GradeInfo or a CreditInfo or a CredentialInfo object similar to resultComponentInfo.resultValueIds? -->
					<!-- not sure the minimum Credits is stored here or on the requirement component -->
					<dict:fieldDescriptor>
						<dict:name>total credits in overall program gpa</dict:name>
						<dict:desc>total credits in overall program gpa</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.non.negative.decimal"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="total.credits.in.overall.program.operator" key="operator">
					<dict:fieldDescriptor>
						<dict:name>total credits in overall program operator</dict:name>
						<dict:desc>total credits in overall program operator</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.code"/>
							<dict:constraintRef bean="constraint.lrd.operators"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="total.credits.in.overall.program.dynamic.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>total credits in overall program dynamic attributes</dict:name>
						<dict:desc>total credits in overall program dynamic attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="total.credits.in.overall.program.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>total credits in overall program metaInfo</dict:name>
						<dict:desc>total credits in overall program metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="total.credits.in.overall.program.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>total credits in overall program meta versionInd</dict:name>
												<dict:desc>total credits in overall program meta versionInd</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="total.credits.in.overall.program.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>total credits in overall program meta createTime</dict:name>
												<dict:desc>total credits in overall program meta createTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="total.credits.in.overall.program.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>total credits in overall program meta createId</dict:name>
												<dict:desc>total credits in overall program meta createId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="total.credits.in.overall.program.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>total credits in overall program meta updateTime</dict:name>
												<dict:desc>total credits in overall program meta updateTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="total.credits.in.overall.program.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>total credits in overall program meta updateId</dict:name>
												<dict:desc>total credits in overall program meta updateId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="total.credits.in.overall.program.internal.id" key="lrDefinitionId">
					<dict:fieldDescriptor>
						<dict:name>total credits in overall program internal id</dict:name>
						<dict:desc>total credits in overall program internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.id"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
</beans>
