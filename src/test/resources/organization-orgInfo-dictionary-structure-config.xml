<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:dict="http://student.kuali.org/xsd/dictionary-extension"
xsi:schemaLocation="
http://student.kuali.org/xsd/dictionary-extension http://student.kuali.org/xsd/dictionary-extension/dictionary-extension.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
">
<!-- *** Automatically Generated ***
by: org.kuali.student.dictionary.writer.dict.DictionaryModelWriter
Using:Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls   and: Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls
 -->

<!-- *********************************** -->
<!-- object structure for object.orgInfo -->
<!-- *********************************** -->
<!-- Detailed information about a single organization. -->
<dict:objectStructure key=".OrgInfo" id="object.orgInfo.abstract" abstract="true">
	<dict:typeRef bean="type.orgInfo"/>
</dict:objectStructure>
<dict:objectStructure key=".OrgInfo" id="object.orgInfo" parent="object.orgInfo.abstract"/>

<dict:type key="*" id="type.orgInfo.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="state.orgInfo"/>
</dict:type>
<dict:type key="*" id="type.orgInfo" parent="type.orgInfo.abstract"/>

<!-- ******************************************* -->
<!-- State for state.orgInfo.(default).(default) -->
<!-- ******************************************* -->

<dict:state key="*" id="state.orgInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.orgInfo.longName"/>
	<dict:fieldRef bean="field.orgInfo.shortName"/>
	<dict:fieldRef bean="field.orgInfo.sortName"/>
	<dict:fieldRef bean="field.orgInfo.shortDesc"/>
	<dict:fieldRef bean="field.orgInfo.longDesc"/>
	<dict:fieldRef bean="field.orgInfo.effectiveDate"/>
	<dict:fieldRef bean="field.orgInfo.expirationDate"/>
	<dict:fieldRef bean="field.orgInfo.orgCodes"/>
	<dict:fieldRef bean="field.orgInfo.metaInfo"/>
	<dict:fieldRef bean="field.orgInfo.type"/>
	<dict:fieldRef bean="field.orgInfo.state"/>
	<dict:fieldRef bean="field.orgInfo.id"/>
</dict:state>
<dict:state key="*" id="state.orgInfo" parent="state.orgInfo.abstract"/>


<dict:field key="longName" id="field.orgInfo.longName.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.longName.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.longName.cd"/>
</dict:field>
<dict:field key="longName" id="field.orgInfo.longName" parent="field.orgInfo.longName.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.longName.fd.abstract" abstract="true">
	<dict:name>Organization Long Name</dict:name>
	<dict:desc>Full name of the organization.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.longName.fd" parent="field.orgInfo.longName.fd.abstract"/>
<!-- Required; Single valued (non-repeating); A basic single line of text, no embedded carraige returns or tabs limited to 255 -->
<dict:constraintDescriptor id="field.orgInfo.longName.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.single.line.text"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="longName" id="field.orgInfo.longName.cd" parent="field.orgInfo.longName.cd.abstract"/>

<dict:field key="shortName" id="field.orgInfo.shortName.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.shortName.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.shortName.cd"/>
</dict:field>
<dict:field key="shortName" id="field.orgInfo.shortName" parent="field.orgInfo.shortName.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.shortName.fd.abstract" abstract="true">
	<dict:name>Organization Short Name</dict:name>
	<dict:desc>Shortened format or abbreviation of the organization&apos;s name.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.shortName.fd" parent="field.orgInfo.shortName.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); A basic single line of text, no embedded carraige returns or tabs limited to 255 -->
<dict:constraintDescriptor id="field.orgInfo.shortName.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.single.line.text"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="shortName" id="field.orgInfo.shortName.cd" parent="field.orgInfo.shortName.cd.abstract"/>

<dict:field key="sortName" id="field.orgInfo.sortName.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.sortName.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.sortName.cd"/>
</dict:field>
<dict:field key="sortName" id="field.orgInfo.sortName" parent="field.orgInfo.sortName.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.sortName.fd.abstract" abstract="true">
	<dict:name>Organization Sort Name</dict:name>
	<dict:desc>The name used for sorting, for cases when alphabetical sorting by shortName or longName is undesirable.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.sortName.fd" parent="field.orgInfo.sortName.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); A basic single line of text, no embedded carraige returns or tabs limited to 255 -->
<dict:constraintDescriptor id="field.orgInfo.sortName.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.single.line.text"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="sortName" id="field.orgInfo.sortName.cd" parent="field.orgInfo.sortName.cd.abstract"/>

<dict:field key="shortDesc" id="field.orgInfo.shortDesc.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.shortDesc.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.shortDesc.cd"/>
</dict:field>
<dict:field key="shortDesc" id="field.orgInfo.shortDesc" parent="field.orgInfo.shortDesc.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.shortDesc.fd.abstract" abstract="true">
	<dict:name>Organization Short Description</dict:name>
	<dict:desc>A brief description of the organization.</dict:desc>
	<dict:dataType>Complex</dict:dataType>
		<dict:objectStructureRef bean="object.field.orgInfo.shortDesc"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.shortDesc.fd" parent="field.orgInfo.shortDesc.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.orgInfo.shortDesc.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="shortDesc" id="field.orgInfo.shortDesc.cd" parent="field.orgInfo.shortDesc.cd.abstract"/>

<!-- *********************************************************************** -->
<!-- object structure for object.field.orgInfo.shortDesc.(default).(default) -->
<!-- *********************************************************************** -->
<!-- Complex type supporting both a plain text and formatted version of a string. -->
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="object.field.orgInfo.shortDesc.abstract" abstract="true">
	<dict:typeRef bean="type.field.orgInfo.shortDesc"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="object.field.orgInfo.shortDesc" parent="object.field.orgInfo.shortDesc.abstract"/>

<dict:type key="*" id="type.field.orgInfo.shortDesc.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="state.field.orgInfo.shortDesc"/>
</dict:type>
<dict:type key="*" id="type.field.orgInfo.shortDesc" parent="type.field.orgInfo.shortDesc.abstract"/>

<!-- ******************************************************************************* -->
<!-- State for state.field.orgInfo.shortDesc.(default).(default).(default).(default) -->
<!-- ******************************************************************************* -->

<dict:state key="*" id="state.field.orgInfo.shortDesc.abstract" abstract="true">
	<dict:fieldRef bean="field.orgInfo.shortDesc.plain"/>
	<dict:fieldRef bean="field.orgInfo.shortDesc.formatted"/>
</dict:state>
<dict:state key="*" id="state.field.orgInfo.shortDesc" parent="state.field.orgInfo.shortDesc.abstract"/>


<dict:field key="plain" id="field.orgInfo.shortDesc.plain.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.shortDesc.plain.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.shortDesc.plain.cd"/>
</dict:field>
<dict:field key="plain" id="field.orgInfo.shortDesc.plain" parent="field.orgInfo.shortDesc.plain.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.shortDesc.plain.fd.abstract" abstract="true">
	<dict:name>Plain Text</dict:name>
	<dict:desc>Plain version of the text. This may be used for searching.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.shortDesc.plain.fd" parent="field.orgInfo.shortDesc.plain.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Multi-line text field that accepts all printable characters plus tab, carraige-return and linefeed. -->
<dict:constraintDescriptor id="field.orgInfo.shortDesc.plain.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.multi.line.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="plain" id="field.orgInfo.shortDesc.plain.cd" parent="field.orgInfo.shortDesc.plain.cd.abstract"/>

<dict:field key="formatted" id="field.orgInfo.shortDesc.formatted.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.shortDesc.formatted.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.shortDesc.formatted.cd"/>
</dict:field>
<dict:field key="formatted" id="field.orgInfo.shortDesc.formatted" parent="field.orgInfo.shortDesc.formatted.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.shortDesc.formatted.fd.abstract" abstract="true">
	<dict:name>Formatted Text</dict:name>
	<dict:desc>Formatted version of the text.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.shortDesc.formatted.fd" parent="field.orgInfo.shortDesc.formatted.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Text field that accepts all types of characters using some sort of escaping convention along with the ability to specify bolding, font size, color etc. -->
<dict:constraintDescriptor id="field.orgInfo.shortDesc.formatted.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.rich.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="formatted" id="field.orgInfo.shortDesc.formatted.cd" parent="field.orgInfo.shortDesc.formatted.cd.abstract"/>

<dict:field key="longDesc" id="field.orgInfo.longDesc.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.longDesc.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.longDesc.cd"/>
</dict:field>
<dict:field key="longDesc" id="field.orgInfo.longDesc" parent="field.orgInfo.longDesc.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.longDesc.fd.abstract" abstract="true">
	<dict:name>Organization Long Description</dict:name>
	<dict:desc>Narrative description of the organization.</dict:desc>
	<dict:dataType>Complex</dict:dataType>
		<dict:objectStructureRef bean="object.field.orgInfo.longDesc"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.longDesc.fd" parent="field.orgInfo.longDesc.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.orgInfo.longDesc.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="longDesc" id="field.orgInfo.longDesc.cd" parent="field.orgInfo.longDesc.cd.abstract"/>

<!-- ********************************************************************** -->
<!-- object structure for object.field.orgInfo.longDesc.(default).(default) -->
<!-- ********************************************************************** -->
<!-- Complex type supporting both a plain text and formatted version of a string. -->
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="object.field.orgInfo.longDesc.abstract" abstract="true">
	<dict:typeRef bean="type.field.orgInfo.longDesc"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="object.field.orgInfo.longDesc" parent="object.field.orgInfo.longDesc.abstract"/>

<dict:type key="*" id="type.field.orgInfo.longDesc.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="state.field.orgInfo.longDesc"/>
</dict:type>
<dict:type key="*" id="type.field.orgInfo.longDesc" parent="type.field.orgInfo.longDesc.abstract"/>

<!-- ****************************************************************************** -->
<!-- State for state.field.orgInfo.longDesc.(default).(default).(default).(default) -->
<!-- ****************************************************************************** -->

<dict:state key="*" id="state.field.orgInfo.longDesc.abstract" abstract="true">
	<dict:fieldRef bean="field.orgInfo.longDesc.plain"/>
	<dict:fieldRef bean="field.orgInfo.longDesc.formatted"/>
</dict:state>
<dict:state key="*" id="state.field.orgInfo.longDesc" parent="state.field.orgInfo.longDesc.abstract"/>


<dict:field key="plain" id="field.orgInfo.longDesc.plain.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.longDesc.plain.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.longDesc.plain.cd"/>
</dict:field>
<dict:field key="plain" id="field.orgInfo.longDesc.plain" parent="field.orgInfo.longDesc.plain.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.longDesc.plain.fd.abstract" abstract="true">
	<dict:name>Plain Text</dict:name>
	<dict:desc>Plain version of the text. This may be used for searching.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.longDesc.plain.fd" parent="field.orgInfo.longDesc.plain.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Multi-line text field that accepts all printable characters plus tab, carraige-return and linefeed. -->
<dict:constraintDescriptor id="field.orgInfo.longDesc.plain.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.multi.line.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="plain" id="field.orgInfo.longDesc.plain.cd" parent="field.orgInfo.longDesc.plain.cd.abstract"/>

<dict:field key="formatted" id="field.orgInfo.longDesc.formatted.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.longDesc.formatted.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.longDesc.formatted.cd"/>
</dict:field>
<dict:field key="formatted" id="field.orgInfo.longDesc.formatted" parent="field.orgInfo.longDesc.formatted.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.longDesc.formatted.fd.abstract" abstract="true">
	<dict:name>Formatted Text</dict:name>
	<dict:desc>Formatted version of the text.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.longDesc.formatted.fd" parent="field.orgInfo.longDesc.formatted.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Text field that accepts all types of characters using some sort of escaping convention along with the ability to specify bolding, font size, color etc. -->
<dict:constraintDescriptor id="field.orgInfo.longDesc.formatted.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.rich.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="formatted" id="field.orgInfo.longDesc.formatted.cd" parent="field.orgInfo.longDesc.formatted.cd.abstract"/>

<dict:field key="effectiveDate" id="field.orgInfo.effectiveDate.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.effectiveDate.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.effectiveDate.cd"/>
</dict:field>
<dict:field key="effectiveDate" id="field.orgInfo.effectiveDate" parent="field.orgInfo.effectiveDate.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.effectiveDate.fd.abstract" abstract="true">
	<dict:name>Effective Date</dict:name>
	<dict:desc>Date and time that this organization became effective. This is a similar concept to the effective date on enumerated values. When an expiration date has been specified, this field must be less than or equal to the expiration date.</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.effectiveDate.fd" parent="field.orgInfo.effectiveDate.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time -->
<dict:constraintDescriptor id="field.orgInfo.effectiveDate.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="effectiveDate" id="field.orgInfo.effectiveDate.cd" parent="field.orgInfo.effectiveDate.cd.abstract"/>

<dict:field key="expirationDate" id="field.orgInfo.expirationDate.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.expirationDate.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.expirationDate.cd"/>
</dict:field>
<dict:field key="expirationDate" id="field.orgInfo.expirationDate" parent="field.orgInfo.expirationDate.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.expirationDate.fd.abstract" abstract="true">
	<dict:name>Expiration Date</dict:name>
	<dict:desc>Date and time that this organization expires. This is a similar concept to the expiration date on enumerated values. If specified, this must be greater than or equal to the effective date. If this field is not specified, then no expiration date has been currently defined and should automatically be considered greater than the effective date.</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.expirationDate.fd" parent="field.orgInfo.expirationDate.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Date-Time; Must be empty or a date greater than the entity's effective date -->
<dict:constraintDescriptor id="field.orgInfo.expirationDate.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.cross.greaterthan.effective.date"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="expirationDate" id="field.orgInfo.expirationDate.cd" parent="field.orgInfo.expirationDate.cd.abstract"/>

<dict:field key="orgCodes" id="field.orgInfo.orgCodes.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.orgCodes.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.orgCodes.cd"/>
</dict:field>
<dict:field key="orgCodes" id="field.orgInfo.orgCodes" parent="field.orgInfo.orgCodes.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.fd.abstract" abstract="true">
	<dict:name>Org Code Info</dict:name>
	<dict:desc>These are structures so that many different types of codes can be associated with the org. This allows them to be put into categories.</dict:desc>
	<dict:dataType>Complex</dict:dataType>
		<dict:objectStructureRef bean="object.field.orgInfo.orgCodes"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.fd" parent="field.orgInfo.orgCodes.fd.abstract"/>
<!-- Optional; Repeating -->
<dict:constraintDescriptor id="field.orgInfo.orgCodes.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="orgCodes" id="field.orgInfo.orgCodes.cd" parent="field.orgInfo.orgCodes.cd.abstract"/>

<!-- ********************************************************************** -->
<!-- object structure for object.field.orgInfo.orgCodes.(default).(default) -->
<!-- ********************************************************************** -->
<!-- Detailed information about organization codes. -->
<dict:objectStructure key=".OrgCodeInfo" id="object.field.orgInfo.orgCodes.abstract" abstract="true">
	<dict:typeRef bean="type.field.orgInfo.orgCodes"/>
</dict:objectStructure>
<dict:objectStructure key=".OrgCodeInfo" id="object.field.orgInfo.orgCodes" parent="object.field.orgInfo.orgCodes.abstract"/>

<dict:type key="*" id="type.field.orgInfo.orgCodes.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="state.field.orgInfo.orgCodes"/>
</dict:type>
<dict:type key="*" id="type.field.orgInfo.orgCodes" parent="type.field.orgInfo.orgCodes.abstract"/>

<!-- ****************************************************************************** -->
<!-- State for state.field.orgInfo.orgCodes.(default).(default).(default).(default) -->
<!-- ****************************************************************************** -->

<dict:state key="*" id="state.field.orgInfo.orgCodes.abstract" abstract="true">
	<dict:fieldRef bean="field.orgInfo.orgCodes.desc"/>
	<dict:fieldRef bean="field.orgInfo.orgCodes.value"/>
	<dict:fieldRef bean="field.orgInfo.orgCodes.metaInfo"/>
	<dict:fieldRef bean="field.orgInfo.orgCodes.key"/>
</dict:state>
<dict:state key="*" id="state.field.orgInfo.orgCodes" parent="state.field.orgInfo.orgCodes.abstract"/>


<dict:field key="desc" id="field.orgInfo.orgCodes.desc.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.orgCodes.desc.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.orgCodes.desc.cd"/>
</dict:field>
<dict:field key="desc" id="field.orgInfo.orgCodes.desc" parent="field.orgInfo.orgCodes.desc.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.desc.fd.abstract" abstract="true">
	<dict:name>Org Code Description</dict:name>
	<dict:desc>The description of the code.</dict:desc>
	<dict:dataType>Complex</dict:dataType>
		<dict:objectStructureRef bean="object.field.orgInfo.orgCodes.desc"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.desc.fd" parent="field.orgInfo.orgCodes.desc.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.orgInfo.orgCodes.desc.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="desc" id="field.orgInfo.orgCodes.desc.cd" parent="field.orgInfo.orgCodes.desc.cd.abstract"/>

<!-- *********************************************************************************************** -->
<!-- object structure for object.field.orgInfo.orgCodes.(default).(default).desc.(default).(default) -->
<!-- *********************************************************************************************** -->
<!-- Complex type supporting both a plain text and formatted version of a string. -->
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="object.field.orgInfo.orgCodes.desc.abstract" abstract="true">
	<dict:typeRef bean="type.field.orgInfo.orgCodes.desc"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="object.field.orgInfo.orgCodes.desc" parent="object.field.orgInfo.orgCodes.desc.abstract"/>

<dict:type key="*" id="type.field.orgInfo.orgCodes.desc.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="state.field.orgInfo.orgCodes.desc"/>
</dict:type>
<dict:type key="*" id="type.field.orgInfo.orgCodes.desc" parent="type.field.orgInfo.orgCodes.desc.abstract"/>

<!-- ******************************************************************************************************* -->
<!-- State for state.field.orgInfo.orgCodes.(default).(default).desc.(default).(default).(default).(default) -->
<!-- ******************************************************************************************************* -->

<dict:state key="*" id="state.field.orgInfo.orgCodes.desc.abstract" abstract="true">
	<dict:fieldRef bean="field.orgInfo.orgCodes.desc.plain"/>
	<dict:fieldRef bean="field.orgInfo.orgCodes.desc.formatted"/>
</dict:state>
<dict:state key="*" id="state.field.orgInfo.orgCodes.desc" parent="state.field.orgInfo.orgCodes.desc.abstract"/>


<dict:field key="plain" id="field.orgInfo.orgCodes.desc.plain.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.orgCodes.desc.plain.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.orgCodes.desc.plain.cd"/>
</dict:field>
<dict:field key="plain" id="field.orgInfo.orgCodes.desc.plain" parent="field.orgInfo.orgCodes.desc.plain.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.desc.plain.fd.abstract" abstract="true">
	<dict:name>Plain Text</dict:name>
	<dict:desc>Plain version of the text. This may be used for searching.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.desc.plain.fd" parent="field.orgInfo.orgCodes.desc.plain.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Multi-line text field that accepts all printable characters plus tab, carraige-return and linefeed. -->
<dict:constraintDescriptor id="field.orgInfo.orgCodes.desc.plain.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.multi.line.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="plain" id="field.orgInfo.orgCodes.desc.plain.cd" parent="field.orgInfo.orgCodes.desc.plain.cd.abstract"/>

<dict:field key="formatted" id="field.orgInfo.orgCodes.desc.formatted.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.orgCodes.desc.formatted.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.orgCodes.desc.formatted.cd"/>
</dict:field>
<dict:field key="formatted" id="field.orgInfo.orgCodes.desc.formatted" parent="field.orgInfo.orgCodes.desc.formatted.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.desc.formatted.fd.abstract" abstract="true">
	<dict:name>Formatted Text</dict:name>
	<dict:desc>Formatted version of the text.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.desc.formatted.fd" parent="field.orgInfo.orgCodes.desc.formatted.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Text field that accepts all types of characters using some sort of escaping convention along with the ability to specify bolding, font size, color etc. -->
<dict:constraintDescriptor id="field.orgInfo.orgCodes.desc.formatted.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.rich.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="formatted" id="field.orgInfo.orgCodes.desc.formatted.cd" parent="field.orgInfo.orgCodes.desc.formatted.cd.abstract"/>

<dict:field key="value" id="field.orgInfo.orgCodes.value.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.orgCodes.value.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.orgCodes.value.cd"/>
</dict:field>
<dict:field key="value" id="field.orgInfo.orgCodes.value" parent="field.orgInfo.orgCodes.value.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.value.fd.abstract" abstract="true">
	<dict:name>Org Code Value</dict:name>
	<dict:desc>The code value.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.value.fd" parent="field.orgInfo.orgCodes.value.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.orgInfo.orgCodes.value.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.orgInfo.orgCodes.value.cd" parent="field.orgInfo.orgCodes.value.cd.abstract"/>

<dict:field key="metaInfo" id="field.orgInfo.orgCodes.metaInfo.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.orgCodes.metaInfo.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.orgCodes.metaInfo.cd"/>
</dict:field>
<dict:field key="metaInfo" id="field.orgInfo.orgCodes.metaInfo" parent="field.orgInfo.orgCodes.metaInfo.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.metaInfo.fd.abstract" abstract="true">
	<dict:name>Create/Update meta info</dict:name>
	<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
	<dict:dataType>Complex</dict:dataType>
		<dict:objectStructureRef bean="object.field.orgInfo.orgCodes.metaInfo"/>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.metaInfo.fd" parent="field.orgInfo.orgCodes.metaInfo.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Kuali Meta Data: calculated by service, read-only; Read Only -->
<dict:constraintDescriptor id="field.orgInfo.orgCodes.metaInfo.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.meta.data"/>
	<dict:constraintRef bean="constraint.read.only"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="metaInfo" id="field.orgInfo.orgCodes.metaInfo.cd" parent="field.orgInfo.orgCodes.metaInfo.cd.abstract"/>

<!-- *************************************************************************************************** -->
<!-- object structure for object.field.orgInfo.orgCodes.(default).(default).metaInfo.(default).(default) -->
<!-- *************************************************************************************************** -->
<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="object.field.orgInfo.orgCodes.metaInfo.abstract" abstract="true">
	<dict:typeRef bean="type.field.orgInfo.orgCodes.metaInfo"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="object.field.orgInfo.orgCodes.metaInfo" parent="object.field.orgInfo.orgCodes.metaInfo.abstract"/>

<dict:type key="*" id="type.field.orgInfo.orgCodes.metaInfo.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="state.field.orgInfo.orgCodes.metaInfo"/>
</dict:type>
<dict:type key="*" id="type.field.orgInfo.orgCodes.metaInfo" parent="type.field.orgInfo.orgCodes.metaInfo.abstract"/>

<!-- *********************************************************************************************************** -->
<!-- State for state.field.orgInfo.orgCodes.(default).(default).metaInfo.(default).(default).(default).(default) -->
<!-- *********************************************************************************************************** -->

<dict:state key="*" id="state.field.orgInfo.orgCodes.metaInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.orgInfo.orgCodes.metaInfo.versionInd"/>
	<dict:fieldRef bean="field.orgInfo.orgCodes.metaInfo.createTime"/>
	<dict:fieldRef bean="field.orgInfo.orgCodes.metaInfo.createId"/>
	<dict:fieldRef bean="field.orgInfo.orgCodes.metaInfo.updateTime"/>
	<dict:fieldRef bean="field.orgInfo.orgCodes.metaInfo.updateId"/>
</dict:state>
<dict:state key="*" id="state.field.orgInfo.orgCodes.metaInfo" parent="state.field.orgInfo.orgCodes.metaInfo.abstract"/>


<dict:field key="versionInd" id="field.orgInfo.orgCodes.metaInfo.versionInd.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.orgCodes.metaInfo.versionInd.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.orgCodes.metaInfo.versionInd.cd"/>
</dict:field>
<dict:field key="versionInd" id="field.orgInfo.orgCodes.metaInfo.versionInd" parent="field.orgInfo.orgCodes.metaInfo.versionInd.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.metaInfo.versionInd.fd.abstract" abstract="true">
	<dict:name>Version Indicator</dict:name>
	<dict:desc>An indicator of the version of the thing being described with this meta information. This is set by the service implementation and will be used to determine conflicts in updates.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.metaInfo.versionInd.fd" parent="field.orgInfo.orgCodes.metaInfo.versionInd.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Calculates the version indicator that is used for optimistic locking; Read Only -->
<dict:constraintDescriptor id="field.orgInfo.orgCodes.metaInfo.versionInd.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
	<dict:constraintRef bean="constraint.read.only"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="versionInd" id="field.orgInfo.orgCodes.metaInfo.versionInd.cd" parent="field.orgInfo.orgCodes.metaInfo.versionInd.cd.abstract"/>

<dict:field key="createTime" id="field.orgInfo.orgCodes.metaInfo.createTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.orgCodes.metaInfo.createTime.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.orgCodes.metaInfo.createTime.cd"/>
</dict:field>
<dict:field key="createTime" id="field.orgInfo.orgCodes.metaInfo.createTime" parent="field.orgInfo.orgCodes.metaInfo.createTime.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.metaInfo.createTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Created</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was created</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.metaInfo.createTime.fd" parent="field.orgInfo.orgCodes.metaInfo.createTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Defaults to NOW, when the object is created -->
<dict:constraintDescriptor id="field.orgInfo.orgCodes.metaInfo.createTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.default.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createTime" id="field.orgInfo.orgCodes.metaInfo.createTime.cd" parent="field.orgInfo.orgCodes.metaInfo.createTime.cd.abstract"/>

<dict:field key="createId" id="field.orgInfo.orgCodes.metaInfo.createId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.orgCodes.metaInfo.createId.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.orgCodes.metaInfo.createId.cd"/>
</dict:field>
<dict:field key="createId" id="field.orgInfo.orgCodes.metaInfo.createId" parent="field.orgInfo.orgCodes.metaInfo.createId.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.metaInfo.createId.fd.abstract" abstract="true">
	<dict:name>Created By Identifier</dict:name>
	<dict:desc>The principal who created the thing being described with this meta information</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.metaInfo.createId.fd" parent="field.orgInfo.orgCodes.metaInfo.createId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Defaults to the currently authenticated user -->
<dict:constraintDescriptor id="field.orgInfo.orgCodes.metaInfo.createId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createId" id="field.orgInfo.orgCodes.metaInfo.createId.cd" parent="field.orgInfo.orgCodes.metaInfo.createId.cd.abstract"/>

<dict:field key="updateTime" id="field.orgInfo.orgCodes.metaInfo.updateTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.orgCodes.metaInfo.updateTime.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.orgCodes.metaInfo.updateTime.cd"/>
</dict:field>
<dict:field key="updateTime" id="field.orgInfo.orgCodes.metaInfo.updateTime" parent="field.orgInfo.orgCodes.metaInfo.updateTime.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.metaInfo.updateTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Last Updated</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was last updated. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.metaInfo.updateTime.fd" parent="field.orgInfo.orgCodes.metaInfo.updateTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Sets a field to the current time -->
<dict:constraintDescriptor id="field.orgInfo.orgCodes.metaInfo.updateTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.calc.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateTime" id="field.orgInfo.orgCodes.metaInfo.updateTime.cd" parent="field.orgInfo.orgCodes.metaInfo.updateTime.cd.abstract"/>

<dict:field key="updateId" id="field.orgInfo.orgCodes.metaInfo.updateId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.orgCodes.metaInfo.updateId.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.orgCodes.metaInfo.updateId.cd"/>
</dict:field>
<dict:field key="updateId" id="field.orgInfo.orgCodes.metaInfo.updateId" parent="field.orgInfo.orgCodes.metaInfo.updateId.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.metaInfo.updateId.fd.abstract" abstract="true">
	<dict:name>Updated By Identifier</dict:name>
	<dict:desc>The principal who last updated the thing being described with this meta information. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.metaInfo.updateId.fd" parent="field.orgInfo.orgCodes.metaInfo.updateId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Sets a field to the currently authenticated user -->
<dict:constraintDescriptor id="field.orgInfo.orgCodes.metaInfo.updateId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateId" id="field.orgInfo.orgCodes.metaInfo.updateId.cd" parent="field.orgInfo.orgCodes.metaInfo.updateId.cd.abstract"/>

<dict:field key="key" id="field.orgInfo.orgCodes.key.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.orgCodes.key.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.orgCodes.key.cd"/>
</dict:field>
<dict:field key="key" id="field.orgInfo.orgCodes.key" parent="field.orgInfo.orgCodes.key.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.key.fd.abstract" abstract="true">
	<dict:name>Org Code Key</dict:name>
	<dict:desc>Unique identifier for an Organization code record.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.orgCodes.key.fd" parent="field.orgInfo.orgCodes.key.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali KEY; structured like a type but unique like and ID, used to identify configured objects. -->
<dict:constraintDescriptor id="field.orgInfo.orgCodes.key.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.key"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.orgInfo.orgCodes.key.cd" parent="field.orgInfo.orgCodes.key.cd.abstract"/>

<dict:field key="metaInfo" id="field.orgInfo.metaInfo.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.metaInfo.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.metaInfo.cd"/>
</dict:field>
<dict:field key="metaInfo" id="field.orgInfo.metaInfo" parent="field.orgInfo.metaInfo.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.metaInfo.fd.abstract" abstract="true">
	<dict:name>Create/Update meta info</dict:name>
	<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
	<dict:dataType>Complex</dict:dataType>
		<dict:objectStructureRef bean="object.field.orgInfo.metaInfo"/>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.metaInfo.fd" parent="field.orgInfo.metaInfo.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Kuali Meta Data: calculated by service, read-only; Read Only -->
<dict:constraintDescriptor id="field.orgInfo.metaInfo.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.meta.data"/>
	<dict:constraintRef bean="constraint.read.only"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="metaInfo" id="field.orgInfo.metaInfo.cd" parent="field.orgInfo.metaInfo.cd.abstract"/>

<!-- ********************************************************************** -->
<!-- object structure for object.field.orgInfo.metaInfo.(default).(default) -->
<!-- ********************************************************************** -->
<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="object.field.orgInfo.metaInfo.abstract" abstract="true">
	<dict:typeRef bean="type.field.orgInfo.metaInfo"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="object.field.orgInfo.metaInfo" parent="object.field.orgInfo.metaInfo.abstract"/>

<dict:type key="*" id="type.field.orgInfo.metaInfo.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="state.field.orgInfo.metaInfo"/>
</dict:type>
<dict:type key="*" id="type.field.orgInfo.metaInfo" parent="type.field.orgInfo.metaInfo.abstract"/>

<!-- ****************************************************************************** -->
<!-- State for state.field.orgInfo.metaInfo.(default).(default).(default).(default) -->
<!-- ****************************************************************************** -->

<dict:state key="*" id="state.field.orgInfo.metaInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.orgInfo.metaInfo.versionInd"/>
	<dict:fieldRef bean="field.orgInfo.metaInfo.createTime"/>
	<dict:fieldRef bean="field.orgInfo.metaInfo.createId"/>
	<dict:fieldRef bean="field.orgInfo.metaInfo.updateTime"/>
	<dict:fieldRef bean="field.orgInfo.metaInfo.updateId"/>
</dict:state>
<dict:state key="*" id="state.field.orgInfo.metaInfo" parent="state.field.orgInfo.metaInfo.abstract"/>


<dict:field key="versionInd" id="field.orgInfo.metaInfo.versionInd.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.metaInfo.versionInd.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.metaInfo.versionInd.cd"/>
</dict:field>
<dict:field key="versionInd" id="field.orgInfo.metaInfo.versionInd" parent="field.orgInfo.metaInfo.versionInd.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.metaInfo.versionInd.fd.abstract" abstract="true">
	<dict:name>Version Indicator</dict:name>
	<dict:desc>An indicator of the version of the thing being described with this meta information. This is set by the service implementation and will be used to determine conflicts in updates.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.metaInfo.versionInd.fd" parent="field.orgInfo.metaInfo.versionInd.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Calculates the version indicator that is used for optimistic locking; Read Only -->
<dict:constraintDescriptor id="field.orgInfo.metaInfo.versionInd.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
	<dict:constraintRef bean="constraint.read.only"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="versionInd" id="field.orgInfo.metaInfo.versionInd.cd" parent="field.orgInfo.metaInfo.versionInd.cd.abstract"/>

<dict:field key="createTime" id="field.orgInfo.metaInfo.createTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.metaInfo.createTime.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.metaInfo.createTime.cd"/>
</dict:field>
<dict:field key="createTime" id="field.orgInfo.metaInfo.createTime" parent="field.orgInfo.metaInfo.createTime.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.metaInfo.createTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Created</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was created</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.metaInfo.createTime.fd" parent="field.orgInfo.metaInfo.createTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Defaults to NOW, when the object is created -->
<dict:constraintDescriptor id="field.orgInfo.metaInfo.createTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.default.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createTime" id="field.orgInfo.metaInfo.createTime.cd" parent="field.orgInfo.metaInfo.createTime.cd.abstract"/>

<dict:field key="createId" id="field.orgInfo.metaInfo.createId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.metaInfo.createId.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.metaInfo.createId.cd"/>
</dict:field>
<dict:field key="createId" id="field.orgInfo.metaInfo.createId" parent="field.orgInfo.metaInfo.createId.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.metaInfo.createId.fd.abstract" abstract="true">
	<dict:name>Created By Identifier</dict:name>
	<dict:desc>The principal who created the thing being described with this meta information</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.metaInfo.createId.fd" parent="field.orgInfo.metaInfo.createId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Defaults to the currently authenticated user -->
<dict:constraintDescriptor id="field.orgInfo.metaInfo.createId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createId" id="field.orgInfo.metaInfo.createId.cd" parent="field.orgInfo.metaInfo.createId.cd.abstract"/>

<dict:field key="updateTime" id="field.orgInfo.metaInfo.updateTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.metaInfo.updateTime.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.metaInfo.updateTime.cd"/>
</dict:field>
<dict:field key="updateTime" id="field.orgInfo.metaInfo.updateTime" parent="field.orgInfo.metaInfo.updateTime.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.metaInfo.updateTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Last Updated</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was last updated. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.metaInfo.updateTime.fd" parent="field.orgInfo.metaInfo.updateTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Sets a field to the current time -->
<dict:constraintDescriptor id="field.orgInfo.metaInfo.updateTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.calc.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateTime" id="field.orgInfo.metaInfo.updateTime.cd" parent="field.orgInfo.metaInfo.updateTime.cd.abstract"/>

<dict:field key="updateId" id="field.orgInfo.metaInfo.updateId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.metaInfo.updateId.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.metaInfo.updateId.cd"/>
</dict:field>
<dict:field key="updateId" id="field.orgInfo.metaInfo.updateId" parent="field.orgInfo.metaInfo.updateId.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.metaInfo.updateId.fd.abstract" abstract="true">
	<dict:name>Updated By Identifier</dict:name>
	<dict:desc>The principal who last updated the thing being described with this meta information. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.metaInfo.updateId.fd" parent="field.orgInfo.metaInfo.updateId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Sets a field to the currently authenticated user -->
<dict:constraintDescriptor id="field.orgInfo.metaInfo.updateId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateId" id="field.orgInfo.metaInfo.updateId.cd" parent="field.orgInfo.metaInfo.updateId.cd.abstract"/>

<dict:field key="type" id="field.orgInfo.type.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.type.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.type.cd"/>
</dict:field>
<dict:field key="type" id="field.orgInfo.type" parent="field.orgInfo.type.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.type.fd.abstract" abstract="true">
	<dict:name>Organization Type</dict:name>
	<dict:desc>Unique identifier for an organization type.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.type.fd" parent="field.orgInfo.type.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only -->
<dict:constraintDescriptor id="field.orgInfo.type.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="type" id="field.orgInfo.type.cd" parent="field.orgInfo.type.cd.abstract"/>

<dict:field key="state" id="field.orgInfo.state.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.state.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.state.cd"/>
</dict:field>
<dict:field key="state" id="field.orgInfo.state" parent="field.orgInfo.state.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.state.fd.abstract" abstract="true">
	<dict:name>Organization State</dict:name>
	<dict:desc>The current status of the organization. The values for this field are constrained to those in the orgState enumeration. A separate setup operation does not exist for retrieval of the meta data around this value.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.state.fd" parent="field.orgInfo.state.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali STATE -->
<dict:constraintDescriptor id="field.orgInfo.state.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.state"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="state" id="field.orgInfo.state.cd" parent="field.orgInfo.state.cd.abstract"/>

<dict:field key="id" id="field.orgInfo.id.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.orgInfo.id.fd"/>
	<dict:constraintDescriptorRef bean="field.orgInfo.id.cd"/>
</dict:field>
<dict:field key="id" id="field.orgInfo.id" parent="field.orgInfo.id.abstract"/>
<dict:fieldDescriptor id="field.orgInfo.id.fd.abstract" abstract="true">
	<dict:name>Organization Id</dict:name>
	<dict:desc>This is optional, due to the identifier being set at the time of creation. Once the organization has been created, this should be seen as required.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.orgInfo.id.fd" parent="field.orgInfo.id.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Kuali ID; calculated by service on add, then read-only.; Read Only -->
<dict:constraintDescriptor id="field.orgInfo.id.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.id"/>
	<dict:constraintRef bean="constraint.read.only"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="id" id="field.orgInfo.id.cd" parent="field.orgInfo.id.cd.abstract"/>
</beans>
