<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:dict="http://student.kuali.org/xsd/dictionary-extension"
xsi:schemaLocation="
http://student.kuali.org/xsd/dictionary-extension dictionary-extension.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
">
<!-- *** Automatically Generated ***
on: Thu Feb 04 18:38:32 EST 2010
by: org.kuali.student.dictionary.writer.DictionaryModelWriter
Using:Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls   and: Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls
 -->
<import resource="constraints-dictionary-config.xml"/>

<!-- Detailed information about a learning objective -->
<dict:objectStructure key="org.kuali.student.lum.lo.dto.LoInfo" id="object.loInfo.abstract" abstract="true">
	<dict:typeRef bean="object.loInfo.type"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.lum.lo.dto.LoInfo" id="object.loInfo" parent="object.loInfo.abstract"/>

<dict:type key="(default)" id="object.loInfo.type.abstract" abstract="true">
	<dict:stateRef bean="object.loInfo.state"/>
</dict:type>
<dict:type key="kuali.lo.type.external" id="object.loInfo.type.kuali.lo.type.external" parent="object.loInfo.type.abstract">
	<dict:name>Externally-created</dict:name>
	<dict:desc>LO created by external organization, e.g., state or accrediting organization</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.lo.type.formal" id="object.loInfo.type.kuali.lo.type.formal" parent="object.loInfo.type.abstract">
	<dict:name>Formal</dict:name>
	<dict:desc>LO created as part of an established, &quot;official&quot; curriculum or program, typically requires separate approval process to add to hierarchy</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.lo.type.singleUse" id="object.loInfo.type.kuali.lo.type.singleUse" parent="object.loInfo.type.abstract">
	<dict:name>singleUse</dict:name>
	<dict:desc>LO created in support of programs or courses, e.g., faculty-inspired additional LO for a course that are not intended for others to re-use</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.lo.type.personal" id="object.loInfo.type.kuali.lo.type.personal" parent="object.loInfo.type.abstract">
	<dict:name>Personal</dict:name>
	<dict:desc>LO created by individuals in support of personal goals, e.g., student LO in Learning Plan</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>

<dict:state key="(default)" id="object.loInfo.state.abstract" abstract="true">
	<dict:fieldRef bean="field.loInfo.name"/>
	<dict:fieldRef bean="field.loInfo.desc"/>
	<dict:fieldRef bean="field.loInfo.loRepositoryKey"/>
	<dict:fieldRef bean="field.loInfo.effectiveDate"/>
	<dict:fieldRef bean="field.loInfo.expirationDate"/>
	<dict:fieldRef bean="field.loInfo.attributes"/>
	<dict:fieldRef bean="field.loInfo.metaInfo"/>
	<dict:fieldRef bean="field.loInfo.type"/>
	<dict:fieldRef bean="field.loInfo.state"/>
	<dict:fieldRef bean="field.loInfo.id"/>
</dict:state>
<dict:state key="draft" id="object.loInfo.state.draft" parent="object.loInfo.state.abstract"/>
<dict:state key="active" id="object.loInfo.state.active" parent="object.loInfo.state.abstract"/>
<dict:state key="inactive" id="object.loInfo.state.inactive" parent="object.loInfo.state.abstract"/>

<dict:field key="name" id="field.loInfo.name.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Learning Objective Name</dict:name>
		<dict:desc>Friendly name of the learning objective</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="name" id="field.loInfo.name" parent="field.loInfo.name.abstract">
</dict:field>

<dict:field key="desc" id="field.loInfo.desc.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Learning Objective Description</dict:name>
		<dict:desc>Narrative description of the learning objective</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="desc" id="field.loInfo.desc" parent="field.loInfo.desc.abstract">
</dict:field>

<dict:field key="loRepositoryKey" id="field.loInfo.loRepositoryKey.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Learning Objective Repository Key</dict:name>
		<dict:desc>Unique identifier for a learning objective Repository. This value is immutable once set during creation.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.lo.repositories"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="loRepositoryKey" id="field.loInfo.loRepositoryKey" parent="field.loInfo.loRepositoryKey.abstract">
</dict:field>

<dict:field key="effectiveDate" id="field.loInfo.effectiveDate.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Effective Date</dict:name>
		<dict:desc>Date and time that this learning objective became effective. This is a similar concept to the effective date on enumerated values. When an expiration date has been specified, this field must be less than or equal to the expiration date.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="effectiveDate" id="field.loInfo.effectiveDate" parent="field.loInfo.effectiveDate.abstract">
</dict:field>

<dict:field key="expirationDate" id="field.loInfo.expirationDate.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Expiration Date</dict:name>
		<dict:desc>Date and time that this learning objective expires. This is a similar concept to the expiration date on enumerated values. If specified, this should be greater than or equal to the effective date. If this field is not specified, then no expiration date has been currently defined and should automatically be considered greater than the effective date.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="expirationDate" id="field.loInfo.expirationDate" parent="field.loInfo.expirationDate.abstract">
</dict:field>

<dict:field key="attributes" id="field.loInfo.attributes.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Generic/dynamic attributes</dict:name>
		<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
	<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="attributes" id="field.loInfo.attributes" parent="field.loInfo.attributes.abstract">
</dict:field>

<dict:field key="metaInfo" id="field.loInfo.metaInfo.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Create/Update meta info</dict:name>
		<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="metaInfo" id="field.loInfo.metaInfo" parent="field.loInfo.metaInfo.abstract">
</dict:field>

<dict:field key="type" id="field.loInfo.type.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Learning Objective Type</dict:name>
		<dict:desc>Unique identifier for a learning objective type.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.lo.types"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="type" id="field.loInfo.type" parent="field.loInfo.type.abstract">
</dict:field>

<dict:field key="state" id="field.loInfo.state.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Learning Objective State</dict:name>
		<dict:desc>The current status of the learning objective. The values for this field are constrained to those in the loState enumeration. A separate setup operation does not exist for retrieval of the meta data around this value.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.state"/>
	</dict:constraintDescriptor>
	<dict:selector>true</dict:selector>
</dict:field>
<dict:field key="state" id="field.loInfo.state" parent="field.loInfo.state.abstract">
</dict:field>

<dict:field key="id" id="field.loInfo.id.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Learning Objective Id</dict:name>
		<dict:desc>Unique identifier for a learning objective record. This is optional, due to the identifier being set at the time of creation. Once the learning objective has been created, this should be seen as required.</dict:desc>
		<dict:dataType>string</dict:dataType>
		<dict:readOnly>true</dict:readOnly>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.read.only"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.id"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="id" id="field.loInfo.id" parent="field.loInfo.id.abstract">
</dict:field>

<!-- Detailed information about an LO to LO relationship. -->
<dict:objectStructure key="org.kuali.student.lum.lo.dto.LoLoRelationInfo" id="object.loLoRelationInfo.abstract" abstract="true">
	<dict:typeRef bean="object.loLoRelationInfo.type"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.lum.lo.dto.LoLoRelationInfo" id="object.loLoRelationInfo" parent="object.loLoRelationInfo.abstract"/>

<dict:type key="(default)" id="object.loLoRelationInfo.type.abstract" abstract="true">
	<dict:stateRef bean="object.loLoRelationInfo.state"/>
</dict:type>
<dict:type key="kuali.lo.relation.type.includes" id="object.loLoRelationInfo.type.kuali.lo.relation.type.includes" parent="object.loLoRelationInfo.type.abstract">
	<dict:name>includes</dict:name>
	<dict:desc>Parent-child relationship between a parent LO and sub LO. Currently used in the context of LOs that are related within a single CLU.</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>

<dict:state key="(default)" id="object.loLoRelationInfo.state.abstract" abstract="true">
	<dict:fieldRef bean="field.loLoRelationInfo.loId"/>
	<dict:fieldRef bean="field.loLoRelationInfo.relatedLoId"/>
	<dict:fieldRef bean="field.loLoRelationInfo.effectiveDate"/>
	<dict:fieldRef bean="field.loLoRelationInfo.expirationDate"/>
	<dict:fieldRef bean="field.loLoRelationInfo.attributes"/>
	<dict:fieldRef bean="field.loLoRelationInfo.metaInfo"/>
	<dict:fieldRef bean="field.loLoRelationInfo.type"/>
	<dict:fieldRef bean="field.loLoRelationInfo.state"/>
	<dict:fieldRef bean="field.loLoRelationInfo.id"/>
</dict:state>
<dict:state key="draft" id="object.loLoRelationInfo.state.draft" parent="object.loLoRelationInfo.state.abstract"/>
<dict:state key="active" id="object.loLoRelationInfo.state.active" parent="object.loLoRelationInfo.state.abstract"/>
<dict:state key="inactive" id="object.loLoRelationInfo.state.inactive" parent="object.loLoRelationInfo.state.abstract"/>

<dict:field key="loId" id="field.loLoRelationInfo.loId.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>LO Identifier</dict:name>
		<dict:desc>Unique identifier for a learning objective record. This is the &quot;From&quot; or &quot;Parent&quot; in the relation.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="loId" id="field.loLoRelationInfo.loId" parent="field.loLoRelationInfo.loId.abstract">
</dict:field>

<dict:field key="relatedLoId" id="field.loLoRelationInfo.relatedLoId.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Related LO Identifier</dict:name>
		<dict:desc>Unique identifier for a learning objective record. This is the &quot;To&quot; or &quot;Child&quot; of the relation.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="relatedLoId" id="field.loLoRelationInfo.relatedLoId" parent="field.loLoRelationInfo.relatedLoId.abstract">
</dict:field>

<dict:field key="effectiveDate" id="field.loLoRelationInfo.effectiveDate.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Effective Date</dict:name>
		<dict:desc>Date and time that this LO to LO relationship became effective. This is a similar concept to the effective date on enumerated values. When an expiration date has been specified, this field must be less than or equal to the expiration date.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="effectiveDate" id="field.loLoRelationInfo.effectiveDate" parent="field.loLoRelationInfo.effectiveDate.abstract">
</dict:field>

<dict:field key="expirationDate" id="field.loLoRelationInfo.expirationDate.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Expiration Date</dict:name>
		<dict:desc>Date and time that this LO to LO relationship expires. This is a similar concept to the expiration date on enumerated values. If specified, this should be greater than or equal to the effective date. If this field is not specified, then no expiration date has been currently defined and should automatically be considered greater than the effective date.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="expirationDate" id="field.loLoRelationInfo.expirationDate" parent="field.loLoRelationInfo.expirationDate.abstract">
</dict:field>

<dict:field key="attributes" id="field.loLoRelationInfo.attributes.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Generic/dynamic attributes</dict:name>
		<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="attributes" id="field.loLoRelationInfo.attributes" parent="field.loLoRelationInfo.attributes.abstract">
</dict:field>

<dict:field key="metaInfo" id="field.loLoRelationInfo.metaInfo.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Create/Update meta info</dict:name>
		<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="metaInfo" id="field.loLoRelationInfo.metaInfo" parent="field.loLoRelationInfo.metaInfo.abstract">
</dict:field>

<dict:field key="type" id="field.loLoRelationInfo.type.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>LO to LO Relation Type</dict:name>
		<dict:desc>Unique identifier for the LO to LO relation type.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.lo.lo.relation.types"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="type" id="field.loLoRelationInfo.type" parent="field.loLoRelationInfo.type.abstract">
</dict:field>

<dict:field key="state" id="field.loLoRelationInfo.state.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>LO to LO Relation State</dict:name>
		<dict:desc>Identifier for the current status of a LO to LO relationship. The values for this field are constrained to those in the luLuRelationState enumeration. A separate setup operation does not exist for retrieval of the meta data around this value.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.state"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="state" id="field.loLoRelationInfo.state" parent="field.loLoRelationInfo.state.abstract">
</dict:field>

<dict:field key="id" id="field.loLoRelationInfo.id.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>LO to LO Relation Identifier</dict:name>
		<dict:desc>Unique identifier for a LO to LO relationship. This is optional, due to the identifier being set at the time of creation. Once the relation has been created, this should be seen as required.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.id"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="id" id="field.loLoRelationInfo.id" parent="field.loLoRelationInfo.id.abstract">
</dict:field>

<!-- Detailed information about a learning objective category. -->
<dict:objectStructure key="org.kuali.student.lum.lo.dto.LoCategoryInfo" id="object.loCategoryInfo.abstract" abstract="true">
	<dict:typeRef bean="object.loCategoryInfo.type"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.lum.lo.dto.LoCategoryInfo" id="object.loCategoryInfo" parent="object.loCategoryInfo.abstract"/>

<dict:type key="(default)" id="object.loCategoryInfo.type.abstract" abstract="true">
	<dict:stateRef bean="object.loCategoryInfo.state"/>
</dict:type>
<dict:type key="kuali.lo.category.type.*" id="object.loCategoryInfo.type.kuali.lo.category.type._" parent="object.loCategoryInfo.type.abstract">
	<dict:name>all categories</dict:name>
	<dict:desc>all lo categories</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.lo.category.type.accreditation" id="object.loCategoryInfo.type.kuali.lo.category.type.accreditation" parent="object.loCategoryInfo.type.abstract">
	<dict:name>accreditation</dict:name>
	<dict:desc>Categories that are specific to or defined by an accreditation body</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.lo.category.type.skill" id="object.loCategoryInfo.type.kuali.lo.category.type.skill" parent="object.loCategoryInfo.type.abstract">
	<dict:name>skill</dict:name>
	<dict:desc>Categories that are representative of skill sets</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.lo.category.type.subject" id="object.loCategoryInfo.type.kuali.lo.category.type.subject" parent="object.loCategoryInfo.type.abstract">
	<dict:name>subject</dict:name>
	<dict:desc>Categories that are representative of content areas</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>

<dict:state key="(default)" id="object.loCategoryInfo.state.abstract" abstract="true">
	<dict:fieldRef bean="field.loCategoryInfo.name"/>
	<dict:fieldRef bean="field.loCategoryInfo.desc"/>
	<dict:fieldRef bean="field.loCategoryInfo.loRepository"/>
	<dict:fieldRef bean="field.loCategoryInfo.effectiveDate"/>
	<dict:fieldRef bean="field.loCategoryInfo.expirationDate"/>
	<dict:fieldRef bean="field.loCategoryInfo.attributes"/>
	<dict:fieldRef bean="field.loCategoryInfo.metaInfo"/>
	<dict:fieldRef bean="field.loCategoryInfo.type"/>
	<dict:fieldRef bean="field.loCategoryInfo.state"/>
	<dict:fieldRef bean="field.loCategoryInfo.id"/>
</dict:state>
<dict:state key="inactive" id="object.loCategoryInfo.state.inactive" parent="object.loCategoryInfo.state.abstract"/>
<dict:state key="active" id="object.loCategoryInfo.state.active" parent="object.loCategoryInfo.state.abstract"/>

<dict:field key="name" id="field.loCategoryInfo.name.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Learning Objective Category Name</dict:name>
		<dict:desc>Friendly name of the category</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="name" id="field.loCategoryInfo.name" parent="field.loCategoryInfo.name.abstract">
</dict:field>

<dict:field key="desc" id="field.loCategoryInfo.desc.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Learning Objective Category Description</dict:name>
		<dict:desc>Narrative description of the learning objective category</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="desc" id="field.loCategoryInfo.desc" parent="field.loCategoryInfo.desc.abstract">
</dict:field>

<dict:field key="loRepository" id="field.loCategoryInfo.loRepository.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Learning Objective Repository Key</dict:name>
		<dict:desc>Unique identifier for a learning objective repository. Once set in creation, this is immutable.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.lo.hierarchy.types"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="loRepository" id="field.loCategoryInfo.loRepository" parent="field.loCategoryInfo.loRepository.abstract">
</dict:field>

<dict:field key="effectiveDate" id="field.loCategoryInfo.effectiveDate.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Effective Date</dict:name>
		<dict:desc>Date and time that this learning objective category became effective. This is a similar concept to the effective date on enumerated values. When an expiration date has been specified, this field must be less than or equal to the expiration date.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="effectiveDate" id="field.loCategoryInfo.effectiveDate" parent="field.loCategoryInfo.effectiveDate.abstract">
</dict:field>

<dict:field key="expirationDate" id="field.loCategoryInfo.expirationDate.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Expiration Date</dict:name>
		<dict:desc>Date and time that this learning objective category expires. This is a similar concept to the expiration date on enumerated values. If specified, this should be greater than or equal to the effective date. If this field is not specified, then no expiration date has been currently defined and should automatically be considered greater than the effective date.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="expirationDate" id="field.loCategoryInfo.expirationDate" parent="field.loCategoryInfo.expirationDate.abstract">
</dict:field>

<dict:field key="attributes" id="field.loCategoryInfo.attributes.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Generic/dynamic attributes</dict:name>
		<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="attributes" id="field.loCategoryInfo.attributes" parent="field.loCategoryInfo.attributes.abstract">
</dict:field>

<dict:field key="metaInfo" id="field.loCategoryInfo.metaInfo.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Create/Update meta info</dict:name>
		<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="metaInfo" id="field.loCategoryInfo.metaInfo" parent="field.loCategoryInfo.metaInfo.abstract">
</dict:field>

<dict:field key="type" id="field.loCategoryInfo.type.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Learning Objective Category Type</dict:name>
		<dict:desc>Unique identifier for a learning objective category type.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="type" id="field.loCategoryInfo.type" parent="field.loCategoryInfo.type.abstract">
</dict:field>

<dict:field key="state" id="field.loCategoryInfo.state.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Learning Objective Category State</dict:name>
		<dict:desc>The current status of the learning objective category. The values for this field are constrained to those in the loCategoryState enumeration. A separate setup operation does not exist for retrieval of the meta data around this value.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="state" id="field.loCategoryInfo.state" parent="field.loCategoryInfo.state.abstract">
</dict:field>

<dict:field key="id" id="field.loCategoryInfo.id.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Learning Objective Category Identifier</dict:name>
		<dict:desc>Unique identifier for a learning objective category record. This is optional, due to the identifier being set at the time of creation. Once the learning objective category has been created, this should be seen as required.</dict:desc>
		<dict:dataType>string</dict:dataType>
		<dict:readOnly>true</dict:readOnly>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.read.only"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.id"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="id" id="field.loCategoryInfo.id" parent="field.loCategoryInfo.id.abstract">
</dict:field>

<!-- Complex type supporting both a plain text and formatted version of a string. -->
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="object.richTextInfo.abstract" abstract="true">
	<dict:typeRef bean="object.richTextInfo.type"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="object.richTextInfo" parent="object.richTextInfo.abstract"/>

<dict:type key="(default)" id="object.richTextInfo.type.abstract" abstract="true">
	<dict:stateRef bean="object.richTextInfo.state"/>
</dict:type>
<dict:type key="kuali.not.applicable" id="object.richTextInfo.type.kuali.not.applicable" parent="object.richTextInfo.type.abstract">
	<dict:name>(n/a)</dict:name>
	<dict:desc>Not applicable</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>

<dict:state key="(default)" id="object.richTextInfo.state.abstract" abstract="true">
	<dict:fieldRef bean="field.richTextInfo.plain"/>
	<dict:fieldRef bean="field.richTextInfo.formatted"/>
</dict:state>
<dict:state key="(n/a)" id="object.richTextInfo.state.NA" parent="object.richTextInfo.state.abstract"/>

<dict:field key="plain" id="field.richTextInfo.plain.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Plain Text</dict:name>
		<dict:desc>Plain version of the text. This may be used for searching.</dict:desc>
		<dict:dataType>string</dict:dataType>
		<dict:readOnly>true</dict:readOnly>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.read.only"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.multi.line.text"/>
			<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
				<dict:maxLength>(unbounded)</dict:maxLength>
				</dict:constraint>
			<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
				<dict:maxLength>(unbounded)</dict:maxLength>
				</dict:constraint>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="plain" id="field.richTextInfo.plain" parent="field.richTextInfo.plain.abstract">
</dict:field>

<dict:field key="formatted" id="field.richTextInfo.formatted.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Formatted Text</dict:name>
		<dict:desc>Formatted version of the text.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.rich.text"/>
			<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
				<dict:maxLength>(unbounded)</dict:maxLength>
				</dict:constraint>
			<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
				<dict:maxLength>(unbounded)</dict:maxLength>
				</dict:constraint>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="formatted" id="field.richTextInfo.formatted" parent="field.richTextInfo.formatted.abstract">
</dict:field>

<!-- List of key/value pairs, typically used for dynamic attributes. -->
<dict:objectStructure key=".AttributeInfo" id="object.attributeInfo.abstract" abstract="true">
	<dict:typeRef bean="object.attributeInfo.type"/>
</dict:objectStructure>
<dict:objectStructure key=".AttributeInfo" id="object.attributeInfo" parent="object.attributeInfo.abstract"/>

<dict:type key="(default)" id="object.attributeInfo.type.abstract" abstract="true">
	<dict:stateRef bean="object.attributeInfo.state"/>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color" id="object.attributeInfo.type.kuali.lu.type.CreditCourse.dynamic.eye.color" parent="object.attributeInfo.type.abstract">
	<dict:name>Eye Color</dict:name>
	<dict:desc>Captures the eye color of students expected to take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed" id="object.attributeInfo.type.kuali.lu.type.CreditCourse.dynamic.left.handed" parent="object.attributeInfo.type.abstract">
	<dict:name>Left Handed</dict:name>
	<dict:desc>Captures if the students are expected to be left handed who take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.lo.type.SingleUse.dynamic.sequence" id="object.attributeInfo.type.kuali.lo.type.SingleUse.dynamic.sequence" parent="object.attributeInfo.type.abstract">
	<dict:name>Sequence</dict:name>
	<dict:desc>Captures the sequence of an LO within a Credit Course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>

<dict:state key="(default)" id="object.attributeInfo.state.abstract" abstract="true">
	<dict:fieldRef bean="field.attributeInfo.value"/>
	<dict:fieldRef bean="field.attributeInfo.key"/>
</dict:state>
<dict:state key="(n/a)" id="object.attributeInfo.state.NA" parent="object.attributeInfo.state.abstract"/>

<dict:field key="value" id="field.attributeInfo.value.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Attribute Value</dict:name>
		<dict:desc>The value for this dynamic attribute.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
				<dict:maxLength>(unbounded)</dict:maxLength>
				</dict:constraint>
			<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
				<dict:maxLength>(unbounded)</dict:maxLength>
				</dict:constraint>
	</dict:constraintDescriptor>
	<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.attributeInfo.value" parent="field.attributeInfo.value.abstract">
</dict:field>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.attributeInfo.key.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Attribute Type Identifier</dict:name>
		<dict:desc>The identifier for this attribute.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.type"/>
			<dict:constraintRef bean="constraint.dynamic.field.types"/>
	</dict:constraintDescriptor>
	<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.attributeInfo.key" parent="field.attributeInfo.key.abstract">
</dict:field>

<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="object.metaInfo.abstract" abstract="true">
	<dict:typeRef bean="object.metaInfo.type"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="object.metaInfo" parent="object.metaInfo.abstract"/>

<dict:type key="(default)" id="object.metaInfo.type.abstract" abstract="true">
	<dict:stateRef bean="object.metaInfo.state"/>
</dict:type>
<dict:type key="kuali.not.applicable" id="object.metaInfo.type.kuali.not.applicable" parent="object.metaInfo.type.abstract">
	<dict:name>(n/a)</dict:name>
	<dict:desc>Not applicable</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>

<dict:state key="(default)" id="object.metaInfo.state.abstract" abstract="true">
	<dict:fieldRef bean="field.metaInfo.versionInd"/>
	<dict:fieldRef bean="field.metaInfo.createTime"/>
	<dict:fieldRef bean="field.metaInfo.createId"/>
	<dict:fieldRef bean="field.metaInfo.updateTime"/>
	<dict:fieldRef bean="field.metaInfo.updateId"/>
</dict:state>
<dict:state key="(n/a)" id="object.metaInfo.state.NA" parent="object.metaInfo.state.abstract"/>

<dict:field key="versionInd" id="field.metaInfo.versionInd.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Version Indicator</dict:name>
		<dict:desc>An indicator of the version of the thing being described with this meta information. This is set by the service implementation and will be used to determine conflicts in updates.</dict:desc>
		<dict:dataType>string</dict:dataType>
		<dict:readOnly>true</dict:readOnly>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
			<dict:constraintRef bean="constraint.read.only"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="versionInd" id="field.metaInfo.versionInd" parent="field.metaInfo.versionInd.abstract">
</dict:field>

<dict:field key="createTime" id="field.metaInfo.createTime.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Date/Time Created</dict:name>
		<dict:desc>The date and time the thing being described with this meta information was created</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
			<dict:constraintRef bean="constraint.default.now"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="createTime" id="field.metaInfo.createTime" parent="field.metaInfo.createTime.abstract">
</dict:field>

<dict:field key="createId" id="field.metaInfo.createId.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Created By Identifier</dict:name>
		<dict:desc>The principal who created the thing being described with this meta information</dict:desc>
		<dict:dataType>string</dict:dataType>
		<dict:readOnly>true</dict:readOnly>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.read.only"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.related.principalId"/>
			<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="createId" id="field.metaInfo.createId" parent="field.metaInfo.createId.abstract">
</dict:field>

<dict:field key="updateTime" id="field.metaInfo.updateTime.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Date/Time Last Updated</dict:name>
		<dict:desc>The date and time the thing being described with this meta information was last updated. This would be filled in on initial creation as well.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
			<dict:constraintRef bean="constraint.calc.now"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="updateTime" id="field.metaInfo.updateTime" parent="field.metaInfo.updateTime.abstract">
</dict:field>

<dict:field key="updateId" id="field.metaInfo.updateId.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Updated By Identifier</dict:name>
		<dict:desc>The principal who last updated the thing being described with this meta information. This would be filled in on initial creation as well.</dict:desc>
		<dict:dataType>string</dict:dataType>
		<dict:readOnly>true</dict:readOnly>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.read.only"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.related.principalId"/>
			<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="updateId" id="field.metaInfo.updateId" parent="field.metaInfo.updateId.abstract">
</dict:field>
</beans>
