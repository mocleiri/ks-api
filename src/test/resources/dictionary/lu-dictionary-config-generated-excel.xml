<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:dict="http://student.kuali.org/xsd/dictionary-extension"
xsi:schemaLocation="
http://student.kuali.org/xsd/dictionary-extension dictionary-extension.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
">
<!-- *** Automatically Generated ***
on: Tue Dec 08 20:15:42 EST 2009
by: org.kuali.student.dictionary.DictionaryModelWriter
Using:Excel Spreadsheet src/test/resources/dictionary/type-state configuration.xls
 -->

	<dict:constraint key="required" id="required" serverSide="false">
		<!-- Required -->
		<dict:minOccurs>1</dict:minOccurs>
		</dict:constraint>

	<dict:constraint key="optional" id="optional" serverSide="false">
		<!-- Optional -->
		<!-- Used to override a previous required constraint.  Also implied by the absence of a required constraint -->
		<dict:minOccurs>0</dict:minOccurs>
		</dict:constraint>

	<dict:constraint key="not.used" id="not.used" serverSide="false">
		<!-- Not Used -->
		<dict:minOccurs>0</dict:minOccurs>
		<dict:maxOccurs>0</dict:maxOccurs>
		</dict:constraint>

	<dict:constraint key="repeating" id="repeating" serverSide="false">
		<!-- Repeating -->
		<!-- Nine 9's get translated as "(unbounded)" -->
		<dict:maxOccurs>(unbounded)</dict:maxOccurs>
		</dict:constraint>

	<dict:constraint key="single" id="single" serverSide="false">
		<!-- Single valued (non-repeating) -->
		<!-- Used to override a repeating constraint -->
		<dict:maxOccurs>1</dict:maxOccurs>
		</dict:constraint>

	<dict:constraint key="code" id="code" serverSide="false">
		<!-- Alphanumeric code, hypen and period. -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="code.uppercase" id="code.uppercase" serverSide="false">
		<!-- uppercase alphanumeric code, hypen and period. -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[A-Z0-9.-]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="code.lowercase" id="code.lowercase" serverSide="false">
		<!-- lowercase alphanumeric code, hypen and period. -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[a-z0-9.-]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="single.line.text" id="single.line.text" serverSide="false">
		<!-- A basic single line of text, no embedded carraige returns or tabs limited to 255 -->
		<!-- old reg ex was "[A-Za-z0-9.-;;'&%$#@!]* -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>255</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[\p{Print} ]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="letter" id="letter" serverSide="false">
		<!-- letters only -->
		<dict:validChars>
		<dict:value>regex:[A-Za-z]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="size.one" id="size.one" serverSide="false">
		<!-- Only one character -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>1</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="size.two" id="size.two" serverSide="false">
		<!-- Two characters both must be filled out. -->
		<dict:minLength>2</dict:minLength>
		<dict:maxLength>2</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="size.up.to.two" id="size.up.to.two" serverSide="false">
		<!-- Up to 2 characters long -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>2</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="no.linefeeds" id="no.linefeeds" serverSide="false">
		<!-- Any character EXCEPT carraige returns and line feeds -->
		<dict:validChars>
		<dict:value>regex:[^\n\r]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="no.tabs" id="no.tabs" serverSide="false">
		<!-- Any character EXCEPT a tab -->
		<dict:validChars>
		<dict:value>regex:[^\t]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="multi.line.text" id="multi.line.text" serverSide="false">
		<!-- Multi-line text field that accepts all printable characters plus tab, carraige-return and linefeed. -->
		<!-- old reg ex was [A-Za-z0-9.-;;'&%$#@!\n\r\t]* -->
		<dict:minLength>1</dict:minLength>
		<dict:validChars>
		<dict:value>regex:[\p{Print}\p{Blank}\n\r]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="rich.text" id="rich.text" serverSide="false">
		<!-- Text field that accepts all types of characters using some sort of escaping convention along with the ability to specify bolding, font size, color etc. -->
		<!-- Not sure if characterset for rich text is the same for regular text but just interpretted differently.  I.e. html is plain text interpreted differently. -->
		<dict:minLength>1</dict:minLength>
		<dict:validChars>
		<dict:value>regex:[\p{Print}\p{Blank}\n\r]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="date" id="date" serverSide="false">
		<!-- Date -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=760 (but not sure) -->
		<dict:minLength>10</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="date.time" id="date.time" serverSide="false">
		<!-- Date-Time -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=1966 (but not sure) -->
		<dict:minLength>19</dict:minLength>
		<dict:maxLength>19</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="integer" id="integer" serverSide="false">
		<!-- Integer -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=14 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:^(\+|-)?\d+$</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="non-negative.integer" id="non-negative.integer" serverSide="false">
		<!-- Non-Negative Integer -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=13 -->
		<dict:minValue>0</dict:minValue>
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:^\d+$</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="decimal" id="decimal" serverSide="false">
		<!-- decimal number -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=117 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:^[-+]?\d+(\.\d+)?$</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="non.negative.decimal" id="non.negative.decimal" serverSide="false">
		<!-- non-negative decimal number -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=117 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:^[-+]?\d+(\.\d+)?$</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="amount" id="amount" serverSide="false">
		<!-- Amount field -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=131 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:^\$?\d+(\.(\d{2}))?$</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="url" id="url" serverSide="false">
		<!-- Uniform Resource Locator -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=96 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>2083</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&amp;amp;:/~\+#]*[\w\-\@?^=%&amp;amp;/~\+#])?</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="boolean" id="boolean" serverSide="false">
		<!-- True or False -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=905 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>5</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[Ff]+(alse)?|[Tt]+(rue)</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="kuali.id" id="kuali.id" className="org.kuali.student.core.validation.KualiIdValidator" serverSide="true">
		<!-- Kuali ID; calculated by service on add, then read-only. -->
		<!-- MinOccur on ID's of 1 may not work because it is missing on the create -->
		<dict:minOccurs>1</dict:minOccurs>
		<dict:maxOccurs>1</dict:maxOccurs>
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="kuali.key" id="kuali.key" className="org.kuali.student.core.validation.KualiTypeValidator" serverSide="true">
		<!-- Kuali KEY; structured like a type but unique like and ID, used to identify configured objects. -->
		<dict:minOccurs>1</dict:minOccurs>
		<dict:maxOccurs>1</dict:maxOccurs>
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="kuali.type" id="kuali.type" serverSide="true">
		<!-- Kuali TYPE: required on add, then read-only -->
		<dict:minOccurs>1</dict:minOccurs>
		<dict:maxOccurs>1</dict:maxOccurs>
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="kuali.state" id="kuali.state" serverSide="true">
		<!-- Kuali STATE -->
		<dict:minOccurs>1</dict:minOccurs>
		<dict:maxOccurs>1</dict:maxOccurs>
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="kuali.meta.data" id="kuali.meta.data" className="org.kuali.student.core.validation.KualiMetaDataValidator" serverSide="true">
		<!-- Kuali Meta Data: calculated by service, read-only -->
		<!-- MinOccur on Meta data structures may not 1 not work because it is not supplied  on the create -->
		<dict:minOccurs>1</dict:minOccurs>
		<dict:maxOccurs>1</dict:maxOccurs>
		</dict:constraint>

	<dict:constraint key="related.cluId" id="related.cluId" className="org.kuali.student.lum.lu.validation.CluIdExistsValidator" serverSide="true">
		<!-- Id of an existing CLU -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="related.clu.set.id" id="related.clu.set.id" className="org.kuali.student.lum.lu.validation.CluSetIdExistsValidator" serverSide="true">
		<!-- Id of an existing CLU Set Id -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="related.orgId" id="related.orgId" className="org.kuali.student.core.org.validation.OrgIdExistsValidator" serverSide="true">
		<!-- Id of an existing ORG -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="related.principalId" id="related.principalId" className="org.kuali.student.core.auth.validation.PrincipaldExistsValidator" serverSide="true">
		<!-- Id of an existing PRINCIPAL -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="related.personId" id="related.personId" className="org.kuali.student.core.person.validation.PersonIddExistsValidator" serverSide="true">
		<!-- Id of an existing PERSON -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="related.gradekey" id="related.gradekey" className="org.kuali.student.lum.lrc.validation.GradeExistsValidator" serverSide="true">
		<!-- Key of an existing Grade -->
		<!-- Requires special logic to check that the key supplied actuall exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="related.creditkey" id="related.creditkey" className="org.kuali.student.lum.lrc.validation.CreditExistsValidator" serverSide="true">
		<!-- Key of an existing Credit -->
		<!-- Requires special logic to check that the key supplied actuall exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="related.credentialkey" id="related.credentialkey" className="org.kuali.student.lum.lrc.validation.credentialExistsValidator" serverSide="true">
		<!-- Key of an existin Credential -->
		<!-- Requires special logic to check that the key supplied actuall exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="related.proposal" id="related.proposal" className="org.kuali.student.core.proposal.validation.ProposalIdExistsValidator" serverSide="true">
		<!-- Id of an existing PROPOSAL -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="related.document" id="related.document" className="org.kuali.student.core.document.validation.DocumentIdExistsValidator" serverSide="true">
		<!-- Id of an existing DOCUMENT -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="lu.types" id="lu.types" serverSide="false">
		<!-- In list of configured learning unit types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.identifier.types" id="lu.identifier.types" serverSide="false">
		<!-- In list of configured clu identifier types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.identifier.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.activity.types" id="lu.activity.types" serverSide="false">
		<!-- In a list of configured activity LuTypes -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.activity.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="duration.types" id="duration.types" serverSide="false">
		<!-- In list of configured duration types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.durationTypes">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="instructional.format.types" id="instructional.format.types" serverSide="false">
		<!-- In list of configured instructional formats -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:lookup search="kuali.enum.type.instructionalFormatTypes">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="season.types" id="season.types" serverSide="false">
		<!-- In list of configured seasons -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.seasonTypes">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="atp.types" id="atp.types" serverSide="false">
		<!-- In list of configured  time period types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.atpTypes">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="dynamic.field.types" id="dynamic.field.types" serverSide="false">
		<!-- In list of configured dynamic field types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.dynamicFieldTypes">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.lo.relation.types" id="lu.lo.relation.types" serverSide="false">
		<!-- In list of configured lu-lo relation types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.lo.relation.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.lu.relation.types" id="lu.lu.relation.types" serverSide="false">
		<!-- In list of configured lul-lu relation types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.lu.relation.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.code.types" id="lu.code.types" serverSide="false">
		<!-- In list of configured classification codes used for LU -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.code.type">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="currency.types" id="currency.types" serverSide="false">
		<!-- In list of configured currency types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.currency.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lo.category.types" id="lo.category.types" serverSide="false">
		<!-- In list of lo category types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lo.category.type">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lo.types" id="lo.types" serverSide="false">
		<!-- In list of confured lo types -->
		<!-- TO DO: add to SimpleS -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lo.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lo.lo.relation.types" id="lo.lo.relation.types" serverSide="false">
		<!-- In list of configured lo-lo relationship types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lo.lo.relation.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lo.repositories" id="lo.repositories" serverSide="false">
		<!-- In list of configured lo repositories -->
		<!-- TO DO: add to SimpleS -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lo.repositories">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="cluResult.types" id="cluResult.types" serverSide="false">
		<!-- In list of configured cluResultTypes -->
		<!-- TO DO: add to SimpleS -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.cluResult.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="resultUsage.types" id="resultUsage.types" serverSide="false">
		<!-- In list of confured resultUsage types -->
		<!-- TO DO: add to Simple Spec -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.resultUsage.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="proposal.types" id="proposal.types" serverSide="false">
		<!-- In a list of configured proposal types -->
		<!-- TO DO: add to SimpleS -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.proposal.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="course.proposal.types" id="course.proposal.types" serverSide="false">
		<!-- In a list of configured course proposal types -->
		<!-- TO DO: add to SimpleS -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.course.proposal.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="program.proposal.types" id="program.proposal.types" serverSide="false">
		<!-- In a list of configured program proposal types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.program.proposal.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lo.hierarchy.types" id="lo.hierarchy.types" serverSide="false">
		<!-- In a list of configured program lo hierarchy types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lo.hierarchy.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="reference.types" id="reference.types" serverSide="false">
		<!-- In a list of configured reference types -->
		<!-- TO DO: add to SimpleS -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.reference.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.states" id="lu.states" serverSide="false">
		<!-- In list of configured learning unit states -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.states">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.identifier.states" id="lu.identifier.states" serverSide="false">
		<!-- In list of configured clu identifier states -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.identifier.states">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="subject.areas" id="subject.areas" serverSide="false">
		<!-- In list of configured subject areas -->
		<dict:minLength>4</dict:minLength>
		<dict:maxLength>4</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[A-Z]*</dict:value>
		</dict:validChars>
		<dict:lookup search="kuali.enum.type.subjectArea">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="available.course.numbers" id="available.course.numbers" serverSide="false">
		<!-- In list of configured available course numbers -->
		<dict:minLength>3</dict:minLength>
		<dict:maxLength>3</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[0-9]*</dict:value>
		</dict:validChars>
		<dict:lookup search="kuali.enum.type.availableNumbers">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="offering.campuses" id="offering.campuses" serverSide="false">
		<!-- In list of configured offering campuses -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:lookup search="kuali.enum.type.offeringCampuses">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="unit.types" id="unit.types" serverSide="false">
		<!-- In list of configured unit types -->
		<!-- Although called a type, this is not a formal type in kuali student like an lu type, for example it may be changeable after being added. -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:lookup search="kuali.enum.type.validUnitTypes">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="eye.colors" id="eye.colors" serverSide="false">
		<!-- In a list of configured eye colors -->
		<!-- Blue, Brown, Green, Hazel, etc -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:lookup search="kuali.enum.type.validEyeColors">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="grade.scales" id="grade.scales" serverSide="false">
		<!-- In a list of configured grading scales -->
		<dict:lookup search="kuali.enum.type.grade.scales">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="effective.date.atps" id="effective.date.atps" serverSide="false">
		<!-- In a list of configured ATPs -->
		<!-- Not entirely sure what to call this. There is also a kuali.enum.type.EffectiveDateATPs defined for the which is backed by this enumeration (its further constrained) but I don't know that it needs to be represented that way. -->
		<dict:lookup search="kuali.enum.type.ATPsByDate">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="hard.coded.type.credit.course" id="hard.coded.type.credit.course" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.lu.type.CreditCourse" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.CreditCourse</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.type.credit.course.format.shell" id="hard.coded.type.credit.course.format.shell" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.lu.type.CreditCourseFormatShell" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.CreditCourseFormatShell</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.type.program" id="hard.coded.type.program" serverSide="true">
		<!-- Must be "kuali.lu.type.Program" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.Program</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.type.program.level" id="hard.coded.type.program.level" serverSide="true">
		<!-- Must be "kuali.lu.type.ProgramLevel" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.ProgramLevel</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.type.program.type" id="hard.coded.type.program.type" serverSide="true">
		<!-- Must be "kuali.lu.type.ProgramType" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.ProgramType</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.type.degree.level" id="hard.coded.type.degree.level" serverSide="true">
		<!-- Must be "kuali.lu.type.DegreeLevel" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.DegreeLevel</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.type.degree.type" id="hard.coded.type.degree.type" serverSide="true">
		<!-- Must be "kuali.lu.type.DegreeType" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.DegreeType</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.type.major" id="hard.coded.type.major" serverSide="true">
		<!-- Must be "kuali.lu.type.Major" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.Major</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.type.minor" id="hard.coded.type.minor" serverSide="true">
		<!-- Must be "kuali.lu.type.Minor" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.Minor</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.type.general.ed" id="hard.coded.type.general.ed" serverSide="true">
		<!-- Must be "kuali.lu.type.GeneralEd" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.GeneralEd</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.type.honors" id="hard.coded.type.honors" serverSide="true">
		<!-- Must be "kuali.lu.type.Honors" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.Honors</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.official" id="hard.coded.official" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.lu.type.CreditCourse.identifier.official" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.CreditCourse\.identifier\.official</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.active" id="hard.coded.active" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "active" -->
		<dict:validChars>
		<dict:value>regex:active</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.cross-listed" id="hard.coded.cross-listed" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.lu.type.CreditCourse.identifier.cross-listed" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.CreditCourse\.identifier\.cross-listed</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.co-located" id="hard.coded.co-located" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.lu.relation.type.co-located" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.relation\.type\.co-located</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.lulurelation.courseformat" id="hard.coded.lulurelation.courseformat" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.lu.lu.relation.type.hasCourseFormat" -->
		<dict:validChars>
		<dict:value>regex:kulai\.lu\.lu\.relation\.type\.hasCourseFormat</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.lulurelation.programlevel" id="hard.coded.lulurelation.programlevel" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.lu.lu.relation.type.hasProgramLevel" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.lu\.relation\.type\.hasProgramLevel</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.lulurelation.programtype" id="hard.coded.lulurelation.programtype" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.lu.lu.relation.type.hasProgramType" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.lu\.relation\.type\.hasProgramType</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.version" id="hard.coded.version" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.lu.type.CreditCourse.identifier.version" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.CreditCourse\.identifier\.version</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.zero" id="hard.coded.zero" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be 0 -->
		<dict:validChars>
		<dict:value>regex:0</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.one" id="hard.coded.one" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be 1 -->
		<dict:validChars>
		<dict:value>regex:1</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.true" id="hard.coded.true" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be TRUE -->
		<dict:validChars>
		<dict:value>regex:true</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.false" id="hard.coded.false" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be FALSE -->
		<dict:validChars>
		<dict:value>regex:false</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.eye.color" id="hard.coded.eye.color" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.lu.type.CreditCourse.dynamic.eye.color" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.CreditCourse\.dynamic\.eye\.color</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.left.handed" id="hard.coded.left.handed" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.lu.type.CreditCourse.dynamic.left.handed" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.CreditCourse\.dynamic\.left\.handed</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.singleUse.lo" id="hard.coded.singleUse.lo" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- must be "kuali.lo.type.singleUse" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lo\.type\.singleUse</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.unclassified.lo.category" id="hard.coded.unclassified.lo.category" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- must be "kuali.lo.category.type.unclassified" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lo\.category\.type\.unclassified</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.accreditation.lo.category" id="hard.coded.accreditation.lo.category" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- must be "kuali.lo.category.type.accreditation" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lo\.category\.type\.accreditation</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.skill.lo.category" id="hard.coded.skill.lo.category" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- must be "kuali.lo.category.type.skill" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lo\.category\.type\.skill</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.subject.lo.category" id="hard.coded.subject.lo.category" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- must be "kuali.lo.category.type.subject" -->
		<dict:validChars>
		<dict:value>regex:kuali\.lo\.category\.type\.subject</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.lulorealtion.includes" id="hard.coded.lulorealtion.includes" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.lu.lo.relation.type.includes" -->
		<dict:validChars>
		<dict:value>regex:kulai\.lu\.lo\.relation\.type\.includes</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.lolorealtion.includes" id="hard.coded.lolorealtion.includes" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.lo.lo.relation.type.includes" -->
		<dict:validChars>
		<dict:value>regex:kulai\.lo\.lo\.relation\.type\.includes</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.singleUse.lo.repository" id="hard.coded.singleUse.lo.repository" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.loRepository.key.single.use" -->
		<dict:validChars>
		<dict:value>regex:kuali\.loRepository\.key\.singleUse</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.credit.awarded.resultUsage" id="hard.coded.credit.awarded.resultUsage" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- must be "Kuali.resultUsageType.CreditAwarded" -->
		<dict:validChars>
		<dict:value>regex:Kuali\.resultUsageType\.CreditAwarded</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.fixed.credit" id="hard.coded.fixed.credit" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.resultComponentType.credit.degree.fixed" -->
		<dict:validChars>
		<dict:value>regex:kuali\.resultComponentType\.credit\.degree\.fixed</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.variable.credit" id="hard.coded.variable.credit" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.resultComponentType.credit.degree.range" -->
		<dict:validChars>
		<dict:value>regex:kuali\.resultComponentType\.credit\.degree\.range</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.final.grade" id="hard.coded.final.grade" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be"kuali.resultComponentType.finalGrade" -->
		<dict:validChars>
		<dict:value>regex:kuali\.resultComponentType\.finalGrade</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.academic.credit" id="hard.coded.academic.credit" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.creditType.credit.degree" -->
		<dict:validChars>
		<dict:value>regex:kuali\.creditType\.credit\.degree</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.final.qualitative.result.Usage" id="hard.coded.final.qualitative.result.Usage" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.resultComponentType.finalQualitative" -->
		<dict:validChars>
		<dict:value>regex:kuali\.resultComponentType\.finalQualitative</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.final.grad.awarded.resultUsage" id="hard.coded.final.grad.awarded.resultUsage" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "Must be "kuali.resultUsageType.finalGradeAwarded"" -->
		<dict:validChars>
		<dict:value>regex:kuali\.resultUsageType\.finalGradeAwarded</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.letter.grade" id="hard.coded.letter.grade" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.gradeType.Letter" -->
		<dict:validChars>
		<dict:value>regex:kuali\.gradeType\.Letter</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.pass-fail.grade" id="hard.coded.pass-fail.grade" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.gradeType.Pass-Fail" -->
		<dict:validChars>
		<dict:value>regex:kuali\.gradeType\.Pass-Fail</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.final.qualitative" id="hard.coded.final.qualitative" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be"kuali.resultComponentType.finalQualitative" -->
		<dict:validChars>
		<dict:value>regex:kuali\.resultComponentType\.finalQualitative</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.referenceType.CLU" id="hard.coded.referenceType.CLU" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.referenceType.CLU" -->
		<dict:validChars>
		<dict:value>regex:kuali\.referenceType\.CLU</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.referenceType.Proposal" id="hard.coded.referenceType.Proposal" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.referenceType.proposal" -->
		<dict:validChars>
		<dict:value>regex:kuali\.referenceType\.proposal</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.group.proposal" id="hard.coded.group.proposal" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be "kuali.proposal.type.group" -->
		<dict:validChars>
		<dict:value>regex:kuali\.proposal\.type\.group</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.syllabus" id="hard.coded.syllabus" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be"kuali.proposal.ProposalDocRelationType.syllabus" -->
		<dict:validChars>
		<dict:value>regex:kuali\.proposal\.ProposalDocRelationType\.syllabus</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.other.document" id="hard.coded.other.document" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be"kuali.proposal.ProposalDocRelationType.other" -->
		<dict:validChars>
		<dict:value>regex:kuali\.proposal\.ProposalDocRelationType\.other</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.file" id="hard.coded.file" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be"kuali.document.type.file" -->
		<dict:validChars>
		<dict:value>regex:kuali\.document\.type\.file</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.course.proposal.doc.category" id="hard.coded.course.proposal.doc.category" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be"kuali.document.category.courseProposal.Doc.Category" -->
		<dict:validChars>
		<dict:value>regex:kuali\.document\.category\.courseProposal\.Doc\.Category</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="has.course.format.relation.lu.types" id="has.course.format.relation.lu.types" serverSide="false">
		<!-- constrains the required LuType of the clu referenced by cluCluRelationInfo.cluID for a Has Course Format relation -->
		<!-- TO DO: add the enumeration to simples -->
		<dict:lookup search="kuali.enum.type.validLuTypesForLuLuRelationType">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="is.course.format.relation.lu.types" id="is.course.format.relation.lu.types" serverSide="false">
		<!-- constrains the required LuType of clu referenced by cluCluRelationInfo.relatedCluId for a has course format relation -->
		<!-- TO DO: add the enumeration to simples -->
		<dict:lookup search="kuali.enum.type.validRelatedLuTypesForLuLuRelationType">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="contains.relation.lu.types" id="contains.relation.lu.types" serverSide="false">
		<!-- constrains the required LuType of the clu referenced by cluCluRelationInfo.cluID for a "Contains" relation -->
		<!-- TO DO: add the enumeration to simples -->
		<dict:lookup search="kuali.enum.type.validLuTypesForLuLuRelationType">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="contained.by.relation.lu.types" id="contained.by.relation.lu.types" serverSide="false">
		<!-- constrains the required LuType of the clu referenced by cluCluRelationInfo.relatedCluID for a "Contain" relation -->
		<!-- TO DO: add the enumeration to simples -->
		<dict:lookup search="kuali.enum.type.validRelatedLuTypesForLuLuRelationType">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="valid.duration.types" id="valid.duration.types" serverSide="false">
		<!-- In a list of duration types configured by LuType -->
		<dict:lookup search="kuali.enum.type.ValidDurationTypes">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="valid.atp.types" id="valid.atp.types">
		<!-- In a list of atp types configured by LuType -->
		<!-- TO DO: add this enumeration to the simples -->
		<dict:lookup search="kuali.enum.type.validAtpTypes">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.statement.operators" id="lu.statement.operators" serverSide="false">
		<!-- In list of configured lu statement operators (AND and OR) -->
		<!-- Hard coded to be AND or OR -->
		<dict:lookup search="kuali.enum.type.lu.statement.operators">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.statement.types" id="lu.statement.types" serverSide="false">
		<!-- In list of valid lu statement types -->
		<!-- See LuStatementInfo types defined on the Types tab -->
		<dict:lookup search="kuali.enum.type.lu.statement.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.statement.states" id="lu.statement.states" serverSide="false">
		<!-- In list of valid lu statement states -->
		<!-- See LuStatementInfo states defined on the States tab -->
		<dict:lookup search="kuali.enum.type.lu.statement.states">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="related.luStatementd" id="related.luStatementd" className="org.kuali.student.lum.lu.validation.LuStatementIdExistsValidator" serverSide="true">
		<!-- Id of an existing LU Statement -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="related.requirementComponentId" id="related.requirementComponentId" className="org.kuali.student.lum.lu.validation.RequirementComponentIdExistsValidator" serverSide="true">
		<!-- Id of an existing requirement component -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="lu.requirement.component.types" id="lu.requirement.component.types" serverSide="false">
		<!-- In list of valid lu requirement component types -->
		<!-- See reqComponentInfo types defined on the Types tab -->
		<dict:lookup search="kuali.enum.type.lu.requirement.component.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="dictionary.field.descriptor.field.types" id="dictionary.field.descriptor.field.types" serverSide="false">
		<!-- In list of valid data types fof fields that are supported by the validator -->
		<!-- Valid values are: complex, string, date, dateTime, boolean, integer, & long -->
		<dict:lookup search="kuali.enum.type.dictionary.field.descriptor.field.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="dictionary.enumeration.keys" id="dictionary.enumeration.keys" serverSide="false">
		<!-- In list of the keys for all valid enumerations known to the system -->
		<!-- See the lookup column of this spreadsheet!!!!! -->
		<dict:lookup search="kuali.enum.type.dictionary.enumeration.type.keys">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="dictionary.enumeration.context.keys" id="dictionary.enumeration.context.keys" serverSide="false">
		<!-- In list of the keys for all valid enumeration contexts known to the system -->
		<!-- See the lookupContext column of this spreadsheet!!!!! -->
		<dict:lookup search="kuali.enum.type.dictionary.enumeration.context.type.keys">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.requirement.component.states" id="lu.requirement.component.states" serverSide="false">
		<!-- In list of valid lu requirement component states -->
		<!-- See reqComponentInfo states defined on the States tab -->
		<dict:lookup search="kuali.enum.type.lu.requirement.component.states">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.requirement.component.field.keys" id="lu.requirement.component.field.keys" serverSide="false">
		<!-- In list of valid lu requirement component field keys -->
		<!-- See the reqCompFieldTypeInfo keys defined on the Types tab -->
		<dict:lookup search="kuali.enum.type.lu.requirement.component.field.keys">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="search.types" id="search.types" serverSide="false">
		<!-- In list of valid search types -->
		<!-- See all the searches defined in the simple specs -->
		<dict:lookup search="kuali.enum.type.search.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="query.param.value.types" id="query.param.value.types" serverSide="false">
		<!-- In list of valid query parameter types for searches -->
		<!-- See all the searches defined in the simple specs -->
		<dict:lookup search="kuali.enum.type.query.param.value.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lrd.types" id="lrd.types" serverSide="false">
		<!-- In list of valid learning result definition types -->
		<!-- See the lrd types defined in this spreadsheet -->
		<dict:lookup search="kuali.enum.type.lrc.lrd.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="learning.result.scale.types" id="learning.result.scale.types" serverSide="false">
		<!-- In list of valid learning result scale types -->
		<!-- See the scale types defined in this spreadsheet -->
		<dict:lookup search="kuali.enum.type.lrc.scale.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lrd.operators" id="lrd.operators" serverSide="false">
		<!-- In list of configured learning result definition operators (=, >, < etc) -->
		<!-- Hard coded to be equal_to, not_equal_to, greater_than, less_than, greater_than_or_equal_to, less_than_or_equal_to -->
		<dict:lookup search="kuali.enum.type.lrd.operators">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="related.lrd.Id" id="related.lrd.Id" className="org.kuali.student.lum.lrd.validation.LearningResultDefinitionIdExistsValidator" serverSide="true">
		<!-- Id of an existing learning result definition -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="hard.coded.credit.course.clu" id="hard.coded.credit.course.clu" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be"kuali.reqCompFieldType.credit.course" -->
		<dict:validChars>
		<dict:value>regex:kuali\.reqCompFieldType\.credit\.course</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.credit.course.clu.set" id="hard.coded.credit.course.clu.set" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be"kuali.reqCompFieldType.credit.course.set" -->
		<dict:validChars>
		<dict:value>regex:kuali\.reqCompFieldType\.credit\.course\.set</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.required.count" id="hard.coded.required.count" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be"kuali.reqCompFieldType.requiredCount" -->
		<dict:validChars>
		<dict:value>regex:kuali\.reqCompFieldType\.requiredCount</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.lrd.credit.course.final.grade" id="hard.coded.lrd.credit.course.final.grade" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be"kuali.reqCompFieldType. -->
		<dict:validChars>
		<dict:value>regex:kuali\.reqCompFieldType\.lrd\.credit\.course\.final\.grade</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.overall.gpa" id="hard.coded.overall.gpa" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be"kuali.reqCompFieldType. -->
		<dict:validChars>
		<dict:value>regex:kuali\.reqCompFieldType\.overall\.gpa</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.overall.totalCredits" id="hard.coded.overall.totalCredits" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be"kuali.reqCompFieldType. -->
		<dict:validChars>
		<dict:value>regex:kuali\.reqCompFieldType\.overall\.totalCredits</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.operator" id="hard.coded.operator" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be"kuali.reqCompFieldType. -->
		<dict:validChars>
		<dict:value>regex:kuali\.reqCompFieldType\.operator</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.countType" id="hard.coded.countType" className="org.kuali.student.core.calculation.HardCodedValueCalculator" serverSide="true">
		<!-- Must be"kuali.reqCompFieldType. -->
		<dict:validChars>
		<dict:value>regex:kuali\.reqCompFieldType\.countType</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="clu.set.types" id="clu.set.types" serverSide="false">
		<!-- In list of valid clu set types -->
		<!-- See cluSetInfo states defined on the Types tab -->
		<dict:lookup search="kuali.enum.type.lu.clu.set.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="clu.set.states" id="clu.set.states" serverSide="false">
		<!-- In list of valid clu set states -->
		<!-- See cluSetInfo states defined on the States tab -->
		<dict:lookup search="kuali.enum.type.lu.clu.set.states">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="valid.credit.course.clu.set.search.types" id="valid.credit.course.clu.set.search.types" serverSide="false">
		<!-- In list of search times that return credit courses or clu sets of credit courses -->
		<!-- Has just one value for now and that is "kuali.lu.searchTypes.CoursesForDynamicCLUSet" but that will expand in the future. -->
		<dict:lookup search="kuali.enum.search.type.credit.course">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>
	
	<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluInfo">
		<!-- Detailed information about a single CLU. -->
		<dict:type key="kuali.lu.type.CreditCourse">
		<!-- A course offered for academic credit -->
		<!-- Subject, Academic Course -->
			<dict:state key="template">
			<!-- A template holds configuration for defaults for creating a new course -->
				
				<dict:field id="course.official" key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>course no</dict:name>
						<dict:desc>course no</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										
										<dict:field id="course.official.no" key="code">
											<dict:fieldDescriptor>
												<dict:name>course official no</dict:name>
												<dict:desc>course number</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="calc.course.no"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.transcriptTitle" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course official transcriptTitle</dict:name>
												<dict:desc>transcript title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="required"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.official.transcriptTitle">
														<dict:maxLength>20</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.catalogTitle" key="longName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course official catalogTitle</dict:name>
												<dict:desc>catalog title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="required"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.official.catalogTitle">
														<dict:maxLength>60</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.level" key="level">
											<dict:fieldDescriptor>
												<dict:name>course official level</dict:name>
												<dict:desc>level</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.subjectArea" key="division">
											<dict:fieldDescriptor>
												<dict:name>course official subjectArea</dict:name>
												<dict:desc>subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.numberPart" key="suffixCode">
											<dict:fieldDescriptor>
												<dict:name>course official numberPart</dict:name>
												<dict:desc>number part of the course number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="available.course.numbers"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.version" key="variation">
											<dict:fieldDescriptor>
												<dict:name>course official version</dict:name>
												<dict:desc>version code</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.adminOrg" key="orgId">
											<dict:fieldDescriptor>
												<dict:name>course official adminOrg</dict:name>
												<dict:desc>dept</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.orgId"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.type" key="type">
											<!-- Required when first adding but read-only thereafter -->
											<dict:fieldDescriptor>
												<dict:name>course official type</dict:name>
												<dict:desc>official</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="lu.identifier.types"/>
													<dict:constraintRef bean="hard.coded.official"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.state" key="state">
											<dict:fieldDescriptor>
												<dict:name>course official state</dict:name>
												<dict:desc>state</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.state"/>
													<dict:constraintRef bean="lu.identifier.states"/>
													<dict:constraintRef bean="hard.coded.active"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.internal.id" key="id">
											<!-- should be blank when first adding but required thereafter for updates -->
											<dict:fieldDescriptor>
												<dict:name>course official internalId</dict:name>
												<dict:desc>internal id of this id</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.id"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.official.no"/>
										<dict:fieldRef bean="course.official.transcriptTitle"/>
										<dict:fieldRef bean="course.official.catalogTitle"/>
										<dict:fieldRef bean="course.official.level"/>
										<dict:fieldRef bean="course.official.subjectArea"/>
										<dict:fieldRef bean="course.official.numberPart"/>
										<dict:fieldRef bean="course.official.version"/>
										<dict:fieldRef bean="course.official.adminOrg"/>
										<dict:fieldRef bean="course.official.type"/>
										<dict:fieldRef bean="course.official.state"/>
										<dict:fieldRef bean="course.official.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraint key="exactly.one.official.identifier" id="exactly.one.official.identifier">
							<dict:typeStateCase>
								<dict:typeStateWhen type="kuali.lu.type.CreditCourse.identifier.official">
								<!-- For a Credit Course, constrains that the type of the identifier for the official identifier is always "official" -->
									<dict:minOccurs>1</dict:minOccurs>
									<dict:maxOccurs>1</dict:maxOccurs>
								</dict:typeStateWhen>
							</dict:typeStateCase>
							</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.alternateIdentifiers" key="alternateIdentifiers">
					<dict:fieldDescriptor>
						<dict:name>course alternateIdentifiers</dict:name>
						<dict:desc>course alternate ids</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.cross-listed">
								<!-- This identifier holds the cross-listed identifiers for this course -->
								<!-- (MIT's meaning of joint) -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										
										<dict:field id="course.cross-listed.no" key="code">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed no</dict:name>
												<dict:desc>cross-listed number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="calc.course.no"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.transcriptTitle" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course cross-listed transcriptTitle</dict:name>
												<dict:desc>not used</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.catalogTitle" key="longName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course cross-listed catalogTitle</dict:name>
												<dict:desc>not used</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.level" key="level">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed level</dict:name>
												<dict:desc>not used</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.subjectArea" key="division">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed subjectArea</dict:name>
												<dict:desc>cross-listed subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.numberPart" key="suffixCode">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed numberPart</dict:name>
												<dict:desc>number part of cross-listed number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="available.course.numbers"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.version" key="variation">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed version</dict:name>
												<dict:desc>not used</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.adminOrg" key="orgId">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed adminOrg</dict:name>
												<dict:desc>cross-listed department</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.orgId"/>
													<dict:constraintRef bean="required"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.type" key="type">
											<!-- Required when first adding but read-only thereafter -->
											<dict:fieldDescriptor>
												<dict:name>course cross-listed type</dict:name>
												<dict:desc>cross-listed</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="lu.identifier.types"/>
													<dict:constraintRef bean="hard.coded.cross-listed"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.state" key="state">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed state</dict:name>
												<dict:desc>state</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.state"/>
													<dict:constraintRef bean="lu.identifier.states"/>
													<dict:constraintRef bean="default.active"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.internal.id" key="id">
											<!-- should be blank when first adding but required thereafter for updates -->
											<dict:fieldDescriptor>
												<dict:name>course cross-listed internalId</dict:name>
												<dict:desc>internal id of cross-listed id</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.id"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.cross-listed.no"/>
										<dict:fieldRef bean="course.cross-listed.transcriptTitle"/>
										<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
										<dict:fieldRef bean="course.cross-listed.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea"/>
										<dict:fieldRef bean="course.cross-listed.numberPart"/>
										<dict:fieldRef bean="course.cross-listed.version"/>
										<dict:fieldRef bean="course.cross-listed.adminOrg"/>
										<dict:fieldRef bean="course.cross-listed.type"/>
										<dict:fieldRef bean="course.cross-listed.state"/>
										<dict:fieldRef bean="course.cross-listed.internal.id"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!-- This identifier holds the version information for courses that have multiple versions -->
								<!-- Variation -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										
										<dict:field id="course.version.no" key="code">
											<!-- calculated by concatenating the subject Area, numberPart and version code. -->
											<dict:fieldDescriptor>
												<dict:name>course version no</dict:name>
												<dict:desc>version number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="calc.course.no"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.transcriptTitle" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course version transcriptTitle</dict:name>
												<dict:desc>Version Title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="required"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.version.transcriptTitle">
														<dict:maxLength>20</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.catalogTitle" key="longName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course version catalogTitle</dict:name>
												<dict:desc>not used</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.level" key="level">
											<dict:fieldDescriptor>
												<dict:name>course version level</dict:name>
												<dict:desc>not used</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.subjectArea" key="division">
											<!-- set to the official number's subjectArea -->
											<dict:fieldDescriptor>
												<dict:name>course version subjectArea</dict:name>
												<dict:desc>subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="calc.copy.course.official.subjectArea"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.numberPart" key="suffixCode">
											<!-- set to the official number's numberPart -->
											<dict:fieldDescriptor>
												<dict:name>course version numberPart</dict:name>
												<dict:desc>number part of course number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="calc.copy.course.official.numberPart"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.version" key="variation">
											<dict:fieldDescriptor>
												<dict:name>course version version</dict:name>
												<dict:desc>version code</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="code.uppercase"/>
													<dict:constraintRef bean="letter"/>
													<dict:constraintRef bean="size.one"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.adminOrg" key="orgId">
											<dict:fieldDescriptor>
												<dict:name>course version adminOrg</dict:name>
												<dict:desc>not used</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.orgId"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.type" key="type">
											<!-- Required when first adding but read-only thereafter -->
											<dict:fieldDescriptor>
												<dict:name>course version type</dict:name>
												<dict:desc>version</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="lu.identifier.types"/>
													<dict:constraintRef bean="hard.coded.version"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.state" key="state">
											<dict:fieldDescriptor>
												<dict:name>course version state</dict:name>
												<dict:desc>state</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.state"/>
													<dict:constraintRef bean="lu.identifier.states"/>
													<dict:constraintRef bean="hard.coded.active"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.internal.id" key="id">
											<!-- should be blank when first adding but required thereafter for updates -->
											<dict:fieldDescriptor>
												<dict:name>course version internalId</dict:name>
												<dict:desc>internal id of this course version</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.id"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.version.no"/>
										<dict:fieldRef bean="course.version.transcriptTitle"/>
										<dict:fieldRef bean="course.version.catalogTitle"/>
										<dict:fieldRef bean="course.version.level"/>
										<dict:fieldRef bean="course.version.subjectArea"/>
										<dict:fieldRef bean="course.version.numberPart"/>
										<dict:fieldRef bean="course.version.version"/>
										<dict:fieldRef bean="course.version.adminOrg"/>
										<dict:fieldRef bean="course.version.type"/>
										<dict:fieldRef bean="course.version.state"/>
										<dict:fieldRef bean="course.version.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraint key="zero.or.more.cross-listed.identifiers.zero.or.more.version.identifiers" id="zero.or.more.cross-listed.identifiers.zero.or.more.version.identifiers">
							<dict:typeStateCase>
								<dict:typeStateWhen type="kuali.lu.type.CreditCourse.identifier.cross-listed">
								<!-- For a Credit Course, constrains that there be zero or more cross-listed identfiers -->
									<dict:minOccurs>0</dict:minOccurs>
									<dict:maxOccurs>(unbounded)</dict:maxOccurs>
								</dict:typeStateWhen>
								<dict:typeStateWhen type="kuali.lu.type.CreditCourse.identifier.version">
								<!-- For a Credit Course, constrains that there be zero or more version identifiers -->
									<dict:minOccurs>0</dict:minOccurs>
									<dict:maxOccurs>(unbounded)</dict:maxOccurs>
								</dict:typeStateWhen>
							</dict:typeStateCase>
							</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.academicSubjectOrgs" key="academicSubjectOrgs">
					<dict:fieldDescriptor>
						<dict:name>course academicSubjectOrgs</dict:name>
						<dict:desc>course ademicSubjectOrgs</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.studySubjectArea" key="studySubjectArea">
					<dict:fieldDescriptor>
						<dict:name>course studySubjectArea</dict:name>
						<dict:desc>course studySubjectArea</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="code"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.desc.template" key="desc">
					<dict:fieldDescriptor>
						<dict:name>course desc</dict:name>
						<dict:desc>dscription</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.desc.plain" key="plain">
											<!-- calculated by stripping out formatting -->
											<dict:fieldDescriptor>
												<dict:name>course desc plain</dict:name>
												<dict:desc>plain text version description of course</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.desc.plain">
														<dict:maxLength>14000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>course desc formatted</dict:name>
												<dict:desc>rich text version of the course description</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.desc.formatted">
														<dict:maxLength>14000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.rationale" key="marketingDesc">
					<!-- Rationale is stored in the Marketing Description for now -->
					<dict:fieldDescriptor>
						<dict:name>course rationale</dict:name>
						<dict:desc>rationale</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.rationale.plain" key="plain">
											<!-- calculated by stripping out formatting -->
											<dict:fieldDescriptor>
												<dict:name>course rationale plain</dict:name>
												<dict:desc>plain text version of rationale</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.rationale.plain">
														<dict:maxLength>14000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.rationale.formatted" key="formatted">
											<!-- the rationale is stored in the marketing description for now -->
											<dict:fieldDescriptor>
												<dict:name>course rationale formatted</dict:name>
												<dict:desc>rich text version of rationale</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.rationale.formatted">
														<dict:maxLength>14000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.campusLocation" key="campusLocationList">
					<dict:fieldDescriptor>
						<dict:name>course campusLocation</dict:name>
						<dict:desc>campus location</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="code"/>
							<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.accreditation" key="accreditation">
					<dict:fieldDescriptor>
						<dict:name>course accreditation</dict:name>
						<dict:desc>course accreditation</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.primaryAdminOrg" key="primaryAdminOrg">
					<dict:fieldDescriptor>
						<dict:name>course primaryAdminOrg</dict:name>
						<dict:desc>department</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.AdminOrgInfo">
								<!-- Information about an organization acting in administrative capacity for a learning unit. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.primaryAdminOrg.Id" key="orgId">
											<dict:fieldDescriptor>
												<dict:name>course primaryAdminOrg Id</dict:name>
												<dict:desc>Org Id of the primary administrative department</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.orgId"/>
											</dict:constraintDescriptor>
											<dict:selector>true</dict:selector>
										</dict:field>
										
										<dict:field id="course.primaryAdminOrg.attributes" key="attributes">
											<dict:fieldDescriptor>
												<dict:name>course primaryAdminOrg attributes</dict:name>
												<dict:desc>dynamic attributes qualifying the primary admin org</dict:desc>
												<dict:dataType>complex</dict:dataType>
													
													<dict:objectStructure key=".AttributeInfo">
														<!-- List of key/value pairs, typically used for dynamic attributes. -->
														<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed">
														<!-- Captures if the students are expected to be left handed who take this course -->
															<dict:state key="(n/a)">
															<!-- Not applicable -->
																
																<dict:field id="course.primaryAdminOrg.attributes.left.handed.key" key="key">
																	<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
																	<dict:fieldDescriptor>
																		<dict:name>course primaryAdminOrg attributes left handed key</dict:name>
																		<dict:desc>Key to capture if the students are expected to be left handed who take this course</dict:desc>
																		<dict:dataType>string</dict:dataType>
																		<dict:readOnly>true</dict:readOnly>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="kuali.type"/>
																			<dict:constraintRef bean="dynamic.field.types"/>
																			<dict:constraintRef bean="hard.coded.left.handed"/>
																			<dict:constraintRef bean="read.only"/>
																	</dict:constraintDescriptor>
																	<dict:dynamic>true</dict:dynamic>
																</dict:field>
																
																<dict:field id="course.primaryAdminOrg.attributes.left.handed.value" key="value">
																	<dict:fieldDescriptor>
																		<dict:name>course primaryAdminOrg attributes left handed value</dict:name>
																		<dict:desc>Value of the students are expected to be left handed who take this course</dict:desc>
																		<dict:dataType>string</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="boolean"/>
																			<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
																				<dict:maxLength>(unbounded)</dict:maxLength>
																				</dict:constraint>
																	</dict:constraintDescriptor>
																	<dict:dynamic>true</dict:dynamic>
																</dict:field>
															</dict:state>
														</dict:type>
													</dict:objectStructure>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="repeating"/>
													<dict:constraintRef bean="single"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.primaryAdminOrg.attributes">
														<dict:maxOccurs>20</dict:maxOccurs>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="default.to.proposal.proposerOrg"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.alternateAdminOrgs" key="alternateAdminOrgs">
					<dict:fieldDescriptor>
						<dict:name>course alternateAdminOrgs</dict:name>
						<dict:desc>not used</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.primaryInstructor" key="primaryInstructor">
					<dict:fieldDescriptor>
						<dict:name>course primaryInstructor</dict:name>
						<dict:desc>course primaryInstructor</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.instructors" key="instructors">
					<dict:fieldDescriptor>
						<dict:name>course instructors</dict:name>
						<dict:desc>course instructors</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.expectedFirstAtp" key="expectedFirstAtp">
					<dict:fieldDescriptor>
						<dict:name>course expectedFirstAtp</dict:name>
						<dict:desc>course expectedFirstAtp</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="atp.types"/>
							<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>course effectiveDate</dict:name>
						<dict:desc>first date can be offered</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
							<dict:constraintRef bean="default.today"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>course expirationDate</dict:name>
						<dict:desc>last date can be offerred</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.total.contact.hours" key="intensity">
					<!-- This doesn't exist on the UI but I know that someone soon will want to have the system calculate the total contact hours for the course and this is where that calculation should be stored -->
					<dict:fieldDescriptor>
						<dict:name>course contact hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.duration" key="stdDuration">
					<dict:fieldDescriptor>
						<dict:name>course duration</dict:name>
						<dict:desc>duration</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.duration.units" key="atpDurationTypeKey">
											<!-- services has this flagged as mandatory but don't think it shoujld be because in a draft state a user may specify the units but not yet specify the amount -->
											<dict:fieldDescriptor>
												<dict:name>course duration units</dict:name>
												<dict:desc>Units in which the duration of the course is expressed</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="duration.types"/>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="valid.duration.types"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.duration.no" key="timeQuantity">
											<!-- services has this flagged as mandatory but don't think it shoujld be because in a draft state a user may specify the amount but not yet specify the units because they are unsure but we still need to save -->
											<!-- How do we add a min and max VALUE limit (not min and max size and occurrence) -->
											<dict:fieldDescriptor>
												<dict:name>course duration no</dict:name>
												<dict:desc>number of the duration units</dict:desc>
												<dict:dataType>integer</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="integer"/>
													<dict:constraintRef bean="hard.coded.one"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.canCreateLui" key="canCreateLui">
					<dict:fieldDescriptor>
						<dict:name>course canCreateLui</dict:name>
						<dict:desc>course canCreateLui</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.referenceURL" key="referenceURL">
					<dict:fieldDescriptor>
						<dict:name>course referenceURL</dict:name>
						<dict:desc>course referenceURL</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="url"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.luCodes" key="luCodes">
					<dict:fieldDescriptor>
						<dict:name>course luCodes</dict:name>
						<dict:desc>course luCodes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.publishingInfo" key="publishingInfo">
					<dict:fieldDescriptor>
						<dict:name>course publishingInfo</dict:name>
						<dict:desc>course publishingInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.nextReviewPeriod" key="nextReviewPeriod">
					<dict:fieldDescriptor>
						<dict:name>course nextReviewPeriod</dict:name>
						<dict:desc>course nextReviewPeriod</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="atp.types"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.isEnrollable" key="isEnrollable">
					<!-- defaults to TRUE -->
					<dict:fieldDescriptor>
						<dict:name>course isEnrollable</dict:name>
						<dict:desc>course isEnrollable</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="default.true"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.seasons" key="offeredAtpTypes">
					<!-- Services has this as an atpKeyList but that is just a list of Strings so I didn't create the sub-structure -->
					<dict:fieldDescriptor>
						<dict:name>course seasons</dict:name>
						<dict:desc>seasons offered</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="atp.types"/>
							<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.hasEarlyDropDeadline" key="hasEarlyDropDeadline">
					<dict:fieldDescriptor>
						<dict:name>course hasEarlyDropDeadline</dict:name>
						<dict:desc>course hasEarlyDropDeadline</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.defaultEnrollmentEstimate" key="defaultEnrollmentEstimate">
					<dict:fieldDescriptor>
						<dict:name>course defaultEnrollmentEstimate</dict:name>
						<dict:desc>course defaultEnrollmentEstimate</dict:desc>
						<dict:dataType>integer</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="non-negative.integer"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.defaultMaximumEnrollment" key="defaultMaximumEnrollment">
					<dict:fieldDescriptor>
						<dict:name>course defaultMaximumEnrollment</dict:name>
						<dict:desc>course defaultMaximumEnrollment</dict:desc>
						<dict:dataType>integer</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="non-negative.integer"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.isHazardousForDisabledStudents" key="isHazardousForDisabledStudents">
					<dict:fieldDescriptor>
						<dict:name>course isHazardousForDisabledStudents</dict:name>
						<dict:desc>course isHazardousForDisabledStudents</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.feeInfo" key="feeInfo">
					<dict:fieldDescriptor>
						<dict:name>course feeInfo</dict:name>
						<dict:desc>course feeInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.accountingInfo" key="accountingInfo">
					<dict:fieldDescriptor>
						<dict:name>course accountingInfo</dict:name>
						<dict:desc>course accountingInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.dynamic.attributes" key="attributes">
					<!-- Services has this as an attributeInfoList but that is just a list of the attributeInfo substructure so I did't create the intermediary list sub-structure -->
					<dict:fieldDescriptor>
						<dict:name>course dynamic attributes</dict:name>
						<dict:desc>Eye color and Left Handed</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key=".AttributeInfo">
								<!-- List of key/value pairs, typically used for dynamic attributes. -->
								<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color">
								<!-- Captures the eye color of students expected to take this course -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.attributes.eye.color.key" key="key">
											<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
											<dict:fieldDescriptor>
												<dict:name>course attributes eye color key</dict:name>
												<dict:desc>Key to capture the eye color of students expected to take this course</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="dynamic.field.types"/>
													<dict:constraintRef bean="hard.coded.eye.color"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
											<dict:dynamic>true</dict:dynamic>
										</dict:field>
										
										<dict:field id="course.attributes.eye.color.value" key="value">
											<dict:fieldDescriptor>
												<dict:name>course attributes eye color value</dict:name>
												<dict:desc>Value of the eye color of students expected to take this course</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="eye.colors"/>
													<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
											<dict:dynamic>true</dict:dynamic>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.meta" key="metaInfo">
					<!-- must be empty on create but required on update -->
					<dict:fieldDescriptor>
						<dict:name>course meta</dict:name>
						<dict:desc>audit trail info</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>course meta versionInd</dict:name>
												<dict:desc>Version number for this course info</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>course meta createTime</dict:name>
												<dict:desc>Date-time this course was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>course meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this course</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>course meta updateTime</dict:name>
												<dict:desc>Date-time this course was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>course meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this course</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.type" key="type">
					<!-- Requierd on the create but read-only after that -->
					<dict:fieldDescriptor>
						<dict:name>course type</dict:name>
						<dict:desc>type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="lu.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>course state</dict:name>
						<dict:desc>state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
							<dict:constraintRef bean="lu.states"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="course.internal.id" key="id">
					<!-- must be empty on create but required on update -->
					<dict:fieldDescriptor>
						<dict:name>course internalId</dict:name>
						<dict:desc>internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				
				<dict:field key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>course no</dict:name>
						<dict:desc>course no</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.official.no"/>
										
										<dict:field id="course.official.transcriptTitle.draft.private" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course official transcriptTitle</dict:name>
												<dict:desc>transcript title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.official.transcriptTitle.draft.private">
														<dict:maxLength>250</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.catalogTitle.draft.private" key="longName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course official catalogTitle</dict:name>
												<dict:desc>catalog title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="required"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.official.catalogTitle.draft.private">
														<dict:maxLength>250</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.official.level"/>
										
										<dict:field id="course.official.subjectArea.draft.private" key="division">
											<dict:fieldDescriptor>
												<dict:name>course official subjectArea</dict:name>
												<dict:desc>subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.numberPart.draft.private" key="suffixCode">
											<dict:fieldDescriptor>
												<dict:name>course official numberPart</dict:name>
												<dict:desc>number part of the course number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="available.course.numbers"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.official.version"/>
										<dict:fieldRef bean="course.official.adminOrg"/>
										<dict:fieldRef bean="course.official.type"/>
										<dict:fieldRef bean="course.official.state"/>
										<dict:fieldRef bean="course.official.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.official.no"/>
										<dict:fieldRef bean="course.official.transcriptTitle.draft.private"/>
										<dict:fieldRef bean="course.official.catalogTitle.draft.private"/>
										<dict:fieldRef bean="course.official.level"/>
										<dict:fieldRef bean="course.official.subjectArea.draft.private"/>
										<dict:fieldRef bean="course.official.numberPart.draft.private"/>
										<dict:fieldRef bean="course.official.version"/>
										<dict:fieldRef bean="course.official.adminOrg"/>
										<dict:fieldRef bean="course.official.type"/>
										<dict:fieldRef bean="course.official.state"/>
										<dict:fieldRef bean="course.official.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="exactly.one.official.identifier"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field key="alternateIdentifiers">
					<dict:fieldDescriptor>
						<dict:name>course alternateIdentifiers</dict:name>
						<dict:desc>course alternate ids</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.cross-listed">
								<!-- This identifier holds the cross-listed identifiers for this course -->
								<!-- (MIT's meaning of joint) -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.cross-listed.no"/>
										
										<dict:field id="course.version.transcriptTitle.draft.private" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course version transcriptTitle</dict:name>
												<dict:desc>Version Title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.version.transcriptTitle.draft.private">
														<dict:maxLength>250</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
										<dict:fieldRef bean="course.cross-listed.level"/>
										
										<dict:field id="course.cross-listed.subjectArea.draft.private" key="division">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed subjectArea</dict:name>
												<dict:desc>cross-listed subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.numberPart.draft.private" key="suffixCode">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed numberPart</dict:name>
												<dict:desc>number part of cross-listed number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="available.course.numbers"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.version.draft.private" key="variation">
											<dict:fieldDescriptor>
												<dict:name>course version version</dict:name>
												<dict:desc>version code</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="code.uppercase"/>
													<dict:constraintRef bean="letter"/>
													<dict:constraintRef bean="size.one"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.adminOrg.draft.private" key="orgId">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed adminOrg</dict:name>
												<dict:desc>cross-listed department</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.orgId"/>
													<dict:constraintRef bean="optional"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.cross-listed.type"/>
										<dict:fieldRef bean="course.cross-listed.state"/>
										<dict:fieldRef bean="course.cross-listed.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.cross-listed.no"/>
										<dict:fieldRef bean="course.version.transcriptTitle.draft.private"/>
										<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
										<dict:fieldRef bean="course.cross-listed.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea.draft.private"/>
										<dict:fieldRef bean="course.cross-listed.numberPart.draft.private"/>
										<dict:fieldRef bean="course.version.version.draft.private"/>
										<dict:fieldRef bean="course.cross-listed.adminOrg.draft.private"/>
										<dict:fieldRef bean="course.cross-listed.type"/>
										<dict:fieldRef bean="course.cross-listed.state"/>
										<dict:fieldRef bean="course.cross-listed.internal.id"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!-- This identifier holds the version information for courses that have multiple versions -->
								<!-- Variation -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.version.no"/>
										<dict:fieldRef bean="course.version.transcriptTitle.draft.private"/>
										<dict:fieldRef bean="course.version.catalogTitle"/>
										<dict:fieldRef bean="course.version.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea.draft.private"/>
										<dict:fieldRef bean="course.cross-listed.numberPart.draft.private"/>
										<dict:fieldRef bean="course.version.version.draft.private"/>
										<dict:fieldRef bean="course.cross-listed.adminOrg.draft.private"/>
										<dict:fieldRef bean="course.version.type"/>
										<dict:fieldRef bean="course.version.state"/>
										<dict:fieldRef bean="course.version.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.version.no"/>
										<dict:fieldRef bean="course.version.transcriptTitle.draft.private"/>
										<dict:fieldRef bean="course.version.catalogTitle"/>
										<dict:fieldRef bean="course.version.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea.draft.private"/>
										<dict:fieldRef bean="course.cross-listed.numberPart.draft.private"/>
										<dict:fieldRef bean="course.version.version.draft.private"/>
										<dict:fieldRef bean="course.cross-listed.adminOrg.draft.private"/>
										<dict:fieldRef bean="course.version.type"/>
										<dict:fieldRef bean="course.version.state"/>
										<dict:fieldRef bean="course.version.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="zero.or.more.cross-listed.identifiers.zero.or.more.version.identifiers"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.studySubjectArea"/>
				
				<dict:field id="course.desc.draft.private" key="desc">
					<dict:fieldDescriptor>
						<dict:name>course desc</dict:name>
						<dict:desc>dscription</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.desc.plain.draft.private" key="plain">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>course desc plain</dict:name>
												<dict:desc>plain text version description of course</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.desc.plain.draft.private">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.desc.formatted.draft.private" key="formatted">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>course desc formatted</dict:name>
												<dict:desc>rich text version of the course description</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.desc.formatted.draft.private">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.rationale.draft.private" key="marketingDesc">
					<!-- Rationale is stored in the Marketing Description for now -->
					<dict:fieldDescriptor>
						<dict:name>course rationale</dict:name>
						<dict:desc>rationale</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.rationale.plain.draft.private" key="plain">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>course rationale plain</dict:name>
												<dict:desc>plain text version of rationale</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.rationale.plain.draft.private">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.rationale.formatted.draft.private" key="formatted">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>course rationale formatted</dict:name>
												<dict:desc>rich text version of rationale</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.rationale.formatted.draft.private">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.campusLocation.draft.private" key="campusLocationList">
					<dict:fieldDescriptor>
						<dict:name>course campusLocation</dict:name>
						<dict:desc>campus location</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="code"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.accreditation"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.primaryInstructor"/>
				<dict:fieldRef bean="course.instructors"/>
				
				<dict:field id="course.expectedFirstAtp.draft.private" key="expectedFirstAtp">
					<dict:fieldDescriptor>
						<dict:name>course expectedFirstAtp</dict:name>
						<dict:desc>course expectedFirstAtp</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="atp.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.total.contact.hours"/>
				
				<dict:field id="course.duration.draft.private" key="stdDuration">
					<dict:fieldDescriptor>
						<dict:name>course duration</dict:name>
						<dict:desc>duration</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.duration.units.draft.private" key="atpDurationTypeKey">
											<!-- services has this flagged as mandatory but don't think it shoujld be because in a draft state a user may specify the units but not yet specify the amount -->
											<dict:fieldDescriptor>
												<dict:name>course duration units</dict:name>
												<dict:desc>Units in which the duration of the course is expressed</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="duration.types"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="valid.duration.types"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.duration.no"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.canCreateLui"/>
				<dict:fieldRef bean="course.referenceURL"/>
				<dict:fieldRef bean="course.luCodes"/>
				<dict:fieldRef bean="course.publishingInfo"/>
				<dict:fieldRef bean="course.nextReviewPeriod"/>
				<dict:fieldRef bean="course.isEnrollable"/>
				
				<dict:field id="course.seasons.draft.private" key="offeredAtpTypes">
					<!-- Services has this as an atpKeyList but that is just a list of Strings so I didn't create the sub-structure -->
					<dict:fieldDescriptor>
						<dict:name>course seasons</dict:name>
						<dict:desc>seasons offered</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="atp.types"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.feeInfo"/>
				<dict:fieldRef bean="course.accountingInfo"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internal.id"/>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				
				<dict:field key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>course no</dict:name>
						<dict:desc>course no</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.official.no"/>
										
										<dict:field id="course.official.transcriptTitle.draft.public" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course official transcriptTitle</dict:name>
												<dict:desc>transcript title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.official.transcriptTitle.draft.public">
														<dict:maxLength>250</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.catalogTitle.draft.public" key="longName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course official catalogTitle</dict:name>
												<dict:desc>catalog title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="required"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.official.catalogTitle.draft.public">
														<dict:maxLength>250</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.official.level"/>
										
										<dict:field id="course.official.subjectArea.draft.public" key="division">
											<dict:fieldDescriptor>
												<dict:name>course official subjectArea</dict:name>
												<dict:desc>subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.numberPart.draft.public" key="suffixCode">
											<dict:fieldDescriptor>
												<dict:name>course official numberPart</dict:name>
												<dict:desc>number part of the course number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="available.course.numbers"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.official.version"/>
										<dict:fieldRef bean="course.official.adminOrg"/>
										<dict:fieldRef bean="course.official.type"/>
										<dict:fieldRef bean="course.official.state"/>
										<dict:fieldRef bean="course.official.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.official.no"/>
										<dict:fieldRef bean="course.official.transcriptTitle.draft.public"/>
										<dict:fieldRef bean="course.official.catalogTitle.draft.public"/>
										<dict:fieldRef bean="course.official.level"/>
										<dict:fieldRef bean="course.official.subjectArea.draft.public"/>
										<dict:fieldRef bean="course.official.numberPart.draft.public"/>
										<dict:fieldRef bean="course.official.version"/>
										<dict:fieldRef bean="course.official.adminOrg"/>
										<dict:fieldRef bean="course.official.type"/>
										<dict:fieldRef bean="course.official.state"/>
										<dict:fieldRef bean="course.official.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="exactly.one.official.identifier"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field key="alternateIdentifiers">
					<dict:fieldDescriptor>
						<dict:name>course alternateIdentifiers</dict:name>
						<dict:desc>course alternate ids</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.cross-listed">
								<!-- This identifier holds the cross-listed identifiers for this course -->
								<!-- (MIT's meaning of joint) -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.cross-listed.no"/>
										
										<dict:field id="course.version.transcriptTitle.draft.public" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course version transcriptTitle</dict:name>
												<dict:desc>Version Title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.version.transcriptTitle.draft.public">
														<dict:maxLength>250</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
										<dict:fieldRef bean="course.cross-listed.level"/>
										
										<dict:field id="course.cross-listed.subjectArea.draft.public" key="division">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed subjectArea</dict:name>
												<dict:desc>cross-listed subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.numberPart.draft.public" key="suffixCode">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed numberPart</dict:name>
												<dict:desc>number part of cross-listed number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="available.course.numbers"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.version.draft.public" key="variation">
											<dict:fieldDescriptor>
												<dict:name>course version version</dict:name>
												<dict:desc>version code</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="code.uppercase"/>
													<dict:constraintRef bean="letter"/>
													<dict:constraintRef bean="size.one"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.adminOrg.draft.public" key="orgId">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed adminOrg</dict:name>
												<dict:desc>cross-listed department</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.orgId"/>
													<dict:constraintRef bean="optional"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.cross-listed.type"/>
										<dict:fieldRef bean="course.cross-listed.state"/>
										<dict:fieldRef bean="course.cross-listed.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.cross-listed.no"/>
										<dict:fieldRef bean="course.version.transcriptTitle.draft.public"/>
										<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
										<dict:fieldRef bean="course.cross-listed.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea.draft.public"/>
										<dict:fieldRef bean="course.cross-listed.numberPart.draft.public"/>
										<dict:fieldRef bean="course.version.version.draft.public"/>
										<dict:fieldRef bean="course.cross-listed.adminOrg.draft.public"/>
										<dict:fieldRef bean="course.cross-listed.type"/>
										<dict:fieldRef bean="course.cross-listed.state"/>
										<dict:fieldRef bean="course.cross-listed.internal.id"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!-- This identifier holds the version information for courses that have multiple versions -->
								<!-- Variation -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.version.no"/>
										<dict:fieldRef bean="course.version.transcriptTitle.draft.public"/>
										<dict:fieldRef bean="course.version.catalogTitle"/>
										<dict:fieldRef bean="course.version.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea.draft.public"/>
										<dict:fieldRef bean="course.cross-listed.numberPart.draft.public"/>
										<dict:fieldRef bean="course.version.version.draft.public"/>
										<dict:fieldRef bean="course.cross-listed.adminOrg.draft.public"/>
										<dict:fieldRef bean="course.version.type"/>
										<dict:fieldRef bean="course.version.state"/>
										<dict:fieldRef bean="course.version.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.version.no"/>
										<dict:fieldRef bean="course.version.transcriptTitle.draft.public"/>
										<dict:fieldRef bean="course.version.catalogTitle"/>
										<dict:fieldRef bean="course.version.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea.draft.public"/>
										<dict:fieldRef bean="course.cross-listed.numberPart.draft.public"/>
										<dict:fieldRef bean="course.version.version.draft.public"/>
										<dict:fieldRef bean="course.cross-listed.adminOrg.draft.public"/>
										<dict:fieldRef bean="course.version.type"/>
										<dict:fieldRef bean="course.version.state"/>
										<dict:fieldRef bean="course.version.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="zero.or.more.cross-listed.identifiers.zero.or.more.version.identifiers"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.studySubjectArea"/>
				
				<dict:field id="course.desc.draft.public" key="desc">
					<dict:fieldDescriptor>
						<dict:name>course desc</dict:name>
						<dict:desc>dscription</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.desc.plain.draft.public" key="plain">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>course desc plain</dict:name>
												<dict:desc>plain text version description of course</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.desc.plain.draft.public">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.desc.formatted.draft.public" key="formatted">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>course desc formatted</dict:name>
												<dict:desc>rich text version of the course description</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.desc.formatted.draft.public">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.rationale.draft.public" key="marketingDesc">
					<!-- Rationale is stored in the Marketing Description for now -->
					<dict:fieldDescriptor>
						<dict:name>course rationale</dict:name>
						<dict:desc>rationale</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.rationale.plain.draft.public" key="plain">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>course rationale plain</dict:name>
												<dict:desc>plain text version of rationale</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.rationale.plain.draft.public">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.rationale.formatted.draft.public" key="formatted">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>course rationale formatted</dict:name>
												<dict:desc>rich text version of rationale</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.rationale.formatted.draft.public">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.campusLocation.draft.public" key="campusLocationList">
					<dict:fieldDescriptor>
						<dict:name>course campusLocation</dict:name>
						<dict:desc>campus location</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="code"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.accreditation"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.primaryInstructor"/>
				<dict:fieldRef bean="course.instructors"/>
				
				<dict:field id="course.expectedFirstAtp.draft.public" key="expectedFirstAtp">
					<dict:fieldDescriptor>
						<dict:name>course expectedFirstAtp</dict:name>
						<dict:desc>course expectedFirstAtp</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="atp.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.total.contact.hours"/>
				
				<dict:field id="course.duration.draft.public" key="stdDuration">
					<dict:fieldDescriptor>
						<dict:name>course duration</dict:name>
						<dict:desc>duration</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.duration.units.draft.public" key="atpDurationTypeKey">
											<!-- services has this flagged as mandatory but don't think it shoujld be because in a draft state a user may specify the units but not yet specify the amount -->
											<dict:fieldDescriptor>
												<dict:name>course duration units</dict:name>
												<dict:desc>Units in which the duration of the course is expressed</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="duration.types"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="valid.duration.types"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.duration.no"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.canCreateLui"/>
				<dict:fieldRef bean="course.referenceURL"/>
				<dict:fieldRef bean="course.luCodes"/>
				<dict:fieldRef bean="course.publishingInfo"/>
				<dict:fieldRef bean="course.nextReviewPeriod"/>
				<dict:fieldRef bean="course.isEnrollable"/>
				
				<dict:field id="course.seasons.draft.public" key="offeredAtpTypes">
					<!-- Services has this as an atpKeyList but that is just a list of Strings so I didn't create the sub-structure -->
					<dict:fieldDescriptor>
						<dict:name>course seasons</dict:name>
						<dict:desc>seasons offered</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="atp.types"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.feeInfo"/>
				<dict:fieldRef bean="course.accountingInfo"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
				
				<dict:field key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>course no</dict:name>
						<dict:desc>course no</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.official.no"/>
										<dict:fieldRef bean="course.official.transcriptTitle"/>
										<dict:fieldRef bean="course.official.catalogTitle"/>
										<dict:fieldRef bean="course.official.level"/>
										
										<dict:field id="course.official.subjectArea.submitted" key="division">
											<dict:fieldDescriptor>
												<dict:name>course official subjectArea</dict:name>
												<dict:desc>subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.numberPart.submitted" key="suffixCode">
											<dict:fieldDescriptor>
												<dict:name>course official numberPart</dict:name>
												<dict:desc>number part of the course number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="available.course.numbers"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.official.version"/>
										<dict:fieldRef bean="course.official.adminOrg"/>
										<dict:fieldRef bean="course.official.type"/>
										<dict:fieldRef bean="course.official.state"/>
										<dict:fieldRef bean="course.official.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.official.no"/>
										<dict:fieldRef bean="course.official.transcriptTitle"/>
										<dict:fieldRef bean="course.official.catalogTitle"/>
										<dict:fieldRef bean="course.official.level"/>
										<dict:fieldRef bean="course.official.subjectArea.submitted"/>
										<dict:fieldRef bean="course.official.numberPart.submitted"/>
										<dict:fieldRef bean="course.official.version"/>
										<dict:fieldRef bean="course.official.adminOrg"/>
										<dict:fieldRef bean="course.official.type"/>
										<dict:fieldRef bean="course.official.state"/>
										<dict:fieldRef bean="course.official.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="exactly.one.official.identifier"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field key="alternateIdentifiers">
					<dict:fieldDescriptor>
						<dict:name>course alternateIdentifiers</dict:name>
						<dict:desc>course alternate ids</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.cross-listed">
								<!-- This identifier holds the cross-listed identifiers for this course -->
								<!-- (MIT's meaning of joint) -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.cross-listed.no"/>
										<dict:fieldRef bean="course.cross-listed.transcriptTitle"/>
										<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
										<dict:fieldRef bean="course.cross-listed.level"/>
										
										<dict:field id="course.cross-listed.subjectArea.submitted" key="division">
											<!-- In KRU the number does not have be chosen prior to submittal. -->
											<dict:fieldDescriptor>
												<dict:name>course cross-listed subjectArea</dict:name>
												<dict:desc>cross-listed subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.numberPart.submitted" key="suffixCode">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed numberPart</dict:name>
												<dict:desc>number part of cross-listed number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="available.course.numbers"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.cross-listed.version"/>
										<dict:fieldRef bean="course.cross-listed.adminOrg"/>
										<dict:fieldRef bean="course.cross-listed.type"/>
										<dict:fieldRef bean="course.cross-listed.state"/>
										<dict:fieldRef bean="course.cross-listed.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.cross-listed.no"/>
										<dict:fieldRef bean="course.cross-listed.transcriptTitle"/>
										<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
										<dict:fieldRef bean="course.cross-listed.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea.submitted"/>
										<dict:fieldRef bean="course.cross-listed.numberPart.submitted"/>
										<dict:fieldRef bean="course.cross-listed.version"/>
										<dict:fieldRef bean="course.cross-listed.adminOrg"/>
										<dict:fieldRef bean="course.cross-listed.type"/>
										<dict:fieldRef bean="course.cross-listed.state"/>
										<dict:fieldRef bean="course.cross-listed.internal.id"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!-- This identifier holds the version information for courses that have multiple versions -->
								<!-- Variation -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.version.no"/>
										<dict:fieldRef bean="course.version.transcriptTitle"/>
										<dict:fieldRef bean="course.version.catalogTitle"/>
										<dict:fieldRef bean="course.version.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea.submitted"/>
										<dict:fieldRef bean="course.cross-listed.numberPart.submitted"/>
										<dict:fieldRef bean="course.version.version"/>
										<dict:fieldRef bean="course.version.adminOrg"/>
										<dict:fieldRef bean="course.version.type"/>
										<dict:fieldRef bean="course.version.state"/>
										<dict:fieldRef bean="course.version.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.version.no"/>
										<dict:fieldRef bean="course.version.transcriptTitle"/>
										<dict:fieldRef bean="course.version.catalogTitle"/>
										<dict:fieldRef bean="course.version.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea.submitted"/>
										<dict:fieldRef bean="course.cross-listed.numberPart.submitted"/>
										<dict:fieldRef bean="course.version.version"/>
										<dict:fieldRef bean="course.version.adminOrg"/>
										<dict:fieldRef bean="course.version.type"/>
										<dict:fieldRef bean="course.version.state"/>
										<dict:fieldRef bean="course.version.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="zero.or.more.cross-listed.identifiers.zero.or.more.version.identifiers"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.studySubjectArea"/>
				
				<dict:field id="course.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>course desc</dict:name>
						<dict:desc>dscription</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="course.desc.plain"/>
										<dict:fieldRef bean="course.desc.formatted"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.accreditation"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.primaryInstructor"/>
				<dict:fieldRef bean="course.instructors"/>
				<dict:fieldRef bean="course.expectedFirstAtp"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.total.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.canCreateLui"/>
				<dict:fieldRef bean="course.referenceURL"/>
				<dict:fieldRef bean="course.luCodes"/>
				<dict:fieldRef bean="course.publishingInfo"/>
				<dict:fieldRef bean="course.nextReviewPeriod"/>
				<dict:fieldRef bean="course.isEnrollable"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.feeInfo"/>
				<dict:fieldRef bean="course.accountingInfo"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before activated) -->
				
				<dict:field key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>course no</dict:name>
						<dict:desc>course no</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.official.no"/>
										<dict:fieldRef bean="course.official.transcriptTitle"/>
										<dict:fieldRef bean="course.official.catalogTitle"/>
										<dict:fieldRef bean="course.official.level"/>
										
										<dict:field id="course.official.subjectArea.withdrawn" key="division">
											<dict:fieldDescriptor>
												<dict:name>course official subjectArea</dict:name>
												<dict:desc>subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.numberPart.withdrawn" key="suffixCode">
											<dict:fieldDescriptor>
												<dict:name>course official numberPart</dict:name>
												<dict:desc>number part of the course number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="available.course.numbers"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.official.version"/>
										<dict:fieldRef bean="course.official.adminOrg"/>
										<dict:fieldRef bean="course.official.type"/>
										<dict:fieldRef bean="course.official.state"/>
										<dict:fieldRef bean="course.official.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.official.no"/>
										<dict:fieldRef bean="course.official.transcriptTitle"/>
										<dict:fieldRef bean="course.official.catalogTitle"/>
										<dict:fieldRef bean="course.official.level"/>
										<dict:fieldRef bean="course.official.subjectArea.withdrawn"/>
										<dict:fieldRef bean="course.official.numberPart.withdrawn"/>
										<dict:fieldRef bean="course.official.version"/>
										<dict:fieldRef bean="course.official.adminOrg"/>
										<dict:fieldRef bean="course.official.type"/>
										<dict:fieldRef bean="course.official.state"/>
										<dict:fieldRef bean="course.official.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="exactly.one.official.identifier"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field key="alternateIdentifiers">
					<dict:fieldDescriptor>
						<dict:name>course alternateIdentifiers</dict:name>
						<dict:desc>course alternate ids</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.cross-listed">
								<!-- This identifier holds the cross-listed identifiers for this course -->
								<!-- (MIT's meaning of joint) -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.cross-listed.no"/>
										<dict:fieldRef bean="course.cross-listed.transcriptTitle"/>
										<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
										<dict:fieldRef bean="course.cross-listed.level"/>
										
										<dict:field id="course.cross-listed.subjectArea.withdrawn" key="division">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed subjectArea</dict:name>
												<dict:desc>cross-listed subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.numberPart.withdrawn" key="suffixCode">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed numberPart</dict:name>
												<dict:desc>number part of cross-listed number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="available.course.numbers"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.cross-listed.version"/>
										<dict:fieldRef bean="course.cross-listed.adminOrg"/>
										<dict:fieldRef bean="course.cross-listed.type"/>
										<dict:fieldRef bean="course.cross-listed.state"/>
										<dict:fieldRef bean="course.cross-listed.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.cross-listed.no"/>
										<dict:fieldRef bean="course.cross-listed.transcriptTitle"/>
										<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
										<dict:fieldRef bean="course.cross-listed.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea.withdrawn"/>
										<dict:fieldRef bean="course.cross-listed.numberPart.withdrawn"/>
										<dict:fieldRef bean="course.cross-listed.version"/>
										<dict:fieldRef bean="course.cross-listed.adminOrg"/>
										<dict:fieldRef bean="course.cross-listed.type"/>
										<dict:fieldRef bean="course.cross-listed.state"/>
										<dict:fieldRef bean="course.cross-listed.internal.id"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!-- This identifier holds the version information for courses that have multiple versions -->
								<!-- Variation -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.version.no"/>
										<dict:fieldRef bean="course.version.transcriptTitle"/>
										<dict:fieldRef bean="course.version.catalogTitle"/>
										<dict:fieldRef bean="course.version.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea.withdrawn"/>
										<dict:fieldRef bean="course.cross-listed.numberPart.withdrawn"/>
										<dict:fieldRef bean="course.version.version"/>
										<dict:fieldRef bean="course.version.adminOrg"/>
										<dict:fieldRef bean="course.version.type"/>
										<dict:fieldRef bean="course.version.state"/>
										<dict:fieldRef bean="course.version.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.version.no"/>
										<dict:fieldRef bean="course.version.transcriptTitle"/>
										<dict:fieldRef bean="course.version.catalogTitle"/>
										<dict:fieldRef bean="course.version.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea.withdrawn"/>
										<dict:fieldRef bean="course.cross-listed.numberPart.withdrawn"/>
										<dict:fieldRef bean="course.version.version"/>
										<dict:fieldRef bean="course.version.adminOrg"/>
										<dict:fieldRef bean="course.version.type"/>
										<dict:fieldRef bean="course.version.state"/>
										<dict:fieldRef bean="course.version.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="zero.or.more.cross-listed.identifiers.zero.or.more.version.identifiers"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.studySubjectArea"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.accreditation"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.primaryInstructor"/>
				<dict:fieldRef bean="course.instructors"/>
				<dict:fieldRef bean="course.expectedFirstAtp"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.total.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.canCreateLui"/>
				<dict:fieldRef bean="course.referenceURL"/>
				<dict:fieldRef bean="course.luCodes"/>
				<dict:fieldRef bean="course.publishingInfo"/>
				<dict:fieldRef bean="course.nextReviewPeriod"/>
				<dict:fieldRef bean="course.isEnrollable"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.feeInfo"/>
				<dict:fieldRef bean="course.accountingInfo"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="course.official"/>
				<dict:fieldRef bean="course.alternateIdentifiers"/>
				<dict:fieldRef bean="course.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.studySubjectArea"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.accreditation"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.primaryInstructor"/>
				<dict:fieldRef bean="course.instructors"/>
				<dict:fieldRef bean="course.expectedFirstAtp"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.total.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.canCreateLui"/>
				<dict:fieldRef bean="course.referenceURL"/>
				<dict:fieldRef bean="course.luCodes"/>
				<dict:fieldRef bean="course.publishingInfo"/>
				<dict:fieldRef bean="course.nextReviewPeriod"/>
				<dict:fieldRef bean="course.isEnrollable"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.feeInfo"/>
				<dict:fieldRef bean="course.accountingInfo"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved (rejected) -->
			<!-- Do we need here some indication of why it was not approved?  I.e. disapproved vs. not acted on because submitted too late, etc. -->
				
				<dict:field key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>course no</dict:name>
						<dict:desc>course no</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.official.no"/>
										<dict:fieldRef bean="course.official.transcriptTitle"/>
										<dict:fieldRef bean="course.official.catalogTitle"/>
										<dict:fieldRef bean="course.official.level"/>
										
										<dict:field id="course.official.subjectArea.rejected" key="division">
											<dict:fieldDescriptor>
												<dict:name>course official subjectArea</dict:name>
												<dict:desc>subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.numberPart.rejected" key="suffixCode">
											<dict:fieldDescriptor>
												<dict:name>course official numberPart</dict:name>
												<dict:desc>number part of the course number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="available.course.numbers"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.official.version"/>
										<dict:fieldRef bean="course.official.adminOrg"/>
										<dict:fieldRef bean="course.official.type"/>
										<dict:fieldRef bean="course.official.state"/>
										<dict:fieldRef bean="course.official.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.official.no"/>
										<dict:fieldRef bean="course.official.transcriptTitle"/>
										<dict:fieldRef bean="course.official.catalogTitle"/>
										<dict:fieldRef bean="course.official.level"/>
										<dict:fieldRef bean="course.official.subjectArea.rejected"/>
										<dict:fieldRef bean="course.official.numberPart.rejected"/>
										<dict:fieldRef bean="course.official.version"/>
										<dict:fieldRef bean="course.official.adminOrg"/>
										<dict:fieldRef bean="course.official.type"/>
										<dict:fieldRef bean="course.official.state"/>
										<dict:fieldRef bean="course.official.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="exactly.one.official.identifier"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field key="alternateIdentifiers">
					<dict:fieldDescriptor>
						<dict:name>course alternateIdentifiers</dict:name>
						<dict:desc>course alternate ids</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.cross-listed">
								<!-- This identifier holds the cross-listed identifiers for this course -->
								<!-- (MIT's meaning of joint) -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.cross-listed.no"/>
										<dict:fieldRef bean="course.cross-listed.transcriptTitle"/>
										<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
										<dict:fieldRef bean="course.cross-listed.level"/>
										
										<dict:field id="course.cross-listed.subjectArea.rejected" key="division">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed subjectArea</dict:name>
												<dict:desc>cross-listed subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.numberPart.rejected" key="suffixCode">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed numberPart</dict:name>
												<dict:desc>number part of cross-listed number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="available.course.numbers"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.cross-listed.version"/>
										<dict:fieldRef bean="course.cross-listed.adminOrg"/>
										<dict:fieldRef bean="course.cross-listed.type"/>
										<dict:fieldRef bean="course.cross-listed.state"/>
										<dict:fieldRef bean="course.cross-listed.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.cross-listed.no"/>
										<dict:fieldRef bean="course.cross-listed.transcriptTitle"/>
										<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
										<dict:fieldRef bean="course.cross-listed.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea.rejected"/>
										<dict:fieldRef bean="course.cross-listed.numberPart.rejected"/>
										<dict:fieldRef bean="course.cross-listed.version"/>
										<dict:fieldRef bean="course.cross-listed.adminOrg"/>
										<dict:fieldRef bean="course.cross-listed.type"/>
										<dict:fieldRef bean="course.cross-listed.state"/>
										<dict:fieldRef bean="course.cross-listed.internal.id"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!-- This identifier holds the version information for courses that have multiple versions -->
								<!-- Variation -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.version.no"/>
										<dict:fieldRef bean="course.version.transcriptTitle"/>
										<dict:fieldRef bean="course.version.catalogTitle"/>
										<dict:fieldRef bean="course.version.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea.rejected"/>
										<dict:fieldRef bean="course.cross-listed.numberPart.rejected"/>
										<dict:fieldRef bean="course.version.version"/>
										<dict:fieldRef bean="course.version.adminOrg"/>
										<dict:fieldRef bean="course.version.type"/>
										<dict:fieldRef bean="course.version.state"/>
										<dict:fieldRef bean="course.version.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.version.no"/>
										<dict:fieldRef bean="course.version.transcriptTitle"/>
										<dict:fieldRef bean="course.version.catalogTitle"/>
										<dict:fieldRef bean="course.version.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea.rejected"/>
										<dict:fieldRef bean="course.cross-listed.numberPart.rejected"/>
										<dict:fieldRef bean="course.version.version"/>
										<dict:fieldRef bean="course.version.adminOrg"/>
										<dict:fieldRef bean="course.version.type"/>
										<dict:fieldRef bean="course.version.state"/>
										<dict:fieldRef bean="course.version.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="zero.or.more.cross-listed.identifiers.zero.or.more.version.identifiers"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.studySubjectArea"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.accreditation"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.primaryInstructor"/>
				<dict:fieldRef bean="course.instructors"/>
				<dict:fieldRef bean="course.expectedFirstAtp"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.total.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.canCreateLui"/>
				<dict:fieldRef bean="course.referenceURL"/>
				<dict:fieldRef bean="course.luCodes"/>
				<dict:fieldRef bean="course.publishingInfo"/>
				<dict:fieldRef bean="course.nextReviewPeriod"/>
				<dict:fieldRef bean="course.isEnrollable"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.feeInfo"/>
				<dict:fieldRef bean="course.accountingInfo"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internal.id"/>
			</dict:state>
			<dict:state key="activated">
			<!-- Activated and ready to be published -->
				<dict:fieldRef bean="course.official"/>
				<dict:fieldRef bean="course.alternateIdentifiers"/>
				<dict:fieldRef bean="course.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.studySubjectArea"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.accreditation"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.primaryInstructor"/>
				<dict:fieldRef bean="course.instructors"/>
				<dict:fieldRef bean="course.expectedFirstAtp"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.total.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.canCreateLui"/>
				<dict:fieldRef bean="course.referenceURL"/>
				<dict:fieldRef bean="course.luCodes"/>
				<dict:fieldRef bean="course.publishingInfo"/>
				<dict:fieldRef bean="course.nextReviewPeriod"/>
				<dict:fieldRef bean="course.isEnrollable"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.feeInfo"/>
				<dict:fieldRef bean="course.accountingInfo"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- Do we need/want to differentiate here between retiring a course simply because it will no longer be taught and retiring a version of a course because it has been superceded by a newer version. -->
				<dict:fieldRef bean="course.official"/>
				<dict:fieldRef bean="course.alternateIdentifiers"/>
				<dict:fieldRef bean="course.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.studySubjectArea"/>
				<dict:fieldRef bean="course.desc"/>
				<dict:fieldRef bean="course.rationale"/>
				<dict:fieldRef bean="course.campusLocation"/>
				<dict:fieldRef bean="course.accreditation"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.primaryInstructor"/>
				<dict:fieldRef bean="course.instructors"/>
				<dict:fieldRef bean="course.expectedFirstAtp"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				
				<dict:field id="course.expirationDate.retired" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>course expirationDate</dict:name>
						<dict:desc>last date can be offerred</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
							<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.total.contact.hours"/>
				<dict:fieldRef bean="course.duration"/>
				<dict:fieldRef bean="course.canCreateLui"/>
				<dict:fieldRef bean="course.referenceURL"/>
				<dict:fieldRef bean="course.luCodes"/>
				<dict:fieldRef bean="course.publishingInfo"/>
				<dict:fieldRef bean="course.nextReviewPeriod"/>
				<dict:fieldRef bean="course.isEnrollable"/>
				<dict:fieldRef bean="course.seasons"/>
				<dict:fieldRef bean="course.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.feeInfo"/>
				<dict:fieldRef bean="course.accountingInfo"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.lu.type.CreditCourseFormatShell">
		<!-- This is really just a container to attach the activities for a given course format (each credit course can have multiple course formats each with a set of activities) -->
		<!-- Delivery methods -->
			<dict:state key="template">
			<!-- A template holds configuration for defaults for creating a new course -->
				
				<dict:field id="course.format.official" key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>course format name</dict:name>
						<dict:desc>name of the course format</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										
										<dict:field id="course.format.official.code" key="code">
											<dict:fieldDescriptor>
												<dict:name>code</dict:name>
												<dict:desc>code</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.official.shortName" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course format short name</dict:name>
												<dict:desc>course format short name</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="not.used"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.format.official.shortName">
														<dict:maxLength>20</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.official.name" key="longName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course format long name</dict:name>
												<dict:desc>course format long name</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="required"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.format.official.name">
														<dict:maxLength>60</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.official.level" key="level">
											<dict:fieldDescriptor>
												<dict:name>level</dict:name>
												<dict:desc>level</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.official.division" key="division">
											<dict:fieldDescriptor>
												<dict:name>division</dict:name>
												<dict:desc>division</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.official.suffixCode" key="suffixCode">
											<dict:fieldDescriptor>
												<dict:name>suffix code</dict:name>
												<dict:desc>suffix code</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.official.variation" key="variation">
											<dict:fieldDescriptor>
												<dict:name>variation</dict:name>
												<dict:desc>variation</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.official.orgId" key="orgId">
											<dict:fieldDescriptor>
												<dict:name>orgId</dict:name>
												<dict:desc>orgId</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.orgId"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.official.type" key="type">
											<!-- Required when first adding but read-only thereafter -->
											<dict:fieldDescriptor>
												<dict:name>course format official type</dict:name>
												<dict:desc>official</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="lu.identifier.types"/>
													<dict:constraintRef bean="hard.coded.official"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.official.state" key="state">
											<dict:fieldDescriptor>
												<dict:name>course format official state</dict:name>
												<dict:desc>state</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.state"/>
													<dict:constraintRef bean="lu.identifier.states"/>
													<dict:constraintRef bean="hard.coded.active"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.official.internal.id" key="id">
											<!-- should be blank when first adding but required thereafter for updates -->
											<dict:fieldDescriptor>
												<dict:name>course format official internalId</dict:name>
												<dict:desc>internal id of this id</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.id"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.format.official.code"/>
										<dict:fieldRef bean="course.format.official.shortName"/>
										<dict:fieldRef bean="course.format.official.name"/>
										<dict:fieldRef bean="course.format.official.level"/>
										<dict:fieldRef bean="course.format.official.division"/>
										<dict:fieldRef bean="course.format.official.suffixCode"/>
										<dict:fieldRef bean="course.format.official.variation"/>
										<dict:fieldRef bean="course.format.official.orgId"/>
										<dict:fieldRef bean="course.format.official.type"/>
										<dict:fieldRef bean="course.format.official.state"/>
										<dict:fieldRef bean="course.format.official.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.alternateIdentifiers" key="alternateIdentifiers">
					<dict:fieldDescriptor>
						<dict:name>course format alternateIdentifiers</dict:name>
						<dict:desc>course format shell alternateIdentifiers</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.academicSubjectOrgs" key="academicSubjectOrgs">
					<dict:fieldDescriptor>
						<dict:name>course format academicSubjectOrgs</dict:name>
						<dict:desc>course format academicSubjectOrgs</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.studySubjectArea" key="studySubjectArea">
					<dict:fieldDescriptor>
						<dict:name>course format studySubjectArea</dict:name>
						<dict:desc>course format studySubjectArea</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="code"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>course format desc</dict:name>
						<dict:desc>course format desc</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.marketingDesc" key="marketingDesc">
					<dict:fieldDescriptor>
						<dict:name>course format marketingDesc</dict:name>
						<dict:desc>course format marketingDesc</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.campusLocations" key="campusLocationList">
					<dict:fieldDescriptor>
						<dict:name>course format campusLocationList</dict:name>
						<dict:desc>course format campusLocationList</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="code"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.accreditation" key="accreditation">
					<dict:fieldDescriptor>
						<dict:name>course format accreditation</dict:name>
						<dict:desc>course format accreditation</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.primaryAdminOrg" key="primaryAdminOrg">
					<dict:fieldDescriptor>
						<dict:name>course format primaryAdminOrg</dict:name>
						<dict:desc>course format primaryAdminOrg</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.alternateAdminOrgs" key="alternateAdminOrgs">
					<dict:fieldDescriptor>
						<dict:name>course format alternateAdminOrgs</dict:name>
						<dict:desc>course format alternateAdminOrgs</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.primaryInstructor" key="primaryInstructor">
					<dict:fieldDescriptor>
						<dict:name>course format primaryInstructor</dict:name>
						<dict:desc>course format primaryInstructor</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.instructors" key="instructors">
					<dict:fieldDescriptor>
						<dict:name>course format instructors</dict:name>
						<dict:desc>course format instructors</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.expectedFirstAtp" key="expectedFirstAtp">
					<dict:fieldDescriptor>
						<dict:name>course format expectedFirstAtp</dict:name>
						<dict:desc>course format expectedFirstAtp</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="atp.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>course format effectiveDate</dict:name>
						<dict:desc>course format effectiveDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>course format expirationDate</dict:name>
						<dict:desc>course format expirationDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.total.contact.hours" key="intensity">
					<!-- this doesn't exist on the current UI but I know we will want this some day -->
					<dict:fieldDescriptor>
						<dict:name>course format intensity</dict:name>
						<dict:desc>course format intensity</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.duration" key="stdDuration">
					<dict:fieldDescriptor>
						<dict:name>course format stdDuration</dict:name>
						<dict:desc>course format duration</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.format.duration.units" key="atpDurationTypeKey">
											<!-- services has this flagged as mandatory but don't think it shoujld be because in a draft state a user may specify the units but not yet specify the amount -->
											<dict:fieldDescriptor>
												<dict:name>course duration units</dict:name>
												<dict:desc>Units in which the duration of the course is expressed</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="duration.types"/>
													<dict:constraintRef bean="valid.duration.types"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.duration.no" key="timeQuantity">
											<!-- services has this flagged as mandatory but don't think it shoujld be because in a draft state a user may specify the amount but not yet specify the units because they are unsure but we still need to save -->
											<!-- How do we add a min and max VALUE limit (not min and max size and occurrence) -->
											<dict:fieldDescriptor>
												<dict:name>course duration no</dict:name>
												<dict:desc>number of the duration units</dict:desc>
												<dict:dataType>integer</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="integer"/>
													<dict:constraintRef bean="hard.coded.one"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.canCreateLui" key="canCreateLui">
					<dict:fieldDescriptor>
						<dict:name>course format canCreateLui</dict:name>
						<dict:desc>course format canCreateLui</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.referenceURL" key="referenceURL">
					<dict:fieldDescriptor>
						<dict:name>course format referenceURL</dict:name>
						<dict:desc>course format referenceURL</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="url"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.luCodes" key="luCodes">
					<dict:fieldDescriptor>
						<dict:name>course format luCodes</dict:name>
						<dict:desc>course format luCodes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.publishingInfo" key="publishingInfo">
					<dict:fieldDescriptor>
						<dict:name>course format publishingInfo</dict:name>
						<dict:desc>course format publishingInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.nextReviewPeriod" key="nextReviewPeriod">
					<dict:fieldDescriptor>
						<dict:name>course format nextReviewPeriod</dict:name>
						<dict:desc>course format nextReviewPeriod</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="atp.types"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.isEnrollable" key="isEnrollable">
					<!-- defaults to TRUE -->
					<dict:fieldDescriptor>
						<dict:name>course format isEnrollable</dict:name>
						<dict:desc>course format isEnrollable</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="default.true"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.offeredAtpTypes" key="offeredAtpTypes">
					<!-- Services has this as an atpKeyList but that is just a list of Strings so I didn't create the sub-structure -->
					<dict:fieldDescriptor>
						<dict:name>course format offeredAtpTypes</dict:name>
						<dict:desc>The time periods for whichthe course format it can be offered</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="atp.types"/>
							<dict:constraintRef bean="valid.atp.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.hasEarlyDropDeadline" key="hasEarlyDropDeadline">
					<dict:fieldDescriptor>
						<dict:name>course format hasEarlyDropDeadline</dict:name>
						<dict:desc>course format hasEarlyDropDeadline</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.defaultEnrollmentEstimate" key="defaultEnrollmentEstimate">
					<dict:fieldDescriptor>
						<dict:name>course format defaultEnrollmentEstimate</dict:name>
						<dict:desc>course format defaultEnrollmentEstimate</dict:desc>
						<dict:dataType>integer</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="non-negative.integer"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.defaultMaximumEnrollment" key="defaultMaximumEnrollment">
					<dict:fieldDescriptor>
						<dict:name>course format defaultMaximumEnrollment</dict:name>
						<dict:desc>course format defaultMaximumEnrollment</dict:desc>
						<dict:dataType>integer</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="non-negative.integer"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.isHazardousForDisabledStudents" key="isHazardousForDisabledStudents">
					<dict:fieldDescriptor>
						<dict:name>course format isHazardousForDisabledStudents</dict:name>
						<dict:desc>course format isHazardousForDisabledStudents</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.feeInfo" key="feeInfo">
					<dict:fieldDescriptor>
						<dict:name>course format feeInfo</dict:name>
						<dict:desc>course format feeInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.accountingInfo" key="accountingInfo">
					<dict:fieldDescriptor>
						<dict:name>course format accountingInfo</dict:name>
						<dict:desc>course format accountingInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.attributes" key="attributes">
					<!-- Services has this as an attributeInfoList but that is just a list of the attributeInfo substructure so I did't create the intermediary list sub-structure -->
					<dict:fieldDescriptor>
						<dict:name>attributes</dict:name>
						<dict:desc>attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.metaInfo" key="metaInfo">
					<!-- must be empty on create but required on update -->
					<dict:fieldDescriptor>
						<dict:name>metaInfo</dict:name>
						<dict:desc>metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.format.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>course colocated meta versionInd</dict:name>
												<dict:desc>Version number for this colocated course relationship info</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>course colocated meta createTime</dict:name>
												<dict:desc>Date-time this co-located course relationship was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>course colocated meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this co-located course relationship</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>course colocated meta updateTime</dict:name>
												<dict:desc>Date-time this co-located course relationship was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>course colocated meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this co-located course relationship</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.type" key="type">
					<!-- Requierd on the create but read-only after that -->
					<dict:fieldDescriptor>
						<dict:name>type</dict:name>
						<dict:desc>type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="lu.types"/>
							<dict:constraintRef bean="hard.coded.type.credit.course.format.shell"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>course format state</dict:name>
						<dict:desc>course format state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
							<dict:constraintRef bean="lu.states"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="course.format.internal.id" key="id">
					<!-- must be empty on create but required on update -->
					<dict:fieldDescriptor>
						<dict:name>course format internal ID</dict:name>
						<dict:desc>internal Id</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				<dict:fieldRef bean="course.format.official"/>
				<dict:fieldRef bean="course.format.alternateIdentifiers"/>
				<dict:fieldRef bean="course.format.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.format.studySubjectArea"/>
				<dict:fieldRef bean="course.format.desc"/>
				<dict:fieldRef bean="course.format.marketingDesc"/>
				<dict:fieldRef bean="course.format.campusLocations"/>
				<dict:fieldRef bean="course.format.accreditation"/>
				<dict:fieldRef bean="course.format.primaryAdminOrg"/>
				<dict:fieldRef bean="course.format.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.format.primaryInstructor"/>
				<dict:fieldRef bean="course.format.instructors"/>
				<dict:fieldRef bean="course.format.expectedFirstAtp"/>
				<dict:fieldRef bean="course.format.effectiveDate"/>
				<dict:fieldRef bean="course.format.expirationDate"/>
				<dict:fieldRef bean="course.format.total.contact.hours"/>
				<dict:fieldRef bean="course.format.duration"/>
				<dict:fieldRef bean="course.format.canCreateLui"/>
				<dict:fieldRef bean="course.format.referenceURL"/>
				<dict:fieldRef bean="course.format.luCodes"/>
				<dict:fieldRef bean="course.format.publishingInfo"/>
				<dict:fieldRef bean="course.format.nextReviewPeriod"/>
				<dict:fieldRef bean="course.format.isEnrollable"/>
				<dict:fieldRef bean="course.format.offeredAtpTypes"/>
				<dict:fieldRef bean="course.format.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.format.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.format.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.format.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.format.feeInfo"/>
				<dict:fieldRef bean="course.format.accountingInfo"/>
				<dict:fieldRef bean="course.format.attributes"/>
				<dict:fieldRef bean="course.format.metaInfo"/>
				<dict:fieldRef bean="course.format.type"/>
				<dict:fieldRef bean="course.format.state"/>
				<dict:fieldRef bean="course.format.internal.id"/>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="course.format.official"/>
				<dict:fieldRef bean="course.format.alternateIdentifiers"/>
				<dict:fieldRef bean="course.format.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.format.studySubjectArea"/>
				<dict:fieldRef bean="course.format.desc"/>
				<dict:fieldRef bean="course.format.marketingDesc"/>
				<dict:fieldRef bean="course.format.campusLocations"/>
				<dict:fieldRef bean="course.format.accreditation"/>
				<dict:fieldRef bean="course.format.primaryAdminOrg"/>
				<dict:fieldRef bean="course.format.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.format.primaryInstructor"/>
				<dict:fieldRef bean="course.format.instructors"/>
				<dict:fieldRef bean="course.format.expectedFirstAtp"/>
				<dict:fieldRef bean="course.format.effectiveDate"/>
				<dict:fieldRef bean="course.format.expirationDate"/>
				<dict:fieldRef bean="course.format.total.contact.hours"/>
				<dict:fieldRef bean="course.format.duration"/>
				<dict:fieldRef bean="course.format.canCreateLui"/>
				<dict:fieldRef bean="course.format.referenceURL"/>
				<dict:fieldRef bean="course.format.luCodes"/>
				<dict:fieldRef bean="course.format.publishingInfo"/>
				<dict:fieldRef bean="course.format.nextReviewPeriod"/>
				<dict:fieldRef bean="course.format.isEnrollable"/>
				<dict:fieldRef bean="course.format.offeredAtpTypes"/>
				<dict:fieldRef bean="course.format.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.format.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.format.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.format.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.format.feeInfo"/>
				<dict:fieldRef bean="course.format.accountingInfo"/>
				<dict:fieldRef bean="course.format.attributes"/>
				<dict:fieldRef bean="course.format.metaInfo"/>
				<dict:fieldRef bean="course.format.type"/>
				<dict:fieldRef bean="course.format.state"/>
				<dict:fieldRef bean="course.format.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
				<dict:fieldRef bean="course.format.official"/>
				<dict:fieldRef bean="course.format.alternateIdentifiers"/>
				<dict:fieldRef bean="course.format.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.format.studySubjectArea"/>
				<dict:fieldRef bean="course.format.desc"/>
				<dict:fieldRef bean="course.format.marketingDesc"/>
				<dict:fieldRef bean="course.format.campusLocations"/>
				<dict:fieldRef bean="course.format.accreditation"/>
				<dict:fieldRef bean="course.format.primaryAdminOrg"/>
				<dict:fieldRef bean="course.format.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.format.primaryInstructor"/>
				<dict:fieldRef bean="course.format.instructors"/>
				<dict:fieldRef bean="course.format.expectedFirstAtp"/>
				<dict:fieldRef bean="course.format.effectiveDate"/>
				<dict:fieldRef bean="course.format.expirationDate"/>
				<dict:fieldRef bean="course.format.total.contact.hours"/>
				<dict:fieldRef bean="course.format.duration"/>
				<dict:fieldRef bean="course.format.canCreateLui"/>
				<dict:fieldRef bean="course.format.referenceURL"/>
				<dict:fieldRef bean="course.format.luCodes"/>
				<dict:fieldRef bean="course.format.publishingInfo"/>
				<dict:fieldRef bean="course.format.nextReviewPeriod"/>
				<dict:fieldRef bean="course.format.isEnrollable"/>
				<dict:fieldRef bean="course.format.offeredAtpTypes"/>
				<dict:fieldRef bean="course.format.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.format.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.format.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.format.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.format.feeInfo"/>
				<dict:fieldRef bean="course.format.accountingInfo"/>
				<dict:fieldRef bean="course.format.attributes"/>
				<dict:fieldRef bean="course.format.metaInfo"/>
				<dict:fieldRef bean="course.format.type"/>
				<dict:fieldRef bean="course.format.state"/>
				<dict:fieldRef bean="course.format.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before activated) -->
				<dict:fieldRef bean="course.format.official"/>
				<dict:fieldRef bean="course.format.alternateIdentifiers"/>
				<dict:fieldRef bean="course.format.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.format.studySubjectArea"/>
				<dict:fieldRef bean="course.format.desc"/>
				<dict:fieldRef bean="course.format.marketingDesc"/>
				<dict:fieldRef bean="course.format.campusLocations"/>
				<dict:fieldRef bean="course.format.accreditation"/>
				<dict:fieldRef bean="course.format.primaryAdminOrg"/>
				<dict:fieldRef bean="course.format.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.format.primaryInstructor"/>
				<dict:fieldRef bean="course.format.instructors"/>
				<dict:fieldRef bean="course.format.expectedFirstAtp"/>
				<dict:fieldRef bean="course.format.effectiveDate"/>
				<dict:fieldRef bean="course.format.expirationDate"/>
				<dict:fieldRef bean="course.format.total.contact.hours"/>
				<dict:fieldRef bean="course.format.duration"/>
				<dict:fieldRef bean="course.format.canCreateLui"/>
				<dict:fieldRef bean="course.format.referenceURL"/>
				<dict:fieldRef bean="course.format.luCodes"/>
				<dict:fieldRef bean="course.format.publishingInfo"/>
				<dict:fieldRef bean="course.format.nextReviewPeriod"/>
				<dict:fieldRef bean="course.format.isEnrollable"/>
				<dict:fieldRef bean="course.format.offeredAtpTypes"/>
				<dict:fieldRef bean="course.format.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.format.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.format.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.format.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.format.feeInfo"/>
				<dict:fieldRef bean="course.format.accountingInfo"/>
				<dict:fieldRef bean="course.format.attributes"/>
				<dict:fieldRef bean="course.format.metaInfo"/>
				<dict:fieldRef bean="course.format.type"/>
				<dict:fieldRef bean="course.format.state"/>
				<dict:fieldRef bean="course.format.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="course.format.official"/>
				<dict:fieldRef bean="course.format.alternateIdentifiers"/>
				<dict:fieldRef bean="course.format.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.format.studySubjectArea"/>
				<dict:fieldRef bean="course.format.desc"/>
				<dict:fieldRef bean="course.format.marketingDesc"/>
				<dict:fieldRef bean="course.format.campusLocations"/>
				<dict:fieldRef bean="course.format.accreditation"/>
				<dict:fieldRef bean="course.format.primaryAdminOrg"/>
				<dict:fieldRef bean="course.format.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.format.primaryInstructor"/>
				<dict:fieldRef bean="course.format.instructors"/>
				<dict:fieldRef bean="course.format.expectedFirstAtp"/>
				<dict:fieldRef bean="course.format.effectiveDate"/>
				<dict:fieldRef bean="course.format.expirationDate"/>
				<dict:fieldRef bean="course.format.total.contact.hours"/>
				<dict:fieldRef bean="course.format.duration"/>
				<dict:fieldRef bean="course.format.canCreateLui"/>
				<dict:fieldRef bean="course.format.referenceURL"/>
				<dict:fieldRef bean="course.format.luCodes"/>
				<dict:fieldRef bean="course.format.publishingInfo"/>
				<dict:fieldRef bean="course.format.nextReviewPeriod"/>
				<dict:fieldRef bean="course.format.isEnrollable"/>
				<dict:fieldRef bean="course.format.offeredAtpTypes"/>
				<dict:fieldRef bean="course.format.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.format.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.format.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.format.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.format.feeInfo"/>
				<dict:fieldRef bean="course.format.accountingInfo"/>
				<dict:fieldRef bean="course.format.attributes"/>
				<dict:fieldRef bean="course.format.metaInfo"/>
				<dict:fieldRef bean="course.format.type"/>
				<dict:fieldRef bean="course.format.state"/>
				<dict:fieldRef bean="course.format.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved (rejected) -->
			<!-- Do we need here some indication of why it was not approved?  I.e. disapproved vs. not acted on because submitted too late, etc. -->
				<dict:fieldRef bean="course.format.official"/>
				<dict:fieldRef bean="course.format.alternateIdentifiers"/>
				<dict:fieldRef bean="course.format.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.format.studySubjectArea"/>
				<dict:fieldRef bean="course.format.desc"/>
				<dict:fieldRef bean="course.format.marketingDesc"/>
				<dict:fieldRef bean="course.format.campusLocations"/>
				<dict:fieldRef bean="course.format.accreditation"/>
				<dict:fieldRef bean="course.format.primaryAdminOrg"/>
				<dict:fieldRef bean="course.format.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.format.primaryInstructor"/>
				<dict:fieldRef bean="course.format.instructors"/>
				<dict:fieldRef bean="course.format.expectedFirstAtp"/>
				<dict:fieldRef bean="course.format.effectiveDate"/>
				<dict:fieldRef bean="course.format.expirationDate"/>
				<dict:fieldRef bean="course.format.total.contact.hours"/>
				<dict:fieldRef bean="course.format.duration"/>
				<dict:fieldRef bean="course.format.canCreateLui"/>
				<dict:fieldRef bean="course.format.referenceURL"/>
				<dict:fieldRef bean="course.format.luCodes"/>
				<dict:fieldRef bean="course.format.publishingInfo"/>
				<dict:fieldRef bean="course.format.nextReviewPeriod"/>
				<dict:fieldRef bean="course.format.isEnrollable"/>
				<dict:fieldRef bean="course.format.offeredAtpTypes"/>
				<dict:fieldRef bean="course.format.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.format.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.format.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.format.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.format.feeInfo"/>
				<dict:fieldRef bean="course.format.accountingInfo"/>
				<dict:fieldRef bean="course.format.attributes"/>
				<dict:fieldRef bean="course.format.metaInfo"/>
				<dict:fieldRef bean="course.format.type"/>
				<dict:fieldRef bean="course.format.state"/>
				<dict:fieldRef bean="course.format.internal.id"/>
			</dict:state>
			<dict:state key="activated">
			<!-- Activated and ready to be published -->
				<dict:fieldRef bean="course.format.official"/>
				<dict:fieldRef bean="course.format.alternateIdentifiers"/>
				<dict:fieldRef bean="course.format.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.format.studySubjectArea"/>
				<dict:fieldRef bean="course.format.desc"/>
				<dict:fieldRef bean="course.format.marketingDesc"/>
				<dict:fieldRef bean="course.format.campusLocations"/>
				<dict:fieldRef bean="course.format.accreditation"/>
				<dict:fieldRef bean="course.format.primaryAdminOrg"/>
				<dict:fieldRef bean="course.format.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.format.primaryInstructor"/>
				<dict:fieldRef bean="course.format.instructors"/>
				<dict:fieldRef bean="course.format.expectedFirstAtp"/>
				<dict:fieldRef bean="course.format.effectiveDate"/>
				<dict:fieldRef bean="course.format.expirationDate"/>
				<dict:fieldRef bean="course.format.total.contact.hours"/>
				<dict:fieldRef bean="course.format.duration"/>
				<dict:fieldRef bean="course.format.canCreateLui"/>
				<dict:fieldRef bean="course.format.referenceURL"/>
				<dict:fieldRef bean="course.format.luCodes"/>
				<dict:fieldRef bean="course.format.publishingInfo"/>
				<dict:fieldRef bean="course.format.nextReviewPeriod"/>
				<dict:fieldRef bean="course.format.isEnrollable"/>
				<dict:fieldRef bean="course.format.offeredAtpTypes"/>
				<dict:fieldRef bean="course.format.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.format.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.format.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.format.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.format.feeInfo"/>
				<dict:fieldRef bean="course.format.accountingInfo"/>
				<dict:fieldRef bean="course.format.attributes"/>
				<dict:fieldRef bean="course.format.metaInfo"/>
				<dict:fieldRef bean="course.format.type"/>
				<dict:fieldRef bean="course.format.state"/>
				<dict:fieldRef bean="course.format.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- Do we need/want to differentiate here between retiring a course simply because it will no longer be taught and retiring a version of a course because it has been superceded by a newer version. -->
				<dict:fieldRef bean="course.format.official"/>
				<dict:fieldRef bean="course.format.alternateIdentifiers"/>
				<dict:fieldRef bean="course.format.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.format.studySubjectArea"/>
				<dict:fieldRef bean="course.format.desc"/>
				<dict:fieldRef bean="course.format.marketingDesc"/>
				<dict:fieldRef bean="course.format.campusLocations"/>
				<dict:fieldRef bean="course.format.accreditation"/>
				<dict:fieldRef bean="course.format.primaryAdminOrg"/>
				<dict:fieldRef bean="course.format.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.format.primaryInstructor"/>
				<dict:fieldRef bean="course.format.instructors"/>
				<dict:fieldRef bean="course.format.expectedFirstAtp"/>
				<dict:fieldRef bean="course.format.effectiveDate"/>
				<dict:fieldRef bean="course.format.expirationDate"/>
				<dict:fieldRef bean="course.format.total.contact.hours"/>
				<dict:fieldRef bean="course.format.duration"/>
				<dict:fieldRef bean="course.format.canCreateLui"/>
				<dict:fieldRef bean="course.format.referenceURL"/>
				<dict:fieldRef bean="course.format.luCodes"/>
				<dict:fieldRef bean="course.format.publishingInfo"/>
				<dict:fieldRef bean="course.format.nextReviewPeriod"/>
				<dict:fieldRef bean="course.format.isEnrollable"/>
				<dict:fieldRef bean="course.format.offeredAtpTypes"/>
				<dict:fieldRef bean="course.format.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.format.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.format.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.format.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.format.feeInfo"/>
				<dict:fieldRef bean="course.format.accountingInfo"/>
				<dict:fieldRef bean="course.format.attributes"/>
				<dict:fieldRef bean="course.format.metaInfo"/>
				<dict:fieldRef bean="course.format.type"/>
				<dict:fieldRef bean="course.format.state"/>
				<dict:fieldRef bean="course.format.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.lu.type.activity.WebLecture">
		<!-- Web-based or technologically-mediated activities replacing standard lectures -->
			<dict:state key="template">
			<!-- A template holds configuration for defaults for creating a new course -->
				
				<dict:field id="course.activity.official" key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>course activity name</dict:name>
						<dict:desc>name of the course activity</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										
										<dict:field id="course.activity.official.code" key="code">
											<dict:fieldDescriptor>
												<dict:name>code</dict:name>
												<dict:desc>code</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.official.shortName" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course activity short name</dict:name>
												<dict:desc>course activity short name</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="not.used"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.activity.official.shortName">
														<dict:maxLength>20</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.official.name" key="longName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course activity long name</dict:name>
												<dict:desc>course activity long name</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="required"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.activity.official.name">
														<dict:maxLength>60</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.official.level" key="level">
											<dict:fieldDescriptor>
												<dict:name>level</dict:name>
												<dict:desc>level</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.official.division" key="division">
											<dict:fieldDescriptor>
												<dict:name>division</dict:name>
												<dict:desc>division</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.official.suffixCode" key="suffixCode">
											<dict:fieldDescriptor>
												<dict:name>suffix code</dict:name>
												<dict:desc>suffix code</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.official.variation" key="variation">
											<dict:fieldDescriptor>
												<dict:name>variation</dict:name>
												<dict:desc>variation</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.official.orgId" key="orgId">
											<dict:fieldDescriptor>
												<dict:name>orgId</dict:name>
												<dict:desc>orgId</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.orgId"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.official.type" key="type">
											<!-- Required when first adding but read-only thereafter -->
											<dict:fieldDescriptor>
												<dict:name>course activity official type</dict:name>
												<dict:desc>official</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="lu.identifier.types"/>
													<dict:constraintRef bean="hard.coded.official"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.official.state" key="state">
											<dict:fieldDescriptor>
												<dict:name>course activity official state</dict:name>
												<dict:desc>state</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.state"/>
													<dict:constraintRef bean="lu.identifier.states"/>
													<dict:constraintRef bean="hard.coded.active"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.official.internal.id" key="id">
											<!-- should be blank when first adding but required thereafter for updates -->
											<dict:fieldDescriptor>
												<dict:name>course activity official internalId</dict:name>
												<dict:desc>internal id of this id</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.id"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.activity.official.code"/>
										<dict:fieldRef bean="course.activity.official.shortName"/>
										<dict:fieldRef bean="course.activity.official.name"/>
										<dict:fieldRef bean="course.activity.official.level"/>
										<dict:fieldRef bean="course.activity.official.division"/>
										<dict:fieldRef bean="course.activity.official.suffixCode"/>
										<dict:fieldRef bean="course.activity.official.variation"/>
										<dict:fieldRef bean="course.activity.official.orgId"/>
										<dict:fieldRef bean="course.activity.official.type"/>
										<dict:fieldRef bean="course.activity.official.state"/>
										<dict:fieldRef bean="course.activity.official.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.alternateIdentifiers" key="alternateIdentifiers">
					<dict:fieldDescriptor>
						<dict:name>course activity alternateIdentifiers</dict:name>
						<dict:desc>course activity shell alternateIdentifiers</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.academicSubjectOrgs" key="academicSubjectOrgs">
					<dict:fieldDescriptor>
						<dict:name>course activity academicSubjectOrgs</dict:name>
						<dict:desc>course activity academicSubjectOrgs</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.studySubjectArea" key="studySubjectArea">
					<dict:fieldDescriptor>
						<dict:name>course activity studySubjectArea</dict:name>
						<dict:desc>course activity studySubjectArea</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="code"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>course activity desc</dict:name>
						<dict:desc>course activity desc</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.marketingDesc" key="marketingDesc">
					<dict:fieldDescriptor>
						<dict:name>course activity marketingDesc</dict:name>
						<dict:desc>course activity marketingDesc</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.campusLocationList" key="campusLocationList">
					<dict:fieldDescriptor>
						<dict:name>course activity campusLocationList</dict:name>
						<dict:desc>course activity campusLocationList</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="code"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.accreditation" key="accreditation">
					<dict:fieldDescriptor>
						<dict:name>course activity accreditation</dict:name>
						<dict:desc>course activity accreditation</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.primaryAdminOrg" key="primaryAdminOrg">
					<dict:fieldDescriptor>
						<dict:name>course activity primaryAdminOrg</dict:name>
						<dict:desc>course activity primaryAdminOrg</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.alternateAdminOrgs" key="alternateAdminOrgs">
					<dict:fieldDescriptor>
						<dict:name>course activity alternateAdminOrgs</dict:name>
						<dict:desc>course activity alternateAdminOrgs</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.primaryInstructor" key="primaryInstructor">
					<dict:fieldDescriptor>
						<dict:name>course activity primaryInstructor</dict:name>
						<dict:desc>course activity primaryInstructor</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.instructors" key="instructors">
					<dict:fieldDescriptor>
						<dict:name>course activity instructors</dict:name>
						<dict:desc>course activity instructors</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.expectedFirstAtp" key="expectedFirstAtp">
					<dict:fieldDescriptor>
						<dict:name>course activity expectedFirstAtp</dict:name>
						<dict:desc>course activity expectedFirstAtp</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="atp.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>course activity effectiveDate</dict:name>
						<dict:desc>course activity effectiveDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>course activity expirationDate</dict:name>
						<dict:desc>course activity expirationDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.contact.hours" key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course activity contact hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.activity.contact.hours.per" key="unitType">
											<!-- must be supplied when adding but read-only thereafter -->
											<dict:fieldDescriptor>
												<dict:name>course activity contact hours per</dict:name>
												<dict:desc>Time period during which the contact hours are counted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="unit.types"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.contact.hours.no" key="unitQuantity">
											<dict:fieldDescriptor>
												<dict:name>course activity contact hours no</dict:name>
												<dict:desc>number of contact hours within the time period</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="decimal"/>
													<dict:constraintRef bean="non-negative.integer"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.activity.contact.hours.no">
														<dict:minValue>0</dict:minValue>
														<dict:maxValue>40</dict:maxValue>
														<dict:minLength>1</dict:minLength>
														<dict:maxLength>2</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.duration" key="stdDuration">
					<dict:fieldDescriptor>
						<dict:name>course activity stdDuration</dict:name>
						<dict:desc>course activity duration</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.activity.duration.units" key="atpDurationTypeKey">
											<!-- services has this flagged as mandatory but don't think it shoujld be because in a draft state a user may specify the units but not yet specify the amount -->
											<dict:fieldDescriptor>
												<dict:name>course duration units</dict:name>
												<dict:desc>Units in which the duration of the course is expressed</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="duration.types"/>
													<dict:constraintRef bean="valid.duration.types"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.duration.no" key="timeQuantity">
											<!-- services has this flagged as mandatory but don't think it shoujld be because in a draft state a user may specify the amount but not yet specify the units because they are unsure but we still need to save -->
											<!-- How do we add a min and max VALUE limit (not min and max size and occurrence) -->
											<dict:fieldDescriptor>
												<dict:name>course duration no</dict:name>
												<dict:desc>number of the duration units</dict:desc>
												<dict:dataType>integer</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="integer"/>
													<dict:constraintRef bean="hard.coded.one"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.canCreateLui" key="canCreateLui">
					<dict:fieldDescriptor>
						<dict:name>course activity canCreateLui</dict:name>
						<dict:desc>course activity canCreateLui</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.referenceURL" key="referenceURL">
					<dict:fieldDescriptor>
						<dict:name>course activity referenceURL</dict:name>
						<dict:desc>course activity referenceURL</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="url"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.luCodes" key="luCodes">
					<dict:fieldDescriptor>
						<dict:name>course activity luCodes</dict:name>
						<dict:desc>course activity luCodes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.publishingInfo" key="publishingInfo">
					<dict:fieldDescriptor>
						<dict:name>course activity publishingInfo</dict:name>
						<dict:desc>course activity publishingInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.nextReviewPeriod" key="nextReviewPeriod">
					<dict:fieldDescriptor>
						<dict:name>course activity nextReviewPeriod</dict:name>
						<dict:desc>course activity nextReviewPeriod</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="atp.types"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.isEnrollable" key="isEnrollable">
					<!-- defaults to TRUE -->
					<dict:fieldDescriptor>
						<dict:name>course activity isEnrollable</dict:name>
						<dict:desc>course activity isEnrollable</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="default.true"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.offeredAtpTypes" key="offeredAtpTypes">
					<!-- Services has this as an atpKeyList but that is just a list of Strings so I didn't create the sub-structure -->
					<dict:fieldDescriptor>
						<dict:name>course activity offeredAtpTypes</dict:name>
						<dict:desc>The time periods for whichthe course activity it can be offered</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="atp.types"/>
							<dict:constraintRef bean="valid.atp.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.hasEarlyDropDeadline" key="hasEarlyDropDeadline">
					<dict:fieldDescriptor>
						<dict:name>course activity hasEarlyDropDeadline</dict:name>
						<dict:desc>course activity hasEarlyDropDeadline</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.defaultEnrollmentEstimate" key="defaultEnrollmentEstimate">
					<dict:fieldDescriptor>
						<dict:name>course activity defaultEnrollmentEstimate</dict:name>
						<dict:desc>course activity defaultEnrollmentEstimate</dict:desc>
						<dict:dataType>integer</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="non-negative.integer"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.defaultMaximumEnrollment" key="defaultMaximumEnrollment">
					<dict:fieldDescriptor>
						<dict:name>course activity defaultMaximumEnrollment</dict:name>
						<dict:desc>course activity defaultMaximumEnrollment</dict:desc>
						<dict:dataType>integer</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="non-negative.integer"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.isHazardousForDisabledStudents" key="isHazardousForDisabledStudents">
					<dict:fieldDescriptor>
						<dict:name>course activity isHazardousForDisabledStudents</dict:name>
						<dict:desc>course activity isHazardousForDisabledStudents</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.feeInfo" key="feeInfo">
					<dict:fieldDescriptor>
						<dict:name>course activity feeInfo</dict:name>
						<dict:desc>course activity feeInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.accountingInfo" key="accountingInfo">
					<dict:fieldDescriptor>
						<dict:name>course activity accountingInfo</dict:name>
						<dict:desc>course activity accountingInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.attributes" key="attributes">
					<!-- Services has this as an attributeInfoList but that is just a list of the attributeInfo substructure so I did't create the intermediary list sub-structure -->
					<dict:fieldDescriptor>
						<dict:name>attributes</dict:name>
						<dict:desc>attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.metaInfo" key="metaInfo">
					<!-- must be empty on create but required on update -->
					<dict:fieldDescriptor>
						<dict:name>metaInfo</dict:name>
						<dict:desc>metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.activity.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>course colocated meta versionInd</dict:name>
												<dict:desc>Version number for this colocated course relationship info</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>course colocated meta createTime</dict:name>
												<dict:desc>Date-time this co-located course relationship was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>course colocated meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this co-located course relationship</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>course colocated meta updateTime</dict:name>
												<dict:desc>Date-time this co-located course relationship was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>course colocated meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this co-located course relationship</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.type" key="type">
					<!-- Requierd on the create but read-only after that -->
					<dict:fieldDescriptor>
						<dict:name>type</dict:name>
						<dict:desc>type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="lu.types"/>
							<dict:constraintRef bean="lu.activity.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>course activity state</dict:name>
						<dict:desc>course activity state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
							<dict:constraintRef bean="lu.states"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="course.activity.internal.id" key="id">
					<!-- must be empty on create but required on update -->
					<dict:fieldDescriptor>
						<dict:name>course activity internal ID</dict:name>
						<dict:desc>internal Id</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				
				<dict:field id="course.activity.contact.hours.draft.private" key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course activity contact hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.activity.contact.hours.per.draft.private" key="unitType">
											<!-- must be supplied when adding but read-only thereafter -->
											<dict:fieldDescriptor>
												<dict:name>course activity contact hours per</dict:name>
												<dict:desc>Time period during which the contact hours are counted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="unit.types"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.contact.hours.no.draft.private" key="unitQuantity">
											<dict:fieldDescriptor>
												<dict:name>course activity contact hours no</dict:name>
												<dict:desc>number of contact hours within the time period</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="decimal"/>
													<dict:constraintRef bean="non-negative.integer"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.activity.contact.hours.no.draft.private">
														<dict:minValue>0</dict:minValue>
														<dict:maxValue>40</dict:maxValue>
														<dict:minLength>1</dict:minLength>
														<dict:maxLength>2</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				
				<dict:field id="course.activity.contact.hours.draft.public" key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course activity contact hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.activity.contact.hours.per.draft.public" key="unitType">
											<!-- must be supplied when adding but read-only thereafter -->
											<dict:fieldDescriptor>
												<dict:name>course activity contact hours per</dict:name>
												<dict:desc>Time period during which the contact hours are counted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="unit.types"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.contact.hours.no.draft.public" key="unitQuantity">
											<dict:fieldDescriptor>
												<dict:name>course activity contact hours no</dict:name>
												<dict:desc>number of contact hours within the time period</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="decimal"/>
													<dict:constraintRef bean="non-negative.integer"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.activity.contact.hours.no.draft.public">
														<dict:minValue>0</dict:minValue>
														<dict:maxValue>40</dict:maxValue>
														<dict:minLength>1</dict:minLength>
														<dict:maxLength>2</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before activated) -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved (rejected) -->
			<!-- Do we need here some indication of why it was not approved?  I.e. disapproved vs. not acted on because submitted too late, etc. -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="activated">
			<!-- Activated and ready to be published -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- Do we need/want to differentiate here between retiring a course simply because it will no longer be taught and retiring a version of a course because it has been superceded by a newer version. -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.lu.type.activity.Discussion">
		<!-- The exchange of opinions or questions on course material -->
		<!-- Seminar Style, Roundtable Discussion -->
			<dict:state key="template">
			<!-- A template holds configuration for defaults for creating a new course -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				
				<dict:field key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course activity contact hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="course.activity.contact.hours.per.draft.private"/>
										<dict:fieldRef bean="course.activity.contact.hours.no.draft.private"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				
				<dict:field key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course activity contact hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="course.activity.contact.hours.per.draft.public"/>
										<dict:fieldRef bean="course.activity.contact.hours.no.draft.public"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before activated) -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved (rejected) -->
			<!-- Do we need here some indication of why it was not approved?  I.e. disapproved vs. not acted on because submitted too late, etc. -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="activated">
			<!-- Activated and ready to be published -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- Do we need/want to differentiate here between retiring a course simply because it will no longer be taught and retiring a version of a course because it has been superceded by a newer version. -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.lu.type.activity.WebDiscuss">
		<!-- Web-based or technologically-mediated activities replacing standard discussion sections -->
		<!-- Blog, Chat, Discussion Group, Learning Management System, LMS -->
			<dict:state key="template">
			<!-- A template holds configuration for defaults for creating a new course -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				
				<dict:field key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course activity contact hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="course.activity.contact.hours.per.draft.private"/>
										<dict:fieldRef bean="course.activity.contact.hours.no.draft.private"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				
				<dict:field key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course activity contact hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="course.activity.contact.hours.per.draft.public"/>
										<dict:fieldRef bean="course.activity.contact.hours.no.draft.public"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before activated) -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved (rejected) -->
			<!-- Do we need here some indication of why it was not approved?  I.e. disapproved vs. not acted on because submitted too late, etc. -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="activated">
			<!-- Activated and ready to be published -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- Do we need/want to differentiate here between retiring a course simply because it will no longer be taught and retiring a version of a course because it has been superceded by a newer version. -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.lu.type.activity.Lab">
		<!-- Student working on projects in a defined laboratory space.  Instructors are on-hand for students to ask questions and guidance. -->
			<dict:state key="template">
			<!-- A template holds configuration for defaults for creating a new course -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				
				<dict:field key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course activity contact hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="course.activity.contact.hours.per.draft.private"/>
										<dict:fieldRef bean="course.activity.contact.hours.no.draft.private"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				
				<dict:field key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course activity contact hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="course.activity.contact.hours.per.draft.public"/>
										<dict:fieldRef bean="course.activity.contact.hours.no.draft.public"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before activated) -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved (rejected) -->
			<!-- Do we need here some indication of why it was not approved?  I.e. disapproved vs. not acted on because submitted too late, etc. -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="activated">
			<!-- Activated and ready to be published -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- Do we need/want to differentiate here between retiring a course simply because it will no longer be taught and retiring a version of a course because it has been superceded by a newer version. -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.lu.type.activity.Directed">
		<!-- Provides students with a way to complete a  class or other area of focussed studies.  Directed study may be individualized method or in a group. -->
		<!-- Directed Honours, Directed Research, Directed Readings, Honours Essay, Honours Study Semester -->
			<dict:state key="template">
			<!-- A template holds configuration for defaults for creating a new course -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				
				<dict:field key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course activity contact hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="course.activity.contact.hours.per.draft.private"/>
										<dict:fieldRef bean="course.activity.contact.hours.no.draft.private"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				
				<dict:field key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course activity contact hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="course.activity.contact.hours.per.draft.public"/>
										<dict:fieldRef bean="course.activity.contact.hours.no.draft.public"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before activated) -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved (rejected) -->
			<!-- Do we need here some indication of why it was not approved?  I.e. disapproved vs. not acted on because submitted too late, etc. -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="activated">
			<!-- Activated and ready to be published -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- Do we need/want to differentiate here between retiring a course simply because it will no longer be taught and retiring a version of a course because it has been superceded by a newer version. -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.lu.type.activity.Lecture">
		<!-- Instructor presentation of course materials -->
		<!-- Classroom based -->
			<dict:state key="template">
			<!-- A template holds configuration for defaults for creating a new course -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				
				<dict:field key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course activity contact hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="course.activity.contact.hours.per.draft.private"/>
										<dict:fieldRef bean="course.activity.contact.hours.no.draft.private"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				
				<dict:field key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course activity contact hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="course.activity.contact.hours.per.draft.public"/>
										<dict:fieldRef bean="course.activity.contact.hours.no.draft.public"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before activated) -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved (rejected) -->
			<!-- Do we need here some indication of why it was not approved?  I.e. disapproved vs. not acted on because submitted too late, etc. -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="activated">
			<!-- Activated and ready to be published -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- Do we need/want to differentiate here between retiring a course simply because it will no longer be taught and retiring a version of a course because it has been superceded by a newer version. -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.lu.type.activity.Tutorial">
		<!-- Supplementary (or remedial) individualized instruction, Extra meetings for the review or elaboration of course materials -->
		<!-- Supplement, workshop, TA Help Session, Extra Lessons, Problem Session -->
			<dict:state key="template">
			<!-- A template holds configuration for defaults for creating a new course -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				
				<dict:field key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course activity contact hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="course.activity.contact.hours.per.draft.private"/>
										<dict:fieldRef bean="course.activity.contact.hours.no.draft.private"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				
				<dict:field key="intensity">
					<dict:fieldDescriptor>
						<dict:name>course activity contact hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="course.activity.contact.hours.per.draft.public"/>
										<dict:fieldRef bean="course.activity.contact.hours.no.draft.public"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before activated) -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved (rejected) -->
			<!-- Do we need here some indication of why it was not approved?  I.e. disapproved vs. not acted on because submitted too late, etc. -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="activated">
			<!-- Activated and ready to be published -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- Do we need/want to differentiate here between retiring a course simply because it will no longer be taught and retiring a version of a course because it has been superceded by a newer version. -->
				<dict:fieldRef bean="course.activity.official"/>
				<dict:fieldRef bean="course.activity.alternateIdentifiers"/>
				<dict:fieldRef bean="course.activity.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.activity.studySubjectArea"/>
				<dict:fieldRef bean="course.activity.desc"/>
				<dict:fieldRef bean="course.activity.marketingDesc"/>
				<dict:fieldRef bean="course.activity.campusLocationList"/>
				<dict:fieldRef bean="course.activity.accreditation"/>
				<dict:fieldRef bean="course.activity.primaryAdminOrg"/>
				<dict:fieldRef bean="course.activity.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.activity.primaryInstructor"/>
				<dict:fieldRef bean="course.activity.instructors"/>
				<dict:fieldRef bean="course.activity.expectedFirstAtp"/>
				<dict:fieldRef bean="course.activity.effectiveDate"/>
				<dict:fieldRef bean="course.activity.expirationDate"/>
				<dict:fieldRef bean="course.activity.contact.hours"/>
				<dict:fieldRef bean="course.activity.duration"/>
				<dict:fieldRef bean="course.activity.canCreateLui"/>
				<dict:fieldRef bean="course.activity.referenceURL"/>
				<dict:fieldRef bean="course.activity.luCodes"/>
				<dict:fieldRef bean="course.activity.publishingInfo"/>
				<dict:fieldRef bean="course.activity.nextReviewPeriod"/>
				<dict:fieldRef bean="course.activity.isEnrollable"/>
				<dict:fieldRef bean="course.activity.offeredAtpTypes"/>
				<dict:fieldRef bean="course.activity.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.activity.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.activity.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.activity.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.activity.feeInfo"/>
				<dict:fieldRef bean="course.activity.accountingInfo"/>
				<dict:fieldRef bean="course.activity.attributes"/>
				<dict:fieldRef bean="course.activity.metaInfo"/>
				<dict:fieldRef bean="course.activity.type"/>
				<dict:fieldRef bean="course.activity.state"/>
				<dict:fieldRef bean="course.activity.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.lu.type.Program">
		<!-- A non-specific program used for grouping -->
			<dict:state key="template">
			<!-- A template holds configuration for defaults for creating a new course -->
				
				<dict:field id="program.official" key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>program no</dict:name>
						<dict:desc>program no</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										
										<dict:field id="program.official.no" key="code">
											<dict:fieldDescriptor>
												<dict:name>program official no</dict:name>
												<dict:desc>course number</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="calc.program.no"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.official.transcriptTitle" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>program official transcriptTitle</dict:name>
												<dict:desc>transcript title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="required"/>
													<dict:constraint key="in-line.constraint.for.dictionary.program.official.transcriptTitle">
														<dict:maxLength>20</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.official.catalogTitle" key="longName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>program official catalogTitle</dict:name>
												<dict:desc>catalog title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="required"/>
													<dict:constraint key="in-line.constraint.for.dictionary.program.official.catalogTitle">
														<dict:maxLength>60</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.official.level" key="level">
											<dict:fieldDescriptor>
												<dict:name>program official level</dict:name>
												<dict:desc>level</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.official.subjectArea" key="division">
											<dict:fieldDescriptor>
												<dict:name>program official subjectArea</dict:name>
												<dict:desc>subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.official.version" key="variation">
											<dict:fieldDescriptor>
												<dict:name>program official version</dict:name>
												<dict:desc>version code</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.official.adminOrg" key="orgId">
											<dict:fieldDescriptor>
												<dict:name>program official adminOrg</dict:name>
												<dict:desc>dept</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.orgId"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.official.type" key="type">
											<!-- Required when first adding but read-only thereafter -->
											<dict:fieldDescriptor>
												<dict:name>program official type</dict:name>
												<dict:desc>official</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="lu.identifier.types"/>
													<dict:constraintRef bean="hard.coded.official"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.official.state" key="state">
											<dict:fieldDescriptor>
												<dict:name>program official state</dict:name>
												<dict:desc>state</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.state"/>
													<dict:constraintRef bean="lu.identifier.states"/>
													<dict:constraintRef bean="hard.coded.active"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.official.internal.id" key="id">
											<!-- should be blank when first adding but required thereafter for updates -->
											<dict:fieldDescriptor>
												<dict:name>program official internalId</dict:name>
												<dict:desc>internal id of this id</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.id"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="program.official.no"/>
										<dict:fieldRef bean="program.official.transcriptTitle"/>
										<dict:fieldRef bean="program.official.catalogTitle"/>
										<dict:fieldRef bean="program.official.level"/>
										<dict:fieldRef bean="program.official.subjectArea"/>
										<dict:fieldRef bean="program.official.version"/>
										<dict:fieldRef bean="program.official.adminOrg"/>
										<dict:fieldRef bean="program.official.type"/>
										<dict:fieldRef bean="program.official.state"/>
										<dict:fieldRef bean="program.official.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.alternateIdentifiers" key="alternateIdentifiers">
					<dict:fieldDescriptor>
						<dict:name>program alternateIdentifiers</dict:name>
						<dict:desc>program alternate ids</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!-- This identifier holds the version information for courses that have multiple versions -->
								<!-- Variation -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										
										<dict:field id="program.version.no" key="code">
											<!-- calculated by concatenating the subject Area, numberPart and version code. -->
											<dict:fieldDescriptor>
												<dict:name>program version no</dict:name>
												<dict:desc>version number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="calc.course.no"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.version.transcriptTitle" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>program version transcriptTitle</dict:name>
												<dict:desc>Version Title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="required"/>
													<dict:constraint key="in-line.constraint.for.dictionary.program.version.transcriptTitle">
														<dict:maxLength>20</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.version.catalogTitle" key="longName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>program version catalogTitle</dict:name>
												<dict:desc>not used</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.version.level" key="level">
											<dict:fieldDescriptor>
												<dict:name>program version level</dict:name>
												<dict:desc>not used</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.version.subjectArea" key="division">
											<!-- set to the official number's subjectArea -->
											<dict:fieldDescriptor>
												<dict:name>program version subjectArea</dict:name>
												<dict:desc>subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="calc.copy.course.official.subjectArea"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.version.numberPart" key="suffixCode">
											<!-- set to the official number's numberPart -->
											<dict:fieldDescriptor>
												<dict:name>program version numberPart</dict:name>
												<dict:desc>number part of program number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="calc.copy.course.official.numberPart"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.version.version" key="variation">
											<dict:fieldDescriptor>
												<dict:name>program version version</dict:name>
												<dict:desc>version code</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="code.uppercase"/>
													<dict:constraintRef bean="letter"/>
													<dict:constraintRef bean="size.one"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.version.adminOrg" key="orgId">
											<dict:fieldDescriptor>
												<dict:name>program version adminOrg</dict:name>
												<dict:desc>not used</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.orgId"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.version.type" key="type">
											<!-- Required when first adding but read-only thereafter -->
											<dict:fieldDescriptor>
												<dict:name>program version type</dict:name>
												<dict:desc>version</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="lu.identifier.types"/>
													<dict:constraintRef bean="hard.coded.version"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.version.state" key="state">
											<dict:fieldDescriptor>
												<dict:name>program version state</dict:name>
												<dict:desc>state</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.state"/>
													<dict:constraintRef bean="lu.identifier.states"/>
													<dict:constraintRef bean="hard.coded.active"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.version.internal.id" key="id">
											<!-- should be blank when first adding but required thereafter for updates -->
											<dict:fieldDescriptor>
												<dict:name>program version internalId</dict:name>
												<dict:desc>internal id of this program version</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.id"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="program.version.no"/>
										<dict:fieldRef bean="program.version.transcriptTitle"/>
										<dict:fieldRef bean="program.version.catalogTitle"/>
										<dict:fieldRef bean="program.version.level"/>
										<dict:fieldRef bean="program.version.subjectArea"/>
										<dict:fieldRef bean="program.version.numberPart"/>
										<dict:fieldRef bean="program.version.version"/>
										<dict:fieldRef bean="program.version.adminOrg"/>
										<dict:fieldRef bean="program.version.type"/>
										<dict:fieldRef bean="program.version.state"/>
										<dict:fieldRef bean="program.version.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.academicSubjectOrgs" key="academicSubjectOrgs">
					<dict:fieldDescriptor>
						<dict:name>program academicSubjectOrgs</dict:name>
						<dict:desc>program ademicSubjectOrgs</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.studySubjectArea" key="studySubjectArea">
					<dict:fieldDescriptor>
						<dict:name>program studySubjectArea</dict:name>
						<dict:desc>program studySubjectArea</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="code"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.desc.template" key="desc">
					<dict:fieldDescriptor>
						<dict:name>program desc</dict:name>
						<dict:desc>dscription</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="program.desc.plain" key="plain">
											<!-- calculated by stripping out formatting -->
											<dict:fieldDescriptor>
												<dict:name>program desc plain</dict:name>
												<dict:desc>plain text version description of program</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.program.desc.plain">
														<dict:maxLength>14000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>program desc formatted</dict:name>
												<dict:desc>rich text version of the program description</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.program.desc.formatted">
														<dict:maxLength>14000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.rationale" key="marketingDesc">
					<!-- Rationale is stored in the Marketing Description for now -->
					<dict:fieldDescriptor>
						<dict:name>program rationale</dict:name>
						<dict:desc>rationale</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="program.rationale.plain" key="plain">
											<!-- calculated by stripping out formatting -->
											<dict:fieldDescriptor>
												<dict:name>program rationale plain</dict:name>
												<dict:desc>plain text version of rationale</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.program.rationale.plain">
														<dict:maxLength>14000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.rationale.formatted" key="formatted">
											<!-- the rationale is stored in the marketing description for now -->
											<dict:fieldDescriptor>
												<dict:name>program rationale formatted</dict:name>
												<dict:desc>rich text version of rationale</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.program.rationale.formatted">
														<dict:maxLength>14000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.campusLocation" key="campusLocationList">
					<dict:fieldDescriptor>
						<dict:name>program campusLocation</dict:name>
						<dict:desc>campus location</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="code"/>
							<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.accreditation" key="accreditation">
					<dict:fieldDescriptor>
						<dict:name>program accreditation</dict:name>
						<dict:desc>program accreditation</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.primaryAdminOrg" key="primaryAdminOrg">
					<dict:fieldDescriptor>
						<dict:name>program primaryAdminOrg</dict:name>
						<dict:desc>department</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.AdminOrgInfo">
								<!-- Information about an organization acting in administrative capacity for a learning unit. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="program.primaryAdminOrg.Id" key="orgId">
											<dict:fieldDescriptor>
												<dict:name>program primaryAdminOrg Id</dict:name>
												<dict:desc>Org Id of the primary administrative department</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.orgId"/>
											</dict:constraintDescriptor>
											<dict:selector>true</dict:selector>
										</dict:field>
										
										<dict:field id="program.primaryAdminOrg.attributes" key="attributes">
											<dict:fieldDescriptor>
												<dict:name>program primaryAdminOrg attributes</dict:name>
												<dict:desc>dynamic attributes qualifying the primary admin org</dict:desc>
												<dict:dataType>complex</dict:dataType>
													
													<dict:objectStructure key=".AttributeInfo">
														<!-- List of key/value pairs, typically used for dynamic attributes. -->
														<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed">
														<!-- Captures if the students are expected to be left handed who take this course -->
															<dict:state key="(n/a)">
															<!-- Not applicable -->
																
																<dict:field id="program.primaryAdminOrg.attributes.left.handed.key" key="key">
																	<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
																	<dict:fieldDescriptor>
																		<dict:name>program primaryAdminOrg attributes left handed key</dict:name>
																		<dict:desc>Key to capture if the students are expected to be left handed who take this program</dict:desc>
																		<dict:dataType>string</dict:dataType>
																		<dict:readOnly>true</dict:readOnly>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="kuali.type"/>
																			<dict:constraintRef bean="dynamic.field.types"/>
																			<dict:constraintRef bean="hard.coded.left.handed"/>
																			<dict:constraintRef bean="read.only"/>
																	</dict:constraintDescriptor>
																	<dict:dynamic>true</dict:dynamic>
																</dict:field>
																
																<dict:field id="program.primaryAdminOrg.attributes.left.handed.value" key="value">
																	<dict:fieldDescriptor>
																		<dict:name>program primaryAdminOrg attributes left handed value</dict:name>
																		<dict:desc>Value of the students are expected to be left handed who take this program</dict:desc>
																		<dict:dataType>string</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="boolean"/>
																			<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
																				<dict:maxLength>(unbounded)</dict:maxLength>
																				</dict:constraint>
																	</dict:constraintDescriptor>
																	<dict:dynamic>true</dict:dynamic>
																</dict:field>
															</dict:state>
														</dict:type>
													</dict:objectStructure>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="repeating"/>
													<dict:constraintRef bean="single"/>
													<dict:constraint key="in-line.constraint.for.dictionary.program.primaryAdminOrg.attributes">
														<dict:maxOccurs>20</dict:maxOccurs>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="default.to.proposal.proposerOrg"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.alternateAdminOrgs" key="alternateAdminOrgs">
					<dict:fieldDescriptor>
						<dict:name>program alternateAdminOrgs</dict:name>
						<dict:desc>not used</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.primaryInstructor" key="primaryInstructor">
					<dict:fieldDescriptor>
						<dict:name>program primaryInstructor</dict:name>
						<dict:desc>program primaryInstructor</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.instructors" key="instructors">
					<dict:fieldDescriptor>
						<dict:name>program instructors</dict:name>
						<dict:desc>program instructors</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.expectedFirstAtp" key="expectedFirstAtp">
					<dict:fieldDescriptor>
						<dict:name>program expectedFirstAtp</dict:name>
						<dict:desc>program expectedFirstAtp</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="atp.types"/>
							<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>program effectiveDate</dict:name>
						<dict:desc>first date program is open</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
							<dict:constraintRef bean="default.today"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>program effectiveDate</dict:name>
						<dict:desc>last date program is open</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.duration" key="stdDuration">
					<dict:fieldDescriptor>
						<dict:name>program duration</dict:name>
						<dict:desc>duration</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="program.duration.units" key="atpDurationTypeKey">
											<!-- services has this flagged as mandatory but don't think it shoujld be because in a draft state a user may specify the units but not yet specify the amount -->
											<dict:fieldDescriptor>
												<dict:name>program duration units</dict:name>
												<dict:desc>Units in which the duration of the course is expressed</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="duration.types"/>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="valid.duration.types"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.duration.no" key="timeQuantity">
											<!-- services has this flagged as mandatory but don't think it shoujld be because in a draft state a user may specify the amount but not yet specify the units because they are unsure but we still need to save -->
											<!-- How do we add a min and max VALUE limit (not min and max size and occurrence) -->
											<dict:fieldDescriptor>
												<dict:name>program duration no</dict:name>
												<dict:desc>number of the duration units</dict:desc>
												<dict:dataType>integer</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="integer"/>
													<dict:constraintRef bean="hard.coded.one"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.canCreateLui" key="canCreateLui">
					<dict:fieldDescriptor>
						<dict:name>program canCreateLui</dict:name>
						<dict:desc>program canCreateLui</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.referenceURL" key="referenceURL">
					<dict:fieldDescriptor>
						<dict:name>program referenceURL</dict:name>
						<dict:desc>program referenceURL</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="url"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.luCodes" key="luCodes">
					<dict:fieldDescriptor>
						<dict:name>program luCodes</dict:name>
						<dict:desc>program luCodes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.publishingInfo" key="publishingInfo">
					<dict:fieldDescriptor>
						<dict:name>program publishingInfo</dict:name>
						<dict:desc>program publishingInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.nextReviewPeriod" key="nextReviewPeriod">
					<dict:fieldDescriptor>
						<dict:name>program nextReviewPeriod</dict:name>
						<dict:desc>program nextReviewPeriod</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="atp.types"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.isEnrollable" key="isEnrollable">
					<!-- defaults to TRUE -->
					<dict:fieldDescriptor>
						<dict:name>program isEnrollable</dict:name>
						<dict:desc>program isEnrollable</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="default.true"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.seasons" key="offeredAtpTypes">
					<!-- Services has this as an atpKeyList but that is just a list of Strings so I didn't create the sub-structure -->
					<dict:fieldDescriptor>
						<dict:name>program seasons</dict:name>
						<dict:desc>seasons offered</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="atp.types"/>
							<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.hasEarlyDropDeadline" key="hasEarlyDropDeadline">
					<dict:fieldDescriptor>
						<dict:name>program hasEarlyDropDeadline</dict:name>
						<dict:desc>program hasEarlyDropDeadline</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.defaultEnrollmentEstimate" key="defaultEnrollmentEstimate">
					<dict:fieldDescriptor>
						<dict:name>program defaultEnrollmentEstimate</dict:name>
						<dict:desc>program defaultEnrollmentEstimate</dict:desc>
						<dict:dataType>integer</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="non-negative.integer"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.defaultMaximumEnrollment" key="defaultMaximumEnrollment">
					<dict:fieldDescriptor>
						<dict:name>program defaultMaximumEnrollment</dict:name>
						<dict:desc>program defaultMaximumEnrollment</dict:desc>
						<dict:dataType>integer</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="non-negative.integer"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.isHazardousForDisabledStudents" key="isHazardousForDisabledStudents">
					<dict:fieldDescriptor>
						<dict:name>program isHazardousForDisabledStudents</dict:name>
						<dict:desc>program isHazardousForDisabledStudents</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.feeInfo" key="feeInfo">
					<dict:fieldDescriptor>
						<dict:name>program feeInfo</dict:name>
						<dict:desc>program feeInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.accountingInfo" key="accountingInfo">
					<dict:fieldDescriptor>
						<dict:name>program accountingInfo</dict:name>
						<dict:desc>program accountingInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.dynamic.attributes" key="attributes">
					<!-- Services has this as an attributeInfoList but that is just a list of the attributeInfo substructure so I did't create the intermediary list sub-structure -->
					<dict:fieldDescriptor>
						<dict:name>program dynamic attributes</dict:name>
						<dict:desc>Eye color and Left Handed</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key=".AttributeInfo">
								<!-- List of key/value pairs, typically used for dynamic attributes. -->
								<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color">
								<!-- Captures the eye color of students expected to take this course -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="program.attributes.eye.color.key" key="key">
											<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
											<dict:fieldDescriptor>
												<dict:name>program attributes eye color key</dict:name>
												<dict:desc>Key to capture the eye color of students expected to take this program</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="dynamic.field.types"/>
													<dict:constraintRef bean="hard.coded.eye.color"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
											<dict:dynamic>true</dict:dynamic>
										</dict:field>
										
										<dict:field id="program.attributes.eye.color.value" key="value">
											<dict:fieldDescriptor>
												<dict:name>program attributes eye color value</dict:name>
												<dict:desc>Value of the eye color of students expected to take this program</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="eye.colors"/>
													<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
											<dict:dynamic>true</dict:dynamic>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.meta" key="metaInfo">
					<!-- must be empty on create but required on update -->
					<dict:fieldDescriptor>
						<dict:name>program meta</dict:name>
						<dict:desc>audit trail info</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="program.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>program meta versionInd</dict:name>
												<dict:desc>Version number for this program info</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>program meta createTime</dict:name>
												<dict:desc>Date-time this program was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>program meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this program</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>program meta updateTime</dict:name>
												<dict:desc>Date-time this program was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>program meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this program</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.type" key="type">
					<!-- Requierd on the create but read-only after that -->
					<dict:fieldDescriptor>
						<dict:name>program type</dict:name>
						<dict:desc>type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="lu.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>program state</dict:name>
						<dict:desc>state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
							<dict:constraintRef bean="lu.states"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="program.internal.id" key="id">
					<!-- must be empty on create but required on update -->
					<dict:fieldDescriptor>
						<dict:name>program internalId</dict:name>
						<dict:desc>internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				
				<dict:field key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>program no</dict:name>
						<dict:desc>program no</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="program.official.no"/>
										
										<dict:field id="program.official.transcriptTitle.draft.private" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>program official transcriptTitle</dict:name>
												<dict:desc>transcript title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraint key="in-line.constraint.for.dictionary.program.official.transcriptTitle.draft.private">
														<dict:maxLength>250</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.official.catalogTitle.draft.private" key="longName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>program official catalogTitle</dict:name>
												<dict:desc>catalog title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="required"/>
													<dict:constraint key="in-line.constraint.for.dictionary.program.official.catalogTitle.draft.private">
														<dict:maxLength>250</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="program.official.level"/>
										
										<dict:field id="program.official.subjectArea.draft.private" key="division">
											<dict:fieldDescriptor>
												<dict:name>program official subjectArea</dict:name>
												<dict:desc>subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="program.official.version"/>
										<dict:fieldRef bean="program.official.adminOrg"/>
										<dict:fieldRef bean="program.official.type"/>
										<dict:fieldRef bean="program.official.state"/>
										<dict:fieldRef bean="program.official.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="program.official.no"/>
										<dict:fieldRef bean="program.official.transcriptTitle.draft.private"/>
										<dict:fieldRef bean="program.official.catalogTitle.draft.private"/>
										<dict:fieldRef bean="program.official.level"/>
										<dict:fieldRef bean="program.official.subjectArea.draft.private"/>
										<dict:fieldRef bean="program.official.version"/>
										<dict:fieldRef bean="program.official.adminOrg"/>
										<dict:fieldRef bean="program.official.type"/>
										<dict:fieldRef bean="program.official.state"/>
										<dict:fieldRef bean="program.official.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field key="alternateIdentifiers">
					<dict:fieldDescriptor>
						<dict:name>program alternateIdentifiers</dict:name>
						<dict:desc>program alternate ids</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!-- This identifier holds the version information for courses that have multiple versions -->
								<!-- Variation -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="program.version.no"/>
										
										<dict:field id="program.version.transcriptTitle.draft.private" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>program version transcriptTitle</dict:name>
												<dict:desc>Version Title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraint key="in-line.constraint.for.dictionary.program.version.transcriptTitle.draft.private">
														<dict:maxLength>250</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="program.version.catalogTitle"/>
										<dict:fieldRef bean="program.version.level"/>
										<dict:fieldRef bean="program.version.subjectArea"/>
										<dict:fieldRef bean="program.version.numberPart"/>
										
										<dict:field id="program.version.version.draft.private" key="variation">
											<dict:fieldDescriptor>
												<dict:name>program version version</dict:name>
												<dict:desc>version code</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="code.uppercase"/>
													<dict:constraintRef bean="letter"/>
													<dict:constraintRef bean="size.one"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="program.version.adminOrg"/>
										<dict:fieldRef bean="program.version.type"/>
										<dict:fieldRef bean="program.version.state"/>
										<dict:fieldRef bean="program.version.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="program.version.no"/>
										<dict:fieldRef bean="program.version.transcriptTitle.draft.private"/>
										<dict:fieldRef bean="program.version.catalogTitle"/>
										<dict:fieldRef bean="program.version.level"/>
										<dict:fieldRef bean="program.version.subjectArea"/>
										<dict:fieldRef bean="program.version.numberPart"/>
										<dict:fieldRef bean="program.version.version.draft.private"/>
										<dict:fieldRef bean="program.version.adminOrg"/>
										<dict:fieldRef bean="program.version.type"/>
										<dict:fieldRef bean="program.version.state"/>
										<dict:fieldRef bean="program.version.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="program.academicSubjectOrgs"/>
				<dict:fieldRef bean="program.studySubjectArea"/>
				
				<dict:field id="program.desc.draft.private" key="desc">
					<dict:fieldDescriptor>
						<dict:name>program desc</dict:name>
						<dict:desc>dscription</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="program.desc.plain.draft.private" key="plain">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>program desc plain</dict:name>
												<dict:desc>plain text version description of program</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.program.desc.plain.draft.private">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.desc.formatted.draft.private" key="formatted">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>program desc formatted</dict:name>
												<dict:desc>rich text version of the program description</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.program.desc.formatted.draft.private">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.rationale.draft.private" key="marketingDesc">
					<!-- Rationale is stored in the Marketing Description for now -->
					<dict:fieldDescriptor>
						<dict:name>program rationale</dict:name>
						<dict:desc>rationale</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="program.rationale.plain.draft.private" key="plain">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>program rationale plain</dict:name>
												<dict:desc>plain text version of rationale</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.program.rationale.plain.draft.private">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.rationale.formatted.draft.private" key="formatted">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>program rationale formatted</dict:name>
												<dict:desc>rich text version of rationale</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.program.rationale.formatted.draft.private">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.campusLocation.draft.private" key="campusLocationList">
					<dict:fieldDescriptor>
						<dict:name>program campusLocation</dict:name>
						<dict:desc>campus location</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="code"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="program.accreditation"/>
				<dict:fieldRef bean="program.primaryAdminOrg"/>
				<dict:fieldRef bean="program.alternateAdminOrgs"/>
				<dict:fieldRef bean="program.primaryInstructor"/>
				<dict:fieldRef bean="program.instructors"/>
				
				<dict:field id="program.expectedFirstAtp.draft.private" key="expectedFirstAtp">
					<dict:fieldDescriptor>
						<dict:name>program expectedFirstAtp</dict:name>
						<dict:desc>program expectedFirstAtp</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="atp.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="program.effectiveDate"/>
				<dict:fieldRef bean="program.expirationDate"/>
				
				<dict:field id="program.duration.draft.private" key="stdDuration">
					<dict:fieldDescriptor>
						<dict:name>program duration</dict:name>
						<dict:desc>duration</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="program.duration.units.draft.private" key="atpDurationTypeKey">
											<!-- services has this flagged as mandatory but don't think it shoujld be because in a draft state a user may specify the units but not yet specify the amount -->
											<dict:fieldDescriptor>
												<dict:name>program duration units</dict:name>
												<dict:desc>Units in which the duration of the course is expressed</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="duration.types"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="valid.duration.types"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="program.duration.no"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="program.canCreateLui"/>
				<dict:fieldRef bean="program.referenceURL"/>
				<dict:fieldRef bean="program.luCodes"/>
				<dict:fieldRef bean="program.publishingInfo"/>
				<dict:fieldRef bean="program.nextReviewPeriod"/>
				<dict:fieldRef bean="program.isEnrollable"/>
				
				<dict:field id="program.seasons.draft.private" key="offeredAtpTypes">
					<!-- Services has this as an atpKeyList but that is just a list of Strings so I didn't create the sub-structure -->
					<dict:fieldDescriptor>
						<dict:name>program seasons</dict:name>
						<dict:desc>seasons offered</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="atp.types"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="program.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="program.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="program.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="program.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="program.feeInfo"/>
				<dict:fieldRef bean="program.accountingInfo"/>
				<dict:fieldRef bean="program.dynamic.attributes"/>
				<dict:fieldRef bean="program.meta"/>
				<dict:fieldRef bean="program.type"/>
				<dict:fieldRef bean="program.state"/>
				<dict:fieldRef bean="program.internal.id"/>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				
				<dict:field key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>program no</dict:name>
						<dict:desc>program no</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="program.official.no"/>
										
										<dict:field id="program.official.transcriptTitle.draft.public" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>program official transcriptTitle</dict:name>
												<dict:desc>transcript title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraint key="in-line.constraint.for.dictionary.program.official.transcriptTitle.draft.public">
														<dict:maxLength>250</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.official.catalogTitle.draft.public" key="longName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>program official catalogTitle</dict:name>
												<dict:desc>catalog title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="required"/>
													<dict:constraint key="in-line.constraint.for.dictionary.program.official.catalogTitle.draft.public">
														<dict:maxLength>250</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="program.official.level"/>
										
										<dict:field id="program.official.subjectArea.draft.public" key="division">
											<dict:fieldDescriptor>
												<dict:name>program official subjectArea</dict:name>
												<dict:desc>subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="program.official.version"/>
										<dict:fieldRef bean="program.official.adminOrg"/>
										<dict:fieldRef bean="program.official.type"/>
										<dict:fieldRef bean="program.official.state"/>
										<dict:fieldRef bean="program.official.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="program.official.no"/>
										<dict:fieldRef bean="program.official.transcriptTitle.draft.public"/>
										<dict:fieldRef bean="program.official.catalogTitle.draft.public"/>
										<dict:fieldRef bean="program.official.level"/>
										<dict:fieldRef bean="program.official.subjectArea.draft.public"/>
										<dict:fieldRef bean="program.official.version"/>
										<dict:fieldRef bean="program.official.adminOrg"/>
										<dict:fieldRef bean="program.official.type"/>
										<dict:fieldRef bean="program.official.state"/>
										<dict:fieldRef bean="program.official.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field key="alternateIdentifiers">
					<dict:fieldDescriptor>
						<dict:name>program alternateIdentifiers</dict:name>
						<dict:desc>program alternate ids</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!-- This identifier holds the version information for courses that have multiple versions -->
								<!-- Variation -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="program.version.no"/>
										
										<dict:field id="program.version.transcriptTitle.draft.public" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>program version transcriptTitle</dict:name>
												<dict:desc>Version Title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraint key="in-line.constraint.for.dictionary.program.version.transcriptTitle.draft.public">
														<dict:maxLength>250</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="program.version.catalogTitle"/>
										<dict:fieldRef bean="program.version.level"/>
										<dict:fieldRef bean="program.version.subjectArea"/>
										<dict:fieldRef bean="program.version.numberPart"/>
										
										<dict:field id="program.version.version.draft.public" key="variation">
											<dict:fieldDescriptor>
												<dict:name>program version version</dict:name>
												<dict:desc>version code</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="code.uppercase"/>
													<dict:constraintRef bean="letter"/>
													<dict:constraintRef bean="size.one"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="program.version.adminOrg"/>
										<dict:fieldRef bean="program.version.type"/>
										<dict:fieldRef bean="program.version.state"/>
										<dict:fieldRef bean="program.version.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="program.version.no"/>
										<dict:fieldRef bean="program.version.transcriptTitle.draft.public"/>
										<dict:fieldRef bean="program.version.catalogTitle"/>
										<dict:fieldRef bean="program.version.level"/>
										<dict:fieldRef bean="program.version.subjectArea"/>
										<dict:fieldRef bean="program.version.numberPart"/>
										<dict:fieldRef bean="program.version.version.draft.public"/>
										<dict:fieldRef bean="program.version.adminOrg"/>
										<dict:fieldRef bean="program.version.type"/>
										<dict:fieldRef bean="program.version.state"/>
										<dict:fieldRef bean="program.version.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="program.academicSubjectOrgs"/>
				<dict:fieldRef bean="program.studySubjectArea"/>
				
				<dict:field id="program.desc.draft.public" key="desc">
					<dict:fieldDescriptor>
						<dict:name>program desc</dict:name>
						<dict:desc>dscription</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="program.desc.plain.draft.public" key="plain">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>program desc plain</dict:name>
												<dict:desc>plain text version description of program</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.program.desc.plain.draft.public">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.desc.formatted.draft.public" key="formatted">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>program desc formatted</dict:name>
												<dict:desc>rich text version of the program description</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.program.desc.formatted.draft.public">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.rationale.draft.public" key="marketingDesc">
					<!-- Rationale is stored in the Marketing Description for now -->
					<dict:fieldDescriptor>
						<dict:name>program rationale</dict:name>
						<dict:desc>rationale</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="program.rationale.plain.draft.public" key="plain">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>program rationale plain</dict:name>
												<dict:desc>plain text version of rationale</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.program.rationale.plain.draft.public">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="program.rationale.formatted.draft.public" key="formatted">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>program rationale formatted</dict:name>
												<dict:desc>rich text version of rationale</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.program.rationale.formatted.draft.public">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="program.campusLocation.draft.public" key="campusLocationList">
					<dict:fieldDescriptor>
						<dict:name>program campusLocation</dict:name>
						<dict:desc>campus location</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="code"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="program.accreditation"/>
				<dict:fieldRef bean="program.primaryAdminOrg"/>
				<dict:fieldRef bean="program.alternateAdminOrgs"/>
				<dict:fieldRef bean="program.primaryInstructor"/>
				<dict:fieldRef bean="program.instructors"/>
				
				<dict:field id="program.expectedFirstAtp.draft.public" key="expectedFirstAtp">
					<dict:fieldDescriptor>
						<dict:name>program expectedFirstAtp</dict:name>
						<dict:desc>program expectedFirstAtp</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="atp.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="program.effectiveDate"/>
				<dict:fieldRef bean="program.expirationDate"/>
				
				<dict:field id="program.duration.draft.public" key="stdDuration">
					<dict:fieldDescriptor>
						<dict:name>program duration</dict:name>
						<dict:desc>duration</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.TimeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="program.duration.units.draft.public" key="atpDurationTypeKey">
											<!-- services has this flagged as mandatory but don't think it shoujld be because in a draft state a user may specify the units but not yet specify the amount -->
											<dict:fieldDescriptor>
												<dict:name>program duration units</dict:name>
												<dict:desc>Units in which the duration of the course is expressed</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="duration.types"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="valid.duration.types"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="program.duration.no"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="program.canCreateLui"/>
				<dict:fieldRef bean="program.referenceURL"/>
				<dict:fieldRef bean="program.luCodes"/>
				<dict:fieldRef bean="program.publishingInfo"/>
				<dict:fieldRef bean="program.nextReviewPeriod"/>
				<dict:fieldRef bean="program.isEnrollable"/>
				
				<dict:field id="program.seasons.draft.public" key="offeredAtpTypes">
					<!-- Services has this as an atpKeyList but that is just a list of Strings so I didn't create the sub-structure -->
					<dict:fieldDescriptor>
						<dict:name>program seasons</dict:name>
						<dict:desc>seasons offered</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="atp.types"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="program.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="program.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="program.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="program.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="program.feeInfo"/>
				<dict:fieldRef bean="program.accountingInfo"/>
				<dict:fieldRef bean="program.dynamic.attributes"/>
				<dict:fieldRef bean="program.meta"/>
				<dict:fieldRef bean="program.type"/>
				<dict:fieldRef bean="program.state"/>
				<dict:fieldRef bean="program.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
				
				<dict:field key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>program no</dict:name>
						<dict:desc>program no</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="program.official.no"/>
										<dict:fieldRef bean="program.official.transcriptTitle"/>
										<dict:fieldRef bean="program.official.catalogTitle"/>
										<dict:fieldRef bean="program.official.level"/>
										
										<dict:field id="program.official.subjectArea.submitted" key="division">
											<dict:fieldDescriptor>
												<dict:name>program official subjectArea</dict:name>
												<dict:desc>subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="program.official.version"/>
										<dict:fieldRef bean="program.official.adminOrg"/>
										<dict:fieldRef bean="program.official.type"/>
										<dict:fieldRef bean="program.official.state"/>
										<dict:fieldRef bean="program.official.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="program.official.no"/>
										<dict:fieldRef bean="program.official.transcriptTitle"/>
										<dict:fieldRef bean="program.official.catalogTitle"/>
										<dict:fieldRef bean="program.official.level"/>
										<dict:fieldRef bean="program.official.subjectArea.submitted"/>
										<dict:fieldRef bean="program.official.version"/>
										<dict:fieldRef bean="program.official.adminOrg"/>
										<dict:fieldRef bean="program.official.type"/>
										<dict:fieldRef bean="program.official.state"/>
										<dict:fieldRef bean="program.official.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="program.alternateIdentifiers"/>
				<dict:fieldRef bean="program.academicSubjectOrgs"/>
				<dict:fieldRef bean="program.studySubjectArea"/>
				
				<dict:field id="program.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>program desc</dict:name>
						<dict:desc>dscription</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="program.desc.plain"/>
										<dict:fieldRef bean="program.desc.formatted"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="program.rationale"/>
				<dict:fieldRef bean="program.campusLocation"/>
				<dict:fieldRef bean="program.accreditation"/>
				<dict:fieldRef bean="program.primaryAdminOrg"/>
				<dict:fieldRef bean="program.alternateAdminOrgs"/>
				<dict:fieldRef bean="program.primaryInstructor"/>
				<dict:fieldRef bean="program.instructors"/>
				<dict:fieldRef bean="program.expectedFirstAtp"/>
				<dict:fieldRef bean="program.effectiveDate"/>
				<dict:fieldRef bean="program.expirationDate"/>
				<dict:fieldRef bean="program.duration"/>
				<dict:fieldRef bean="program.canCreateLui"/>
				<dict:fieldRef bean="program.referenceURL"/>
				<dict:fieldRef bean="program.luCodes"/>
				<dict:fieldRef bean="program.publishingInfo"/>
				<dict:fieldRef bean="program.nextReviewPeriod"/>
				<dict:fieldRef bean="program.isEnrollable"/>
				<dict:fieldRef bean="program.seasons"/>
				<dict:fieldRef bean="program.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="program.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="program.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="program.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="program.feeInfo"/>
				<dict:fieldRef bean="program.accountingInfo"/>
				<dict:fieldRef bean="program.dynamic.attributes"/>
				<dict:fieldRef bean="program.meta"/>
				<dict:fieldRef bean="program.type"/>
				<dict:fieldRef bean="program.state"/>
				<dict:fieldRef bean="program.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before activated) -->
				
				<dict:field key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>program no</dict:name>
						<dict:desc>program no</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="program.official.no"/>
										<dict:fieldRef bean="program.official.transcriptTitle"/>
										<dict:fieldRef bean="program.official.catalogTitle"/>
										<dict:fieldRef bean="program.official.level"/>
										
										<dict:field id="program.official.subjectArea.withdrawn" key="division">
											<dict:fieldDescriptor>
												<dict:name>program official subjectArea</dict:name>
												<dict:desc>subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="program.official.version"/>
										<dict:fieldRef bean="program.official.adminOrg"/>
										<dict:fieldRef bean="program.official.type"/>
										<dict:fieldRef bean="program.official.state"/>
										<dict:fieldRef bean="program.official.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="program.official.no"/>
										<dict:fieldRef bean="program.official.transcriptTitle"/>
										<dict:fieldRef bean="program.official.catalogTitle"/>
										<dict:fieldRef bean="program.official.level"/>
										<dict:fieldRef bean="program.official.subjectArea.withdrawn"/>
										<dict:fieldRef bean="program.official.version"/>
										<dict:fieldRef bean="program.official.adminOrg"/>
										<dict:fieldRef bean="program.official.type"/>
										<dict:fieldRef bean="program.official.state"/>
										<dict:fieldRef bean="program.official.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="program.alternateIdentifiers"/>
				<dict:fieldRef bean="program.academicSubjectOrgs"/>
				<dict:fieldRef bean="program.studySubjectArea"/>
				<dict:fieldRef bean="program.desc"/>
				<dict:fieldRef bean="program.rationale"/>
				<dict:fieldRef bean="program.campusLocation"/>
				<dict:fieldRef bean="program.accreditation"/>
				<dict:fieldRef bean="program.primaryAdminOrg"/>
				<dict:fieldRef bean="program.alternateAdminOrgs"/>
				<dict:fieldRef bean="program.primaryInstructor"/>
				<dict:fieldRef bean="program.instructors"/>
				<dict:fieldRef bean="program.expectedFirstAtp"/>
				<dict:fieldRef bean="program.effectiveDate"/>
				<dict:fieldRef bean="program.expirationDate"/>
				<dict:fieldRef bean="program.duration"/>
				<dict:fieldRef bean="program.canCreateLui"/>
				<dict:fieldRef bean="program.referenceURL"/>
				<dict:fieldRef bean="program.luCodes"/>
				<dict:fieldRef bean="program.publishingInfo"/>
				<dict:fieldRef bean="program.nextReviewPeriod"/>
				<dict:fieldRef bean="program.isEnrollable"/>
				<dict:fieldRef bean="program.seasons"/>
				<dict:fieldRef bean="program.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="program.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="program.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="program.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="program.feeInfo"/>
				<dict:fieldRef bean="program.accountingInfo"/>
				<dict:fieldRef bean="program.dynamic.attributes"/>
				<dict:fieldRef bean="program.meta"/>
				<dict:fieldRef bean="program.type"/>
				<dict:fieldRef bean="program.state"/>
				<dict:fieldRef bean="program.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="program.official"/>
				<dict:fieldRef bean="program.alternateIdentifiers"/>
				<dict:fieldRef bean="program.academicSubjectOrgs"/>
				<dict:fieldRef bean="program.studySubjectArea"/>
				<dict:fieldRef bean="program.desc"/>
				<dict:fieldRef bean="program.rationale"/>
				<dict:fieldRef bean="program.campusLocation"/>
				<dict:fieldRef bean="program.accreditation"/>
				<dict:fieldRef bean="program.primaryAdminOrg"/>
				<dict:fieldRef bean="program.alternateAdminOrgs"/>
				<dict:fieldRef bean="program.primaryInstructor"/>
				<dict:fieldRef bean="program.instructors"/>
				<dict:fieldRef bean="program.expectedFirstAtp"/>
				<dict:fieldRef bean="program.effectiveDate"/>
				<dict:fieldRef bean="program.expirationDate"/>
				<dict:fieldRef bean="program.duration"/>
				<dict:fieldRef bean="program.canCreateLui"/>
				<dict:fieldRef bean="program.referenceURL"/>
				<dict:fieldRef bean="program.luCodes"/>
				<dict:fieldRef bean="program.publishingInfo"/>
				<dict:fieldRef bean="program.nextReviewPeriod"/>
				<dict:fieldRef bean="program.isEnrollable"/>
				<dict:fieldRef bean="program.seasons"/>
				<dict:fieldRef bean="program.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="program.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="program.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="program.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="program.feeInfo"/>
				<dict:fieldRef bean="program.accountingInfo"/>
				<dict:fieldRef bean="program.dynamic.attributes"/>
				<dict:fieldRef bean="program.meta"/>
				<dict:fieldRef bean="program.type"/>
				<dict:fieldRef bean="program.state"/>
				<dict:fieldRef bean="program.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved (rejected) -->
			<!-- Do we need here some indication of why it was not approved?  I.e. disapproved vs. not acted on because submitted too late, etc. -->
				
				<dict:field key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>program no</dict:name>
						<dict:desc>program no</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="program.official.no"/>
										<dict:fieldRef bean="program.official.transcriptTitle"/>
										<dict:fieldRef bean="program.official.catalogTitle"/>
										<dict:fieldRef bean="program.official.level"/>
										
										<dict:field id="program.official.subjectArea.rejected" key="division">
											<dict:fieldDescriptor>
												<dict:name>program official subjectArea</dict:name>
												<dict:desc>subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="program.official.version"/>
										<dict:fieldRef bean="program.official.adminOrg"/>
										<dict:fieldRef bean="program.official.type"/>
										<dict:fieldRef bean="program.official.state"/>
										<dict:fieldRef bean="program.official.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="program.official.no"/>
										<dict:fieldRef bean="program.official.transcriptTitle"/>
										<dict:fieldRef bean="program.official.catalogTitle"/>
										<dict:fieldRef bean="program.official.level"/>
										<dict:fieldRef bean="program.official.subjectArea.rejected"/>
										<dict:fieldRef bean="program.official.version"/>
										<dict:fieldRef bean="program.official.adminOrg"/>
										<dict:fieldRef bean="program.official.type"/>
										<dict:fieldRef bean="program.official.state"/>
										<dict:fieldRef bean="program.official.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="program.alternateIdentifiers"/>
				<dict:fieldRef bean="program.academicSubjectOrgs"/>
				<dict:fieldRef bean="program.studySubjectArea"/>
				<dict:fieldRef bean="program.desc"/>
				<dict:fieldRef bean="program.rationale"/>
				<dict:fieldRef bean="program.campusLocation"/>
				<dict:fieldRef bean="program.accreditation"/>
				<dict:fieldRef bean="program.primaryAdminOrg"/>
				<dict:fieldRef bean="program.alternateAdminOrgs"/>
				<dict:fieldRef bean="program.primaryInstructor"/>
				<dict:fieldRef bean="program.instructors"/>
				<dict:fieldRef bean="program.expectedFirstAtp"/>
				<dict:fieldRef bean="program.effectiveDate"/>
				<dict:fieldRef bean="program.expirationDate"/>
				<dict:fieldRef bean="program.duration"/>
				<dict:fieldRef bean="program.canCreateLui"/>
				<dict:fieldRef bean="program.referenceURL"/>
				<dict:fieldRef bean="program.luCodes"/>
				<dict:fieldRef bean="program.publishingInfo"/>
				<dict:fieldRef bean="program.nextReviewPeriod"/>
				<dict:fieldRef bean="program.isEnrollable"/>
				<dict:fieldRef bean="program.seasons"/>
				<dict:fieldRef bean="program.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="program.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="program.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="program.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="program.feeInfo"/>
				<dict:fieldRef bean="program.accountingInfo"/>
				<dict:fieldRef bean="program.dynamic.attributes"/>
				<dict:fieldRef bean="program.meta"/>
				<dict:fieldRef bean="program.type"/>
				<dict:fieldRef bean="program.state"/>
				<dict:fieldRef bean="program.internal.id"/>
			</dict:state>
			<dict:state key="activated">
			<!-- Activated and ready to be published -->
				<dict:fieldRef bean="program.official"/>
				<dict:fieldRef bean="program.alternateIdentifiers"/>
				<dict:fieldRef bean="program.academicSubjectOrgs"/>
				<dict:fieldRef bean="program.studySubjectArea"/>
				<dict:fieldRef bean="program.desc"/>
				<dict:fieldRef bean="program.rationale"/>
				<dict:fieldRef bean="program.campusLocation"/>
				<dict:fieldRef bean="program.accreditation"/>
				<dict:fieldRef bean="program.primaryAdminOrg"/>
				<dict:fieldRef bean="program.alternateAdminOrgs"/>
				<dict:fieldRef bean="program.primaryInstructor"/>
				<dict:fieldRef bean="program.instructors"/>
				<dict:fieldRef bean="program.expectedFirstAtp"/>
				<dict:fieldRef bean="program.effectiveDate"/>
				<dict:fieldRef bean="program.expirationDate"/>
				<dict:fieldRef bean="program.duration"/>
				<dict:fieldRef bean="program.canCreateLui"/>
				<dict:fieldRef bean="program.referenceURL"/>
				<dict:fieldRef bean="program.luCodes"/>
				<dict:fieldRef bean="program.publishingInfo"/>
				<dict:fieldRef bean="program.nextReviewPeriod"/>
				<dict:fieldRef bean="program.isEnrollable"/>
				<dict:fieldRef bean="program.seasons"/>
				<dict:fieldRef bean="program.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="program.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="program.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="program.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="program.feeInfo"/>
				<dict:fieldRef bean="program.accountingInfo"/>
				<dict:fieldRef bean="program.dynamic.attributes"/>
				<dict:fieldRef bean="program.meta"/>
				<dict:fieldRef bean="program.type"/>
				<dict:fieldRef bean="program.state"/>
				<dict:fieldRef bean="program.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- Do we need/want to differentiate here between retiring a course simply because it will no longer be taught and retiring a version of a course because it has been superceded by a newer version. -->
				<dict:fieldRef bean="program.official"/>
				<dict:fieldRef bean="program.alternateIdentifiers"/>
				<dict:fieldRef bean="program.academicSubjectOrgs"/>
				<dict:fieldRef bean="program.studySubjectArea"/>
				<dict:fieldRef bean="program.desc"/>
				<dict:fieldRef bean="program.rationale"/>
				<dict:fieldRef bean="program.campusLocation"/>
				<dict:fieldRef bean="program.accreditation"/>
				<dict:fieldRef bean="program.primaryAdminOrg"/>
				<dict:fieldRef bean="program.alternateAdminOrgs"/>
				<dict:fieldRef bean="program.primaryInstructor"/>
				<dict:fieldRef bean="program.instructors"/>
				<dict:fieldRef bean="program.expectedFirstAtp"/>
				<dict:fieldRef bean="program.effectiveDate"/>
				
				<dict:field id="program.expirationDate.retired" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>program effectiveDate</dict:name>
						<dict:desc>last date program is open</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
							<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="program.duration"/>
				<dict:fieldRef bean="program.canCreateLui"/>
				<dict:fieldRef bean="program.referenceURL"/>
				<dict:fieldRef bean="program.luCodes"/>
				<dict:fieldRef bean="program.publishingInfo"/>
				<dict:fieldRef bean="program.nextReviewPeriod"/>
				<dict:fieldRef bean="program.isEnrollable"/>
				<dict:fieldRef bean="program.seasons"/>
				<dict:fieldRef bean="program.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="program.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="program.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="program.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="program.feeInfo"/>
				<dict:fieldRef bean="program.accountingInfo"/>
				<dict:fieldRef bean="program.dynamic.attributes"/>
				<dict:fieldRef bean="program.meta"/>
				<dict:fieldRef bean="program.type"/>
				<dict:fieldRef bean="program.state"/>
				<dict:fieldRef bean="program.internal.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key=".CluResultInfo">
		<!-- information about a CLU result. -->
		<dict:type key="kuali.resultType.creditCourseResult">
			<dict:state key="active">
			<!-- cluResult is active -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				
				<dict:field id="course.final.results.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>course final results desc</dict:name>
						<dict:desc>course final results desc</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.final.results.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>course.final.results.desc.plain</dict:name>
												<dict:desc>course.final.results.desc.plain</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>course.final.results.desc.formatted</dict:name>
												<dict:desc>course.final.results.desc.formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.final.grade.award.option.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>course.final.results.final.grade.award.option.desc.plain</dict:name>
												<dict:desc>course.final.results.final.grade.award.option.desc.plain</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.final.grade.award.option.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>course.final.results.final.grade.award.option.desc.formatted</dict:name>
												<dict:desc>course.final.results.final.grade.award.option.desc.formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.qualitative.option.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>course.final.results.qualitative.option.desc.plain</dict:name>
												<dict:desc>course.final.results.qualitative.option.desc.plain</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.qualitative.option.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>course.final.results.qualitative.option.desc.formatted</dict:name>
												<dict:desc>course.final.results.qualitative.option.desc.formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.final.results.cluId" key="cluId">
					<dict:fieldDescriptor>
						<dict:name>course final results CluId</dict:name>
						<dict:desc>the interanl Id of the course that this course final results is for</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="related.cluId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.final.results.options" key="resultOptions">
					<dict:fieldDescriptor>
						<dict:name>course final results options</dict:name>
						<dict:desc>The possible results associated with a course</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key=".ResultOptionInfo">
								<!-- information about a result option. -->
								<dict:type key="Kuali.resultUsageType.CreditAwarded">
								<!-- The amount of credit to be awarded if student passes the course -->
									<dict:state key="active">
									<!-- resultOption is active -->
									<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
										
										<dict:field id="course.final.results.credit.award.option.desc" key="desc">
											<dict:fieldDescriptor>
												<dict:name>course final results credit award option desc</dict:name>
												<dict:desc>course final results credit award option desc</dict:desc>
												<dict:dataType>complex</dict:dataType>
													
													<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
														<!-- Complex type supporting both a plain text and formatted version of a string. -->
														<dict:type key="kuali.not.applicable">
														<!-- Not applicable -->
														<!-- (n/a) -->
															<dict:state key="(n/a)">
															<!-- Not applicable -->
																
																<dict:field id="course.final.results.credit.award.option.desc.plain" key="plain">
																	<dict:fieldDescriptor>
																		<dict:name>course.final.results.credit.award.option.desc.plain</dict:name>
																		<dict:desc>course.final.results.credit.award.option.desc.plain</dict:desc>
																		<dict:dataType>string</dict:dataType>
																		<dict:readOnly>true</dict:readOnly>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="read.only"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="multi.line.text"/>
																			<dict:constraintRef bean="hidden"/>
																			<dict:constraintRef bean="calc.plain.text"/>
																			<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
																				<dict:maxLength>(unbounded)</dict:maxLength>
																				</dict:constraint>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="course.final.results.credit.award.option.desc.formatted" key="formatted">
																	<dict:fieldDescriptor>
																		<dict:name>course.final.results.credit.award.option.desc.formatted</dict:name>
																		<dict:desc>course.final.results.credit.award.option.desc.formatted</dict:desc>
																		<dict:dataType>string</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="optional"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="rich.text"/>
																			<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
																				<dict:maxLength>(unbounded)</dict:maxLength>
																				</dict:constraint>
																	</dict:constraintDescriptor>
																</dict:field>
															</dict:state>
														</dict:type>
													</dict:objectStructure>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.credit.award.option.resultUsageTypeKey" key="resultUsageTypeKey">
											<dict:fieldDescriptor>
												<dict:name>course final results credit award option result usage type key</dict:name>
												<dict:desc>the type of result option for this course final results</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="resultUsage.types"/>
													<dict:constraintRef bean="hard.coded.credit.awarded.resultUsage"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.credit.award.option.resultComponentId" key="resultComponentId">
											<dict:fieldDescriptor>
												<dict:name>course final results credit award option resultComponent Id</dict:name>
												<dict:desc>the internal identifier for the course final results credit award option</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.resultComponentId"/>
													<dict:constraintRef bean="related.creditkey"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.credit.award.option.effectiveDate" key="effectiveDate">
											<dict:fieldDescriptor>
												<dict:name>course final results credit award option effective date</dict:name>
												<dict:desc>course final results credit award option effective date</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.credit.award.option.expirationDate" key="expirationDate">
											<dict:fieldDescriptor>
												<dict:name>course final results credit award option expiration date</dict:name>
												<dict:desc>course final results credit award option expiration date</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.credit.award.option.metaInfo" key="metaInfo">
											<dict:fieldDescriptor>
												<dict:name>course final results credit award option state</dict:name>
												<dict:desc>course final results credit award option state</dict:desc>
												<dict:dataType>complex</dict:dataType>
													
													<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
														<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
														<dict:type key="kuali.not.applicable">
														<!-- Not applicable -->
														<!-- (n/a) -->
															<dict:state key="(n/a)">
															<!-- Not applicable -->
																
																<dict:field id="course.final.results.credit.award.option.meta.versionInd" key="versionInd">
																	<dict:fieldDescriptor>
																		<dict:name>credit award  meta versionInd</dict:name>
																		<dict:desc>credit award  meta versionInd</dict:desc>
																		<dict:dataType>string</dict:dataType>
																		<dict:readOnly>true</dict:readOnly>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="calc.meta.versionInd"/>
																			<dict:constraintRef bean="read.only"/>
																			<dict:constraintRef bean="hidden"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="course.final.results.credit.award.option.meta.createTime" key="createTime">
																	<dict:fieldDescriptor>
																		<dict:name>credit award  meta createTime</dict:name>
																		<dict:desc>credit award  meta createTime</dict:desc>
																		<dict:dataType>dateTime</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="date.time"/>
																			<dict:constraintRef bean="default.now"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="course.final.results.credit.award.option.meta.createId" key="createId">
																	<dict:fieldDescriptor>
																		<dict:name>credit award  meta createId</dict:name>
																		<dict:desc>credit award  meta createId</dict:desc>
																		<dict:dataType>string</dict:dataType>
																		<dict:readOnly>true</dict:readOnly>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="read.only"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="related.principalId"/>
																			<dict:constraintRef bean="default.authenicated.principalId"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="course.final.results.credit.award.option.meta.updateTime" key="updateTime">
																	<dict:fieldDescriptor>
																		<dict:name>credit award  meta updateTime</dict:name>
																		<dict:desc>credit award  meta updateTime</dict:desc>
																		<dict:dataType>dateTime</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="date.time"/>
																			<dict:constraintRef bean="calc.now"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="course.final.results.credit.award.option.meta.updateId" key="updateId">
																	<dict:fieldDescriptor>
																		<dict:name>credit award  meta updateId</dict:name>
																		<dict:desc>credit award  meta updateId</dict:desc>
																		<dict:dataType>string</dict:dataType>
																		<dict:readOnly>true</dict:readOnly>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="read.only"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="related.principalId"/>
																			<dict:constraintRef bean="calc.authenicated.principalId"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="course.final.results.final.grade.award.option.meta.versionInd" key="versionInd">
																	<dict:fieldDescriptor>
																		<dict:name>final grade award  meta versionInd</dict:name>
																		<dict:desc>final grade award  meta versionInd</dict:desc>
																		<dict:dataType>string</dict:dataType>
																		<dict:readOnly>true</dict:readOnly>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="calc.meta.versionInd"/>
																			<dict:constraintRef bean="read.only"/>
																			<dict:constraintRef bean="hidden"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="course.final.results.final.grade.award.option.meta.createTime" key="createTime">
																	<dict:fieldDescriptor>
																		<dict:name>final grade award  meta createTime</dict:name>
																		<dict:desc>final grade award  meta createTime</dict:desc>
																		<dict:dataType>dateTime</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="date.time"/>
																			<dict:constraintRef bean="default.now"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="course.final.results.final.grade.award.option.meta.createId" key="createId">
																	<dict:fieldDescriptor>
																		<dict:name>final grade award  meta createId</dict:name>
																		<dict:desc>final grade award  meta createId</dict:desc>
																		<dict:dataType>string</dict:dataType>
																		<dict:readOnly>true</dict:readOnly>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="read.only"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="related.principalId"/>
																			<dict:constraintRef bean="default.authenicated.principalId"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="course.final.results.final.grade.award.option.meta.updateTime" key="updateTime">
																	<dict:fieldDescriptor>
																		<dict:name>final grade award  meta updateTime</dict:name>
																		<dict:desc>final grade award  meta updateTime</dict:desc>
																		<dict:dataType>dateTime</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="date.time"/>
																			<dict:constraintRef bean="calc.now"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="course.final.results.final.grade.award.option.meta.updateId" key="updateId">
																	<dict:fieldDescriptor>
																		<dict:name>final grade award  meta updateId</dict:name>
																		<dict:desc>final grade award  meta updateId</dict:desc>
																		<dict:dataType>string</dict:dataType>
																		<dict:readOnly>true</dict:readOnly>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="read.only"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="related.principalId"/>
																			<dict:constraintRef bean="calc.authenicated.principalId"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="course.final.results.qualitative.option.meta.versionInd" key="versionInd">
																	<dict:fieldDescriptor>
																		<dict:name>qualitative  meta versionInd</dict:name>
																		<dict:desc>qualitative  meta versionInd</dict:desc>
																		<dict:dataType>string</dict:dataType>
																		<dict:readOnly>true</dict:readOnly>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="calc.meta.versionInd"/>
																			<dict:constraintRef bean="read.only"/>
																			<dict:constraintRef bean="hidden"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="course.final.results.qualitative.option.meta.createTime" key="createTime">
																	<dict:fieldDescriptor>
																		<dict:name>qualitative  meta createTime</dict:name>
																		<dict:desc>qualitative  meta createTime</dict:desc>
																		<dict:dataType>dateTime</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="date.time"/>
																			<dict:constraintRef bean="default.now"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="course.final.results.qualitative.option.meta.createId" key="createId">
																	<dict:fieldDescriptor>
																		<dict:name>qualitative  meta createId</dict:name>
																		<dict:desc>qualitative  meta createId</dict:desc>
																		<dict:dataType>string</dict:dataType>
																		<dict:readOnly>true</dict:readOnly>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="read.only"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="related.principalId"/>
																			<dict:constraintRef bean="default.authenicated.principalId"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="course.final.results.qualitative.option.meta.updateTime" key="updateTime">
																	<dict:fieldDescriptor>
																		<dict:name>qualitative  meta updateTime</dict:name>
																		<dict:desc>qualitative  meta updateTime</dict:desc>
																		<dict:dataType>dateTime</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="date.time"/>
																			<dict:constraintRef bean="calc.now"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="course.final.results.qualitative.option.meta.updateId" key="updateId">
																	<dict:fieldDescriptor>
																		<dict:name>qualitative  meta updateId</dict:name>
																		<dict:desc>qualitative  meta updateId</dict:desc>
																		<dict:dataType>string</dict:dataType>
																		<dict:readOnly>true</dict:readOnly>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="read.only"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="related.principalId"/>
																			<dict:constraintRef bean="calc.authenicated.principalId"/>
																	</dict:constraintDescriptor>
																</dict:field>
															</dict:state>
														</dict:type>
													</dict:objectStructure>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.meta.data"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.credit.award.option.state" key="state">
											<dict:fieldDescriptor>
												<dict:name>course final results credit award option effective date</dict:name>
												<dict:desc>course final results credit award option effective date</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.state"/>
											</dict:constraintDescriptor>
											<dict:selector>true</dict:selector>
										</dict:field>
										
										<dict:field id="course.final.results.credit.award.option.internal.id" key="id">
											<dict:fieldDescriptor>
												<dict:name>course final results credit award option internal id</dict:name>
												<dict:desc>the internal id of the credit award option for the course final results</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.id"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.qualitative.option.desc" key="desc">
											<dict:fieldDescriptor>
												<dict:name>course final results qualitative option desc</dict:name>
												<dict:desc>course final results qualitative option desc</dict:desc>
												<dict:dataType>complex</dict:dataType>
													
													<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
														<!-- Complex type supporting both a plain text and formatted version of a string. -->
														<dict:type key="kuali.not.applicable">
														<!-- Not applicable -->
														<!-- (n/a) -->
															<dict:state key="(n/a)">
															<!-- Not applicable -->
																<dict:fieldRef bean="course.final.results.credit.award.option.desc.plain"/>
																<dict:fieldRef bean="course.final.results.credit.award.option.desc.formatted"/>
															</dict:state>
														</dict:type>
													</dict:objectStructure>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.qualitative.option.resultUsageTypeKey" key="resultUsageTypeKey">
											<dict:fieldDescriptor>
												<dict:name>course final results qualitative option result usage type key</dict:name>
												<dict:desc>the type of result option for this course final results</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="resultUsage.types"/>
													<dict:constraintRef bean="hard.coded.final.qualitative.result.Usage"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.qualitative.option.resultComponentId" key="resultComponentId">
											<dict:fieldDescriptor>
												<dict:name>course final results qualitative option resultComponent Id</dict:name>
												<dict:desc>the internal identifier for the course final results qualitative option</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.resultComponentId"/>
													<dict:constraintRef bean="related.gradekey"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.qualitative.option.effectiveDate" key="effectiveDate">
											<dict:fieldDescriptor>
												<dict:name>course final results qualitative option effective date</dict:name>
												<dict:desc>course final results qualitative option effective date</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.qualitative.option.expirationDate" key="expirationDate">
											<dict:fieldDescriptor>
												<dict:name>course final results qualitative option expiration date</dict:name>
												<dict:desc>course final results qualitative option expiration date</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.qualitative.option.metaInfo" key="metaInfo">
											<dict:fieldDescriptor>
												<dict:name>course final results qualitative option state</dict:name>
												<dict:desc>course final results qualitative option state</dict:desc>
												<dict:dataType>complex</dict:dataType>
													
													<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
														<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
														<dict:type key="kuali.not.applicable">
														<!-- Not applicable -->
														<!-- (n/a) -->
															<dict:state key="(n/a)">
															<!-- Not applicable -->
																<dict:fieldRef bean="course.final.results.credit.award.option.meta.versionInd"/>
																<dict:fieldRef bean="course.final.results.credit.award.option.meta.createTime"/>
																<dict:fieldRef bean="course.final.results.credit.award.option.meta.createId"/>
																<dict:fieldRef bean="course.final.results.credit.award.option.meta.updateTime"/>
																<dict:fieldRef bean="course.final.results.credit.award.option.meta.updateId"/>
																<dict:fieldRef bean="course.final.results.final.grade.award.option.meta.versionInd"/>
																<dict:fieldRef bean="course.final.results.final.grade.award.option.meta.createTime"/>
																<dict:fieldRef bean="course.final.results.final.grade.award.option.meta.createId"/>
																<dict:fieldRef bean="course.final.results.final.grade.award.option.meta.updateTime"/>
																<dict:fieldRef bean="course.final.results.final.grade.award.option.meta.updateId"/>
																<dict:fieldRef bean="course.final.results.qualitative.option.meta.versionInd"/>
																<dict:fieldRef bean="course.final.results.qualitative.option.meta.createTime"/>
																<dict:fieldRef bean="course.final.results.qualitative.option.meta.createId"/>
																<dict:fieldRef bean="course.final.results.qualitative.option.meta.updateTime"/>
																<dict:fieldRef bean="course.final.results.qualitative.option.meta.updateId"/>
															</dict:state>
														</dict:type>
													</dict:objectStructure>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.meta.data"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.qualitative.option.state" key="state">
											<dict:fieldDescriptor>
												<dict:name>course final results qualitative option effective date</dict:name>
												<dict:desc>course final results qualitative option effective date</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.state"/>
											</dict:constraintDescriptor>
											<dict:selector>true</dict:selector>
										</dict:field>
										
										<dict:field id="course.final.results.qualitative.option.internal.id" key="id">
											<dict:fieldDescriptor>
												<dict:name>course final results qualitative option internal id</dict:name>
												<dict:desc>the internal id of the qualitative option for the course final results</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.id"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
									<dict:state key="inactive">
									<!-- resultOption is inactive -->
									<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
										<dict:fieldRef bean="course.final.results.credit.award.option.desc"/>
										<dict:fieldRef bean="course.final.results.credit.award.option.resultUsageTypeKey"/>
										<dict:fieldRef bean="course.final.results.credit.award.option.resultComponentId"/>
										<dict:fieldRef bean="course.final.results.credit.award.option.effectiveDate"/>
										<dict:fieldRef bean="course.final.results.credit.award.option.expirationDate"/>
										<dict:fieldRef bean="course.final.results.credit.award.option.metaInfo"/>
										<dict:fieldRef bean="course.final.results.credit.award.option.state"/>
										<dict:fieldRef bean="course.final.results.credit.award.option.internal.id"/>
										<dict:fieldRef bean="course.final.results.qualitative.option.desc"/>
										<dict:fieldRef bean="course.final.results.qualitative.option.resultUsageTypeKey"/>
										<dict:fieldRef bean="course.final.results.qualitative.option.resultComponentId"/>
										<dict:fieldRef bean="course.final.results.qualitative.option.effectiveDate"/>
										<dict:fieldRef bean="course.final.results.qualitative.option.expirationDate"/>
										<dict:fieldRef bean="course.final.results.qualitative.option.metaInfo"/>
										<dict:fieldRef bean="course.final.results.qualitative.option.state"/>
										<dict:fieldRef bean="course.final.results.qualitative.option.internal.id"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.resultUsageType.FinalGradeAwarded">
								<!-- The final grade to be awarded to a student -->
								<!-- TO DO: add to Simples -->
									<dict:state key="active">
									<!-- resultOption is active -->
									<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
										
										<dict:field id="course.final.results.final.grade.award.option.desc" key="desc">
											<dict:fieldDescriptor>
												<dict:name>course final results final grade award option desc</dict:name>
												<dict:desc>course final results final grade award option desc</dict:desc>
												<dict:dataType>complex</dict:dataType>
													
													<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
														<!-- Complex type supporting both a plain text and formatted version of a string. -->
														<dict:type key="kuali.not.applicable">
														<!-- Not applicable -->
														<!-- (n/a) -->
															<dict:state key="(n/a)">
															<!-- Not applicable -->
																<dict:fieldRef bean="course.final.results.credit.award.option.desc.plain"/>
																<dict:fieldRef bean="course.final.results.credit.award.option.desc.formatted"/>
															</dict:state>
														</dict:type>
													</dict:objectStructure>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.final.grade.award.option.resultUsageTypeKey" key="resultUsageTypeKey">
											<dict:fieldDescriptor>
												<dict:name>course final results final grade award option result usage type key</dict:name>
												<dict:desc>the type of result option for this course final results</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="resultUsage.types"/>
													<dict:constraintRef bean="hard.coded.final.grad.awarded.resultUsage"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.final.grade.award.option.resultComponentId" key="resultComponentId">
											<dict:fieldDescriptor>
												<dict:name>course final results final grade award option resultComponent Id</dict:name>
												<dict:desc>the internal identifier for the course final results final grade award option</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.resultComponentId"/>
													<dict:constraintRef bean="related.gradekey"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.final.grade.award.option.effectiveDate" key="effectiveDate">
											<dict:fieldDescriptor>
												<dict:name>course final results final grade award option effective date</dict:name>
												<dict:desc>course final results final grade award option effective date</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.final.grade.award.option.expirationDate" key="expirationDate">
											<dict:fieldDescriptor>
												<dict:name>course final results final grade award option expiration date</dict:name>
												<dict:desc>course final results final grade award option expiration date</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.final.grade.award.option.metaInfo" key="metaInfo">
											<dict:fieldDescriptor>
												<dict:name>course final results final grade award option meta-info</dict:name>
												<dict:desc>course final results final grade award option meta-info</dict:desc>
												<dict:dataType>complex</dict:dataType>
													
													<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
														<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
														<dict:type key="kuali.not.applicable">
														<!-- Not applicable -->
														<!-- (n/a) -->
															<dict:state key="(n/a)">
															<!-- Not applicable -->
																<dict:fieldRef bean="course.final.results.credit.award.option.meta.versionInd"/>
																<dict:fieldRef bean="course.final.results.credit.award.option.meta.createTime"/>
																<dict:fieldRef bean="course.final.results.credit.award.option.meta.createId"/>
																<dict:fieldRef bean="course.final.results.credit.award.option.meta.updateTime"/>
																<dict:fieldRef bean="course.final.results.credit.award.option.meta.updateId"/>
																<dict:fieldRef bean="course.final.results.final.grade.award.option.meta.versionInd"/>
																<dict:fieldRef bean="course.final.results.final.grade.award.option.meta.createTime"/>
																<dict:fieldRef bean="course.final.results.final.grade.award.option.meta.createId"/>
																<dict:fieldRef bean="course.final.results.final.grade.award.option.meta.updateTime"/>
																<dict:fieldRef bean="course.final.results.final.grade.award.option.meta.updateId"/>
																<dict:fieldRef bean="course.final.results.qualitative.option.meta.versionInd"/>
																<dict:fieldRef bean="course.final.results.qualitative.option.meta.createTime"/>
																<dict:fieldRef bean="course.final.results.qualitative.option.meta.createId"/>
																<dict:fieldRef bean="course.final.results.qualitative.option.meta.updateTime"/>
																<dict:fieldRef bean="course.final.results.qualitative.option.meta.updateId"/>
															</dict:state>
														</dict:type>
													</dict:objectStructure>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.meta.data"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.final.grade.award.option.state" key="state">
											<dict:fieldDescriptor>
												<dict:name>course final results final grade award option state</dict:name>
												<dict:desc>course final results final grade award option state</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.state"/>
											</dict:constraintDescriptor>
											<dict:selector>true</dict:selector>
										</dict:field>
										
										<dict:field id="course.final.results.final.grade.award.option.internal.id" key="id">
											<dict:fieldDescriptor>
												<dict:name>course final results final grade award option internal id</dict:name>
												<dict:desc>the internal id of the final grade award option for the course final results</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.id"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
									<dict:state key="inactive">
									<!-- resultOption is inactive -->
									<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
										<dict:fieldRef bean="course.final.results.final.grade.award.option.desc"/>
										<dict:fieldRef bean="course.final.results.final.grade.award.option.resultUsageTypeKey"/>
										<dict:fieldRef bean="course.final.results.final.grade.award.option.resultComponentId"/>
										<dict:fieldRef bean="course.final.results.final.grade.award.option.effectiveDate"/>
										<dict:fieldRef bean="course.final.results.final.grade.award.option.expirationDate"/>
										<dict:fieldRef bean="course.final.results.final.grade.award.option.metaInfo"/>
										<dict:fieldRef bean="course.final.results.final.grade.award.option.state"/>
										<dict:fieldRef bean="course.final.results.final.grade.award.option.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="required"/>
							<dict:constraint key="exactly.one.credit.award.option.one.or.more.final.grade.zero.or.one.qualitative.assessment" id="exactly.one.credit.award.option.one.or.more.final.grade.zero.or.one.qualitative.assessment">
							<dict:typeStateCase>
								<dict:typeStateWhen type="Kuali.resultUsageType.CreditAwarded">
								<!-- for a Credit Course Final Results, there must exist one and only one resultOption with a usageType of Credit to be Awarded -->
									<dict:minOccurs>1</dict:minOccurs>
									<dict:maxOccurs>1</dict:maxOccurs>
								</dict:typeStateWhen>
								<dict:typeStateWhen type="kuali.resultUsageType.FinalGradeAwarded">
								<!-- for a Credit Course Final Results, there must be either one or two  resultOptions of a usageType Final Grade to be Awarded (this maps to the grading scales that are availbale for the course) -->
									<dict:minOccurs>1</dict:minOccurs>
									<dict:maxOccurs>2</dict:maxOccurs>
								</dict:typeStateWhen>
								<dict:typeStateWhen type="kuali.resultUsageType.QualitativeAssess">
								<!-- for a Credit Course Final Results, there is one optional resultOption of usageType Final Qualitative Asessment -->
									<dict:minOccurs>0</dict:minOccurs>
									<dict:maxOccurs>1</dict:maxOccurs>
								</dict:typeStateWhen>
							</dict:typeStateCase>
							</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.final.results.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>course final results effective date</dict:name>
						<dict:desc>course final results effective date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.final.results.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>course final results expiration date</dict:name>
						<dict:desc>course final results expiration date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.final.results.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>course final results meta-info</dict:name>
						<dict:desc>course final results meta-info</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.final.results.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>course final results meta versionInd</dict:name>
												<dict:desc>course final results meta versionInd</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>course final results meta createTime</dict:name>
												<dict:desc>course final results meta createTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>course final results meta createId</dict:name>
												<dict:desc>course final results meta createId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>course final results meta updateTime</dict:name>
												<dict:desc>course final results meta updateTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.final.results.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>course final results meta updateId</dict:name>
												<dict:desc>course final results meta updateId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.final.results.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>course final results state</dict:name>
						<dict:desc>course final results state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="course.final.results.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>course final results type</dict:name>
						<dict:desc>course final results type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="cluResult.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.final.results.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>course final results internal id</dict:name>
						<dict:desc>The internal id of the course final results</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="inactive">
			<!-- clurResult is inactive -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				<dict:fieldRef bean="course.final.results.desc"/>
				<dict:fieldRef bean="course.final.results.cluId"/>
				<dict:fieldRef bean="course.final.results.options"/>
				<dict:fieldRef bean="course.final.results.effectiveDate"/>
				<dict:fieldRef bean="course.final.results.expirationDate"/>
				<dict:fieldRef bean="course.final.results.metaInfo"/>
				<dict:fieldRef bean="course.final.results.state"/>
				<dict:fieldRef bean="course.final.results.type"/>
				<dict:fieldRef bean="course.final.results.internal.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key=".CluLoRelationInfo">
		<!-- Detailed information about a CLU to Lo relationship. -->
		<dict:type key="kuali.lu.lo.relation.type.includes">
		<!-- Indicates that the content of the clu includes the learning objectives -->
			<dict:state key="draft">
			<!-- CLU-Lo relation is in draft until approved then active -->
			<!-- TODO: add to simple spec -->
				
				<dict:field id="includes.luLoRelation.loId" key="loId">
					<dict:fieldDescriptor>
						<dict:name>includes relation LO id</dict:name>
						<dict:desc>the clu id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="includes.luLoRelation.cluId" key="cluId">
					<dict:fieldDescriptor>
						<dict:name>includes relation clu id</dict:name>
						<dict:desc>the associated lo id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="includes.luLoRelation.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>includes relation effective date</dict:name>
						<dict:desc>the effective date of the lo reation</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="includes.luLoRelation.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>includes relation expiration date</dict:name>
						<dict:desc>the expiration date of the relation</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="includes.luLoRelation.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>includes relation attributes</dict:name>
						<dict:desc>attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="includes.luLoRelation.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>includes relation meta info</dict:name>
						<dict:desc>meta info</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="includes.luLoRelation.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>includes relationship meta versionInd</dict:name>
												<dict:desc>includes relationship meta versionInd</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="includes.luLoRelation.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>includes relationship meta createTime</dict:name>
												<dict:desc>includes relationship meta createTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="includes.luLoRelation.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>includes relationship meta createId</dict:name>
												<dict:desc>includes relationship meta createId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="includes.luLoRelation.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>includes relationship meta updateTime</dict:name>
												<dict:desc>includes relationship meta updateTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="includes.luLoRelation.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>includes relationship meta updateId</dict:name>
												<dict:desc>includes relationship meta updateId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="includes.luLoRelation.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>includes relation type</dict:name>
						<dict:desc>the type of the relation</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="lu.lo.relation.types"/>
							<dict:constraintRef bean="hard.coded.lulorealtion.includes"/>
							<dict:constraintRef bean="read.only"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="includes.luLoRelation.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>includes relation state</dict:name>
						<dict:desc>the state of the relation</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="includes.luLoRelation.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>includes relation internal id</dict:name>
						<dict:desc>the internal id of the lo-lo relation</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="active">
			<!-- CLU-Lo relation is active -->
			<!-- TODO: add to simple spec -->
				<dict:fieldRef bean="includes.luLoRelation.loId"/>
				<dict:fieldRef bean="includes.luLoRelation.cluId"/>
				<dict:fieldRef bean="includes.luLoRelation.effectiveDate"/>
				<dict:fieldRef bean="includes.luLoRelation.expirationDate"/>
				<dict:fieldRef bean="includes.luLoRelation.attributes"/>
				<dict:fieldRef bean="includes.luLoRelation.metaInfo"/>
				<dict:fieldRef bean="includes.luLoRelation.type"/>
				<dict:fieldRef bean="includes.luLoRelation.state"/>
				<dict:fieldRef bean="includes.luLoRelation.internal.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- CLU-Lo relation is inactive -->
			<!-- TODO: add to simple spec -->
				<dict:fieldRef bean="includes.luLoRelation.loId"/>
				<dict:fieldRef bean="includes.luLoRelation.cluId"/>
				<dict:fieldRef bean="includes.luLoRelation.effectiveDate"/>
				<dict:fieldRef bean="includes.luLoRelation.expirationDate"/>
				<dict:fieldRef bean="includes.luLoRelation.attributes"/>
				<dict:fieldRef bean="includes.luLoRelation.metaInfo"/>
				<dict:fieldRef bean="includes.luLoRelation.type"/>
				<dict:fieldRef bean="includes.luLoRelation.state"/>
				<dict:fieldRef bean="includes.luLoRelation.internal.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluCluRelationInfo">
		<!-- Detailed information about a CLU to CLU relationship. -->
		<dict:type key="kuali.lu.relation.type.co-located">
		<!-- Maintains relations betrween different courses the meet together (are co-located) -->
		<!-- Meets with, Joint (but not MIT's meaning of joint) -->
		<!-- TODO: cross-check w/ SIMPLE -->
			<dict:state key="active">
			<!-- Relation is active -->
			<!-- TODO: Add to simple spec -->
				
				<dict:field id="colocated.course.relation.course.internal.id1" key="cluId">
					<dict:fieldDescriptor>
						<dict:name>course colocated course id1</dict:name>
						<dict:desc>course id 1</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="related.cluId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="colocated.course.relation.course.internal.id2" key="relatedCluId">
					<dict:fieldDescriptor>
						<dict:name>course colocated course id2</dict:name>
						<dict:desc>course id 2</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="related.cluId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="colocated.course.relation.required" key="isCluRelationRequired">
					<dict:fieldDescriptor>
						<dict:name>course colocated required</dict:name>
						<dict:desc>indicates that colocation is required or not, hard coded to be false</dict:desc>
						<dict:dataType>boolean</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="hard.coded.false"/>
							<dict:constraintRef bean="read.only"/>
							<dict:constraint key="in-line.constraint.for.dictionary.colocated.course.relation.required">
								<dict:maxLength>20</dict:maxLength>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="colocated.course.relation.expirationDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>course colocated expirationDate</dict:name>
						<dict:desc>expiration date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
							<dict:constraintRef bean="default.now"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="colocated.course.relation.effectiveDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>course colocated effectiveDate</dict:name>
						<dict:desc>effective date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="colocated.course.relation.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>course colocated attributes</dict:name>
						<dict:desc>not used</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="colocated.course.relation.metainfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>course colocated metainfo</dict:name>
						<dict:desc>audit trail info</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.colocated.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>course colocated meta versionInd</dict:name>
												<dict:desc>Version number for this colocated course relationship info</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.colocated.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>course colocated meta createTime</dict:name>
												<dict:desc>Date-time this co-located course relationship was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.colocated.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>course colocated meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this co-located course relationship</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.colocated.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>course colocated meta updateTime</dict:name>
												<dict:desc>Date-time this co-located course relationship was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.colocated.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>course colocated meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this co-located course relationship</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="colocated.course.relation.relation.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>course colocated relation type</dict:name>
						<dict:desc>type of the relationship, hard coded to be co-located</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="lu.lu.relation.types"/>
							<dict:constraintRef bean="hard.coded.co-located"/>
							<dict:constraintRef bean="read.only"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="colocated.course.relation.relation.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>course colocated relation state</dict:name>
						<dict:desc>state of the relationship</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
							<dict:constraintRef bean="hard.coded.active"/>
							<dict:constraintRef bean="read.only"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="colocated.course.relation.relation.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>course colocated relation id</dict:name>
						<dict:desc>relationship id</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="inactive">
			<!-- Relation is inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="colocated.course.relation.course.internal.id1"/>
				<dict:fieldRef bean="colocated.course.relation.course.internal.id2"/>
				<dict:fieldRef bean="colocated.course.relation.required"/>
				<dict:fieldRef bean="colocated.course.relation.expirationDate"/>
				<dict:fieldRef bean="colocated.course.relation.effectiveDate"/>
				<dict:fieldRef bean="colocated.course.relation.attributes"/>
				<dict:fieldRef bean="colocated.course.relation.metainfo"/>
				<dict:fieldRef bean="colocated.course.relation.relation.type"/>
				<dict:fieldRef bean="colocated.course.relation.relation.state"/>
				<dict:fieldRef bean="colocated.course.relation.relation.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.lu.relation.type.course.format">
		<!-- Maintains relation betrween a course and the course format shell -->
		<!-- TODO: cross-check w/ SIMPLE -->
			<dict:state key="active">
			<!-- Relation is active -->
			<!-- TODO: Add to simple spec -->
				
				<dict:field id="course.format.relation.course.internal.id" key="cluId">
					<dict:fieldDescriptor>
						<dict:name>course format course id</dict:name>
						<dict:desc>course format course id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="related.cluId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.relation.formatshell.internal.id" key="relatedCluId">
					<dict:fieldDescriptor>
						<dict:name>course format format shell id</dict:name>
						<dict:desc>course format format shell id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="related.cluId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.relation.required" key="isCluRelationRequired">
					<dict:fieldDescriptor>
						<dict:name>course format required</dict:name>
						<dict:desc>indicates that colocation is required or not, hard coded to be false</dict:desc>
						<dict:dataType>boolean</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="hard.coded.true"/>
							<dict:constraintRef bean="read.only"/>
							<dict:constraint key="in-line.constraint.for.dictionary.course.format.relation.required">
								<dict:maxLength>20</dict:maxLength>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.relation.expirationDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>course format expirationDate</dict:name>
						<dict:desc>expiration date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
							<dict:constraintRef bean="default.now"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.relation.effectiveDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>course format effectiveDate</dict:name>
						<dict:desc>effective date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.relation.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>course format attributes</dict:name>
						<dict:desc>not used</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.relation.metainfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>course format metainfo</dict:name>
						<dict:desc>audit trail info</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.format.relation.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>course format meta versionInd</dict:name>
												<dict:desc>Version number for this format course relationship info</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.relation.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>course format meta createTime</dict:name>
												<dict:desc>Date-time this co-located course relationship was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.relation.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>course format meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this co-located course relationship</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.relation.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>course format meta updateTime</dict:name>
												<dict:desc>Date-time this co-located course relationship was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.format.relation.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>course format meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this co-located course relationship</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.relation.relation.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>course format relation type</dict:name>
						<dict:desc>type of the relationship, hard coded to be course format</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="lu.lu.relation.types"/>
							<dict:constraintRef bean="hard.coded.lulurelation.courseformat"/>
							<dict:constraintRef bean="read.only"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.relation.relation.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>course format relation state</dict:name>
						<dict:desc>state of the relationship</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
							<dict:constraintRef bean="hard.coded.active"/>
							<dict:constraintRef bean="read.only"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.format.relation.relation.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>course format relation id</dict:name>
						<dict:desc>relationship id</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="inactive">
			<!-- Relation is inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="course.format.relation.course.internal.id"/>
				<dict:fieldRef bean="course.format.relation.formatshell.internal.id"/>
				<dict:fieldRef bean="course.format.relation.required"/>
				<dict:fieldRef bean="course.format.relation.expirationDate"/>
				<dict:fieldRef bean="course.format.relation.effectiveDate"/>
				<dict:fieldRef bean="course.format.relation.attributes"/>
				<dict:fieldRef bean="course.format.relation.metainfo"/>
				<dict:fieldRef bean="course.format.relation.relation.type"/>
				<dict:fieldRef bean="course.format.relation.relation.state"/>
				<dict:fieldRef bean="course.format.relation.relation.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.lu.relation.type.course.activity">
		<!-- Maintains relation betrween a course format shell and each individual activity -->
		<!-- Lecture, Lab, Recitation, etc -->
		<!-- TODO: cross-check w/ SIMPLE -->
			<dict:state key="active">
			<!-- Relation is active -->
			<!-- TODO: Add to simple spec -->
				
				<dict:field id="course.activity.relation.course.internal.id" key="cluId">
					<dict:fieldDescriptor>
						<dict:name>course activity course id</dict:name>
						<dict:desc>course activity course id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="related.cluId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.relation.activityshell.internal.id" key="relatedCluId">
					<dict:fieldDescriptor>
						<dict:name>course activity activity shell id</dict:name>
						<dict:desc>course activity activity shell id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="related.cluId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.relation.required" key="isCluRelationRequired">
					<dict:fieldDescriptor>
						<dict:name>course activity required</dict:name>
						<dict:desc>indicates that colocation is required or not, hard coded to be false</dict:desc>
						<dict:dataType>boolean</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="hard.coded.true"/>
							<dict:constraintRef bean="read.only"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.relation.expirationDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>course activity expirationDate</dict:name>
						<dict:desc>expiration date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
							<dict:constraintRef bean="default.now"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.relation.effectiveDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>course activity effectiveDate</dict:name>
						<dict:desc>effective date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.relation.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>course activity attributes</dict:name>
						<dict:desc>not used</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.relation.metainfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>course activity metainfo</dict:name>
						<dict:desc>audit trail info</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.activity.relation.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>course activity meta versionInd</dict:name>
												<dict:desc>Version number for this activity course relationship info</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.relation.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>course activity meta createTime</dict:name>
												<dict:desc>Date-time this co-located course relationship was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.relation.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>course activity meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this co-located course relationship</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.relation.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>course activity meta updateTime</dict:name>
												<dict:desc>Date-time this co-located course relationship was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.activity.relation.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>course activity meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this co-located course relationship</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.relation.relation.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>course activity relation type</dict:name>
						<dict:desc>type of the relationship, hard coded to be course activity</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="lu.lu.relation.types"/>
							<dict:constraintRef bean="hard.coded.lulurelation.courseformat"/>
							<dict:constraintRef bean="read.only"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.relation.relation.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>course activity relation state</dict:name>
						<dict:desc>state of the relationship</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
							<dict:constraintRef bean="hard.coded.active"/>
							<dict:constraintRef bean="read.only"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.activity.relation.relation.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>course activity relation id</dict:name>
						<dict:desc>relationship id</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="inactive">
			<!-- Relation is inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="course.activity.relation.course.internal.id"/>
				<dict:fieldRef bean="course.activity.relation.activityshell.internal.id"/>
				<dict:fieldRef bean="course.activity.relation.required"/>
				<dict:fieldRef bean="course.activity.relation.expirationDate"/>
				<dict:fieldRef bean="course.activity.relation.effectiveDate"/>
				<dict:fieldRef bean="course.activity.relation.attributes"/>
				<dict:fieldRef bean="course.activity.relation.metainfo"/>
				<dict:fieldRef bean="course.activity.relation.relation.type"/>
				<dict:fieldRef bean="course.activity.relation.relation.state"/>
				<dict:fieldRef bean="course.activity.relation.relation.internal.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key="org.kuali.student.lum.lo.dto.LoInfo">
		<!-- Detailed information about a learning objective -->
		<dict:type key="kuali.lo.type.singleUse">
		<!-- LO created in support of programs or courses, e.g., faculty-inspired additional LO for a course that are not intended for others to re-use -->
			<dict:state key="draft">
			<!-- Lo is in draft until approved then active -->
			<!-- TODO: add to simple spec -->
				
				<dict:field id="singleUse.lo.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>informal lo name</dict:name>
						<dict:desc>the name of the lo</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="singleUse.lo.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>informal lo description</dict:name>
						<dict:desc>the description of the lo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="singleUse.lo.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>informal lo desc plain text</dict:name>
												<dict:desc>informal lo desc plain text</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="singleUse.lo.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>informal lo desc formatted</dict:name>
												<dict:desc>informal lo desc formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="singleUse.lo.loRepository" key="loRepositoryKey">
					<dict:fieldDescriptor>
						<dict:name>informal lo hierarcy</dict:name>
						<dict:desc>the name of the hierarchy to which the lo belongs</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="lo.repositories"/>
							<dict:constraintRef bean="hard.coded.singleUse.lo.repository"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="singleUse.lo.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>informal lo effective date</dict:name>
						<dict:desc>the effective date of the lo</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="singleUse.lo.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>informal lo expiration date</dict:name>
						<dict:desc>the expiration date of the lo</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="singleUse.lo.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>informal lo attributes</dict:name>
						<dict:desc>attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="singleUse.lo.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>informal lo meta info</dict:name>
						<dict:desc>meta info</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="singleUse.lo.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>informal lo meta versionInd</dict:name>
												<dict:desc>informal lo meta versionInd</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="singleUse.lo.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>informal lo meta createTime</dict:name>
												<dict:desc>informal lo meta createTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="singleUse.lo.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>informal lo meta createId</dict:name>
												<dict:desc>informal lo meta createId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="singleUse.lo.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>informal lo meta updateTime</dict:name>
												<dict:desc>informal lo meta updateTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="singleUse.lo.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>informal lo meta updateId</dict:name>
												<dict:desc>informal lo meta updateId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="singleUse.lo.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>type</dict:name>
						<dict:desc>the type of the lo</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="lo.types"/>
							<dict:constraintRef bean="hard.coded.singleUse.lo"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="singleUse.lo.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>informal lo.state</dict:name>
						<dict:desc>the state of the lo</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="singleUse.lo.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>informal lo internal id</dict:name>
						<dict:desc>the internal id of the lo</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="active">
			<!-- Lo is active -->
			<!-- TODO: add to simple spec -->
				<dict:fieldRef bean="singleUse.lo.name"/>
				<dict:fieldRef bean="singleUse.lo.desc"/>
				<dict:fieldRef bean="singleUse.lo.loRepository"/>
				<dict:fieldRef bean="singleUse.lo.effectiveDate"/>
				<dict:fieldRef bean="singleUse.lo.expirationDate"/>
				<dict:fieldRef bean="singleUse.lo.attributes"/>
				<dict:fieldRef bean="singleUse.lo.metaInfo"/>
				<dict:fieldRef bean="singleUse.lo.type"/>
				<dict:fieldRef bean="singleUse.lo.state"/>
				<dict:fieldRef bean="singleUse.lo.internal.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- Lo is inactive -->
			<!-- TODO: add to simple spec -->
				<dict:fieldRef bean="singleUse.lo.name"/>
				<dict:fieldRef bean="singleUse.lo.desc"/>
				<dict:fieldRef bean="singleUse.lo.loRepository"/>
				<dict:fieldRef bean="singleUse.lo.effectiveDate"/>
				<dict:fieldRef bean="singleUse.lo.expirationDate"/>
				<dict:fieldRef bean="singleUse.lo.attributes"/>
				<dict:fieldRef bean="singleUse.lo.metaInfo"/>
				<dict:fieldRef bean="singleUse.lo.type"/>
				<dict:fieldRef bean="singleUse.lo.state"/>
				<dict:fieldRef bean="singleUse.lo.internal.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key="org.kuali.student.lum.lo.dto.LoLoRelationInfo">
		<!-- Detailed information about an LO to LO relationship. -->
		<dict:type key="kuali.lo.relation.type.includes">
		<!-- Parent-child relationship between a parent LO and sub LO. Currently used in the context of LOs that are related within a single CLU. -->
			<dict:state key="draft">
			<!-- Lo is in draft until approved then active -->
			<!-- TODO: add to simple spec -->
				
				<dict:field id="includes.loLoRelation.loId" key="loId">
					<dict:fieldDescriptor>
						<dict:name>includes relation parent LO id</dict:name>
						<dict:desc>the parent lo id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="includes.loLoRelation.relatedLoId" key="relatedLoId">
					<dict:fieldDescriptor>
						<dict:name>includes relation child LO id</dict:name>
						<dict:desc>the child lo id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="includes.loLoRelation.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>includes relation effective date</dict:name>
						<dict:desc>the effective date of the lo reation</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="includes.loLoRelation.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>includes relation expiration date</dict:name>
						<dict:desc>the expiration date of the relation</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="includes.loLoRelation.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>includes relation attributes</dict:name>
						<dict:desc>attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="includes.loLoRelation.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>includes relation meta info</dict:name>
						<dict:desc>meta info</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="includes.loLoRelation.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>includes relationship meta versionInd</dict:name>
												<dict:desc>includes relationship meta versionInd</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="includes.loLoRelation.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>includes relationship meta createTime</dict:name>
												<dict:desc>includes relationship meta createTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="includes.loLoRelation.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>includes relationship meta createId</dict:name>
												<dict:desc>includes relationship meta createId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="includes.loLoRelation.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>includes relationship meta updateTime</dict:name>
												<dict:desc>includes relationship meta updateTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="includes.loLoRelation.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>includes relationship meta updateId</dict:name>
												<dict:desc>includes relationship meta updateId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="includes.loLoRelation.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>includes relation type</dict:name>
						<dict:desc>the type of the relation</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="lo.lo.relation.types"/>
							<dict:constraintRef bean="hard.coded.lolorealtion.includes"/>
							<dict:constraintRef bean="read.only"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="includes.loLoRelation.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>includes relation state</dict:name>
						<dict:desc>the state of the relation</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="includes.loLoRelation.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>includes relation internal id</dict:name>
						<dict:desc>the internal id of the lo-lo relation</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="active">
			<!-- Lo is active -->
			<!-- TODO: add to simple spec -->
				<dict:fieldRef bean="includes.loLoRelation.loId"/>
				<dict:fieldRef bean="includes.loLoRelation.relatedLoId"/>
				<dict:fieldRef bean="includes.loLoRelation.effectiveDate"/>
				<dict:fieldRef bean="includes.loLoRelation.expirationDate"/>
				<dict:fieldRef bean="includes.loLoRelation.attributes"/>
				<dict:fieldRef bean="includes.loLoRelation.metaInfo"/>
				<dict:fieldRef bean="includes.loLoRelation.type"/>
				<dict:fieldRef bean="includes.loLoRelation.state"/>
				<dict:fieldRef bean="includes.loLoRelation.internal.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- Lo is inactive -->
			<!-- TODO: add to simple spec -->
				<dict:fieldRef bean="includes.loLoRelation.loId"/>
				<dict:fieldRef bean="includes.loLoRelation.relatedLoId"/>
				<dict:fieldRef bean="includes.loLoRelation.effectiveDate"/>
				<dict:fieldRef bean="includes.loLoRelation.expirationDate"/>
				<dict:fieldRef bean="includes.loLoRelation.attributes"/>
				<dict:fieldRef bean="includes.loLoRelation.metaInfo"/>
				<dict:fieldRef bean="includes.loLoRelation.type"/>
				<dict:fieldRef bean="includes.loLoRelation.state"/>
				<dict:fieldRef bean="includes.loLoRelation.internal.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key="org.kuali.student.lum.lo.dto.LoCategoryInfo">
		<!-- Detailed information about a learning objective category. -->
		<dict:type key="kuali.lo.category.type.unclassified">
		<!-- A miscellaneous type of categories -->
		<!-- KRU -->
			<dict:state key="inactive">
			<!-- Lo Category is inactive -->
			<!-- KS -->
				
				<dict:field id="unclassified.lo.category.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>unclassfied lo category name</dict:name>
						<dict:desc>category name for the unclassified lo category types</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="unclassified.lo.category.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>unclassified lo category description</dict:name>
						<dict:desc>the description of the category</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="unclassified.lo.category.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>unclassified lo category desc plain text</dict:name>
												<dict:desc>unclassified lo category desc plain text</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="unclassified.lo.category.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>unclassified lo category desc formatted</dict:name>
												<dict:desc>unclassified lo category desc formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="unclassified.lo.category.loRepository" key="loRepository">
					<dict:fieldDescriptor>
						<dict:name>unclassified lo category repository</dict:name>
						<dict:desc>the lo repository to which the lo category belongs</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="lo.hierarchy.types"/>
							<dict:constraintRef bean="hard.coded.singleUse.lo.repository"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="unclassified.lo.category.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>unclassified lo category effective date</dict:name>
						<dict:desc>the effective date of the lo category</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="unclassified.lo.category.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>unclassified lo category expiration date</dict:name>
						<dict:desc>the expiration date of the lo category</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="unclassified.lo.category.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>unclassified lo category attributes</dict:name>
						<dict:desc>attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="unclassified.lo.category.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>unclassified lo category meta into</dict:name>
						<dict:desc>meta info</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="unclassified.lo.category.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>unclassified lo category meta versionInd</dict:name>
												<dict:desc>unclassified lo category meta versionInd</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="unclassified.lo.category.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>unclassified lo category  meta createTime</dict:name>
												<dict:desc>unclassified lo category meta createTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="unclassified.lo.category.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>unclassified lo category meta createId</dict:name>
												<dict:desc>unclassified lo category meta createId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="unclassified.lo.category.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>unclassified lo category meta updateTime</dict:name>
												<dict:desc>unclassified lo category meta updateTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="unclassified.lo.category.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>unclassified lo category meta updateId</dict:name>
												<dict:desc>unclassified lo category meta updateId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="unclassified.lo.category.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>type</dict:name>
						<dict:desc>the type of the lo category</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="hard.coded.unclassified.lo.category"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="unclassified.lo.category.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>unclassified lo category state</dict:name>
						<dict:desc>the state of the lo category</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="unclassified.lo.category.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>unclassified lo category id</dict:name>
						<dict:desc>the id of the lo category</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="active">
			<!-- Lo Category is active -->
			<!-- KS -->
				<dict:fieldRef bean="unclassified.lo.category.name"/>
				<dict:fieldRef bean="unclassified.lo.category.desc"/>
				<dict:fieldRef bean="unclassified.lo.category.loRepository"/>
				<dict:fieldRef bean="unclassified.lo.category.effectiveDate"/>
				<dict:fieldRef bean="unclassified.lo.category.expirationDate"/>
				<dict:fieldRef bean="unclassified.lo.category.attributes"/>
				<dict:fieldRef bean="unclassified.lo.category.metaInfo"/>
				<dict:fieldRef bean="unclassified.lo.category.type"/>
				<dict:fieldRef bean="unclassified.lo.category.state"/>
				<dict:fieldRef bean="unclassified.lo.category.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.lo.category.type.accreditation">
		<!-- Categories that are specific to or defined by an accreditation body -->
		<!-- KRU -->
			<dict:state key="inactive">
			<!-- Lo Category is inactive -->
			<!-- KS -->
				
				<dict:field id="accreditation.lo.category.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>accreditation lo category name</dict:name>
						<dict:desc>category name for the unclassified lo category types</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="accreditation.lo.category.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>accreditation lo category description</dict:name>
						<dict:desc>the description of the category</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="accreditation.lo.category.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>accreditation lo category desc plain text</dict:name>
												<dict:desc>unclassified lo category desc plain text</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="accreditation.lo.category.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>accreditation lo category desc formatted</dict:name>
												<dict:desc>unclassified lo category desc formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="accreditation.lo.category.loRepository" key="loRepository">
					<dict:fieldDescriptor>
						<dict:name>accreditation lo category repository</dict:name>
						<dict:desc>the lo repository to which the lo category belongs</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="lo.hierarchy.types"/>
							<dict:constraintRef bean="hard.coded.singleUse.lo.repository"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="accreditation.lo.category.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>accreditation lo category effective date</dict:name>
						<dict:desc>the effective date of the lo category</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="accreditation.lo.category.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>accreditation lo category expiration date</dict:name>
						<dict:desc>the expiration date of the lo category</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="accreditation.lo.category.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>accreditation lo category attributes</dict:name>
						<dict:desc>attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="accreditation.lo.category.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>accreditation lo category meta into</dict:name>
						<dict:desc>meta info</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="accreditation.lo.category.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>accreditation lo category meta versionInd</dict:name>
												<dict:desc>accreditation lo category meta versionInd</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="accreditation.lo.category.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>accreditation lo category meta createTime</dict:name>
												<dict:desc>accreditation lo category meta createTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="accreditation.lo.category.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>accreditation lo category meta createId</dict:name>
												<dict:desc>accreditation lo category  meta createId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="accreditation.lo.category.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>accreditation lo category meta updateTime</dict:name>
												<dict:desc>accreditation lo category meta updateTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="accreditation.lo.category.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>accreditation lo category meta updateId</dict:name>
												<dict:desc>accreditation lo category meta updateId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="accreditation.lo.category.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>type</dict:name>
						<dict:desc>the type of the lo category</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="hard.coded.accreditation.lo.category"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="accreditation.lo.category.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>accreditation lo category state</dict:name>
						<dict:desc>the state of the lo category</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="accreditation.lo.category.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>accreditation lo category id</dict:name>
						<dict:desc>the id of the lo category</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="active">
			<!-- Lo Category is active -->
			<!-- KS -->
				<dict:fieldRef bean="accreditation.lo.category.name"/>
				<dict:fieldRef bean="accreditation.lo.category.desc"/>
				<dict:fieldRef bean="accreditation.lo.category.loRepository"/>
				<dict:fieldRef bean="accreditation.lo.category.effectiveDate"/>
				<dict:fieldRef bean="accreditation.lo.category.expirationDate"/>
				<dict:fieldRef bean="accreditation.lo.category.attributes"/>
				<dict:fieldRef bean="accreditation.lo.category.metaInfo"/>
				<dict:fieldRef bean="accreditation.lo.category.type"/>
				<dict:fieldRef bean="accreditation.lo.category.state"/>
				<dict:fieldRef bean="accreditation.lo.category.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.lo.category.type.skill">
		<!-- Categories that are representative of skill sets -->
		<!-- KRU -->
			<dict:state key="inactive">
			<!-- Lo Category is inactive -->
			<!-- KS -->
				
				<dict:field id="skill.lo.category.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>skill lo category name</dict:name>
						<dict:desc>category name for the unclassified lo category types</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="skill.lo.category.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>skill lo category description</dict:name>
						<dict:desc>the description of the category</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="skill.lo.category.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>skill lo category desc plain text</dict:name>
												<dict:desc>unclassified lo category desc plain text</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="skill.lo.category.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>skill lo category desc formatted</dict:name>
												<dict:desc>unclassified lo category desc formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="skill.lo.category.loRepository" key="loRepository">
					<dict:fieldDescriptor>
						<dict:name>skill lo category repository</dict:name>
						<dict:desc>the lo repository to which the lo category belongs</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="lo.hierarchy.types"/>
							<dict:constraintRef bean="hard.coded.singleUse.lo.repository"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="skill.lo.category.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>skill lo category effective date</dict:name>
						<dict:desc>the effective date of the lo category</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="skill.lo.category.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>skill lo category expiration date</dict:name>
						<dict:desc>the expiration date of the lo category</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="skill.lo.category.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>skill lo category attributes</dict:name>
						<dict:desc>attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="skill.lo.category.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>skill lo category meta into</dict:name>
						<dict:desc>meta info</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="skill.lo.category.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>skill lo category meta versionInd</dict:name>
												<dict:desc>skill lo category meta versionInd</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="skill.lo.category.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>skill lo category meta createTime</dict:name>
												<dict:desc>skill lo category meta createTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="skill.lo.category.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>skill lo category meta createId</dict:name>
												<dict:desc>skill lo category  meta createId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="skill.lo.category.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>skill lo category meta updateTime</dict:name>
												<dict:desc>skill lo category meta updateTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="skill.lo.category.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>skill lo category meta updateId</dict:name>
												<dict:desc>skill lo category meta updateId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="skill.lo.category.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>type</dict:name>
						<dict:desc>the type of the lo category</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="hard.coded.skill.lo.category"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="skill.lo.category.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>skill lo category state</dict:name>
						<dict:desc>the state of the lo category</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="skill.lo.category.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>skill lo category id</dict:name>
						<dict:desc>the id of the lo category</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="active">
			<!-- Lo Category is active -->
			<!-- KS -->
				<dict:fieldRef bean="skill.lo.category.name"/>
				<dict:fieldRef bean="skill.lo.category.desc"/>
				<dict:fieldRef bean="skill.lo.category.loRepository"/>
				<dict:fieldRef bean="skill.lo.category.effectiveDate"/>
				<dict:fieldRef bean="skill.lo.category.expirationDate"/>
				<dict:fieldRef bean="skill.lo.category.attributes"/>
				<dict:fieldRef bean="skill.lo.category.metaInfo"/>
				<dict:fieldRef bean="skill.lo.category.type"/>
				<dict:fieldRef bean="skill.lo.category.state"/>
				<dict:fieldRef bean="skill.lo.category.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.lo.category.type.subject">
		<!-- Categories that are representative of content areas -->
		<!-- KRU -->
			<dict:state key="inactive">
			<!-- Lo Category is inactive -->
			<!-- KS -->
				
				<dict:field id="subject.lo.category.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>subject lo category name</dict:name>
						<dict:desc>category name for the unclassified lo category types</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="subject.lo.category.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>subject lo category description</dict:name>
						<dict:desc>the description of the category</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="subject.lo.category.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>subject lo category desc plain text</dict:name>
												<dict:desc>unclassified lo category desc plain text</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="subject.lo.category.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>subject lo category desc formatted</dict:name>
												<dict:desc>unclassified lo category desc formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="subject.lo.category.loRepository" key="loRepository">
					<dict:fieldDescriptor>
						<dict:name>subject lo category repository</dict:name>
						<dict:desc>the lo repository to which the lo category belongs</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="lo.hierarchy.types"/>
							<dict:constraintRef bean="hard.coded.singleUse.lo.repository"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="subject.lo.category.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>subject lo category effective date</dict:name>
						<dict:desc>the effective date of the lo category</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="subject.lo.category.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>subject lo category expiration date</dict:name>
						<dict:desc>the expiration date of the lo category</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="subject.lo.category.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>subject lo category attributes</dict:name>
						<dict:desc>attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="subject.lo.category.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>subject lo category meta into</dict:name>
						<dict:desc>meta info</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="subject.lo.category.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>subject lo category meta versionInd</dict:name>
												<dict:desc>subject lo category meta versionInd</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="subject.lo.category.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>subject lo category meta createTime</dict:name>
												<dict:desc>subject lo category meta createTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="subject.lo.category.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>subject lo category meta createId</dict:name>
												<dict:desc>subject lo category  meta createId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="subject.lo.category.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>subject lo category meta updateTime</dict:name>
												<dict:desc>subject lo category meta updateTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="subject.lo.category.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>subject lo category meta updateId</dict:name>
												<dict:desc>subject lo category meta updateId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="subject.lo.category.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>type</dict:name>
						<dict:desc>the type of the lo category</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="hard.coded.subject.lo.category"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="subject.lo.category.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>subject lo category state</dict:name>
						<dict:desc>the state of the lo category</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="subject.lo.category.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>subject lo category id</dict:name>
						<dict:desc>the id of the lo category</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="active">
			<!-- Lo Category is active -->
			<!-- KS -->
				<dict:fieldRef bean="subject.lo.category.name"/>
				<dict:fieldRef bean="subject.lo.category.desc"/>
				<dict:fieldRef bean="subject.lo.category.loRepository"/>
				<dict:fieldRef bean="subject.lo.category.effectiveDate"/>
				<dict:fieldRef bean="subject.lo.category.expirationDate"/>
				<dict:fieldRef bean="subject.lo.category.attributes"/>
				<dict:fieldRef bean="subject.lo.category.metaInfo"/>
				<dict:fieldRef bean="subject.lo.category.type"/>
				<dict:fieldRef bean="subject.lo.category.state"/>
				<dict:fieldRef bean="subject.lo.category.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key="org.kuali.student.lum.lrc.dto.CreditInfo">
		<!-- Detailed information about a credit value. -->
		<dict:type key="kuali.creditType.credit.degree">
		<!-- College level credit that can typically be applied by a student to complete a degree -->
			<dict:state key="(n/a)">
			<!-- Not applicable -->
				
				<dict:field id="academic.credit.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>academic credit name</dict:name>
						<dict:desc>Name of this credit. This may have a direct relation to the combination of value and type fields.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="academic.credit.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>academic credit desc</dict:name>
						<dict:desc>Description of this credit.</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="academic.credit.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>academic.credit.desc.plain</dict:name>
												<dict:desc>academic.credit.desc.plain</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="academic.credit.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>academic.credit.desc.formatted</dict:name>
												<dict:desc>academic.credit.desc.formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="academic.credit.value" key="value">
					<dict:fieldDescriptor>
						<dict:name>academic credit value</dict:name>
						<dict:desc>The number of the credits. This is typically numeric, but string is used to cover cases such as fractional and unbounded.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
							<dict:constraintRef bean="integer"/>
							<dict:constraint key="in-line.constraint.for.dictionary.academic.credit.value">
								<dict:minValue>1</dict:minValue>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="academic.credit.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>academic credit effective date</dict:name>
						<dict:desc>Date and time that this credit value became effective. This is a similar concept to the effective date on enumerated values. When an expiration date has been specified, this field must be less than or equal to the expiration date.</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="academic.credit.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>academic credit expiration date</dict:name>
						<dict:desc>Date and time that this credit value expires. This is a similar concept to the expiration date on enumerated values. If specified, this should be greater than or equal to the effective date. If this field is not specified, then no expiration date has been currently defined and should automatically be considered greater than the effective date.</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="academic.credit.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>academic credit attributes</dict:name>
						<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="academic.credit.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>academic credit type</dict:name>
						<dict:desc>Unique identifier for a credit type.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="hard.coded.academic.credit"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="academic.credit.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>academic credit internal id</dict:name>
						<dict:desc>Unique identifier for a credit value.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key="org.kuali.student.lum.lrc.dto.GradeInfo">
		<!-- Detailed information about a grade value. -->
		<dict:type key="kuali.gradeType.Letter">
		<!-- A Letter used as a grade (e.g. A, B, C, D, F) -->
		<!-- TO DO: add to Simples -->
			<dict:state key="(n/a)">
			<!-- Not applicable -->
				
				<dict:field id="letter.grade.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>letter grade name</dict:name>
						<dict:desc>The name of the letter grade</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="letter.grade.value" key="value">
					<dict:fieldDescriptor>
						<dict:name>letter grade value</dict:name>
						<dict:desc>the value of the letter grade</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="code"/>
							<dict:constraint key="in-line.constraint.for.dictionary.letter.grade.value">
								<dict:minLength>1</dict:minLength>
								<dict:maxLength>10</dict:maxLength>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="letter.grade.scaleKey" key="scaleKey">
					<dict:fieldDescriptor>
						<dict:name>letter grade scaleKey</dict:name>
						<dict:desc>Identifier of the scale for this letter grade value.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="grade.scales"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="letter.grade.rank" key="rank">
					<dict:fieldDescriptor>
						<dict:name>letter grade rank</dict:name>
						<dict:desc>Rank of the letter grade value within the scale.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="letter.grade.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>letter grade effectiveDate</dict:name>
						<dict:desc>Date and time that this letter grade value became effective. T</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="letter.grade.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>letter grade expirationDate</dict:name>
						<dict:desc>Date and time that this letter grade value expires.</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="letter.grade.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>letter grade attributes</dict:name>
						<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="letter.grade.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>letter grade type</dict:name>
						<dict:desc>Unique identifier for the letter grade type.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="hard.coded.letter.grade"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="letter.grade.key" key="key">
					<dict:fieldDescriptor>
						<dict:name>letter grade key</dict:name>
						<dict:desc>Unique identifier for a letter grade</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.key"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.gradeType.Pass-Fail">
		<!-- Pass or Fail -->
		<!-- TO DO: add to Simples -->
			<dict:state key="(n/a)">
			<!-- Not applicable -->
				
				<dict:field id="pass-fail.grade.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>pass-fail grade name</dict:name>
						<dict:desc>The name of the pass-fail grade</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="pass-fail.grade.value" key="value">
					<dict:fieldDescriptor>
						<dict:name>pass-fail grade value</dict:name>
						<dict:desc>the value of the pass-fail grade</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="code"/>
							<dict:constraint key="in-line.constraint.for.dictionary.pass-fail.grade.value">
								<dict:minLength>1</dict:minLength>
								<dict:maxLength>10</dict:maxLength>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="pass-fail.grade.scaleKey" key="scaleKey">
					<dict:fieldDescriptor>
						<dict:name>pass-fail grade scaleKey</dict:name>
						<dict:desc>Identifier of the scale for this pass-fail grade value.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="grade.scales"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="pass-fail.grade.rank" key="rank">
					<dict:fieldDescriptor>
						<dict:name>pass-fail grade rank</dict:name>
						<dict:desc>Rank of the pass-fail grade value within the scale.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="pass-fail.grade.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>pass-fail grade effectiveDate</dict:name>
						<dict:desc>Date and time that this pass-fail grade value became effective. T</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="pass-fail.grade.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>pass-fail grade expirationDate</dict:name>
						<dict:desc>Date and time that this pass-fail grade value expires.</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="pass-fail.grade.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>pass-fail grade attributes</dict:name>
						<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="pass-fail.grade.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>pass-fail grade type</dict:name>
						<dict:desc>Unique identifier for the pass-fail grade type.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="hard.coded.pass-fail.grade"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="pass-fail.grade.key" key="key">
					<dict:fieldDescriptor>
						<dict:name>pass-fail grade key</dict:name>
						<dict:desc>Unique identifier for a pass-fail grade</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.key"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.gradeType.Qualitative">
		<!-- A qualitative grade type -->
		<!-- TO DO: add to Simples -->
			<dict:state key="(n/a)">
			<!-- Not applicable -->
				
				<dict:field id="qualitative.grade.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>qualitative grade name</dict:name>
						<dict:desc>The name of the qualitative grade</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="qualitative.grade.value" key="value">
					<dict:fieldDescriptor>
						<dict:name>qualitative grade value</dict:name>
						<dict:desc>the value of the qualitative grade</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="code"/>
							<dict:constraint key="in-line.constraint.for.dictionary.qualitative.grade.value">
								<dict:minLength>1</dict:minLength>
								<dict:maxLength>10</dict:maxLength>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="qualitative.grade.scaleKey" key="scaleKey">
					<dict:fieldDescriptor>
						<dict:name>qualitative grade scaleKey</dict:name>
						<dict:desc>Identifier of the scale for this qualitative grade value.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="grade.scales"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="qualitative.grade.rank" key="rank">
					<dict:fieldDescriptor>
						<dict:name>qualitative grade rank</dict:name>
						<dict:desc>Rank of the qualitative grade value within the scale.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="qualitative.grade.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>qualitative grade effectiveDate</dict:name>
						<dict:desc>Date and time that this qualitative grade value became effective. T</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="qualitative.grade.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>qualitative grade expirationDate</dict:name>
						<dict:desc>Date and time that this qualitative grade value expires.</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="qualitative.grade.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>qualitative grade attributes</dict:name>
						<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="qualitative.grade.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>qualitative grade type</dict:name>
						<dict:desc>Unique identifier for the qualitative grade type.</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="hard.coded.pass-fail.grade"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="qualitative.grade.key" key="key">
					<dict:fieldDescriptor>
						<dict:name>qualitative grade key</dict:name>
						<dict:desc>Unique identifier for a qualitative grade</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.key"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key="org.kuali.student.lum.lrc.dto.ResultComponentInfo">
		<!-- Detailed information about a result component. -->
		<dict:type key="kuali.resultComponentType.credit.degree.fixed">
		<!-- This records a single fixed number of credits that are awarded if the student passes the course. -->
		<!-- TO DO: Fix Simples name -->
			<dict:state key="active">
			<!-- resultComponent is active -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				
				<dict:field id="fixed.credits.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>fixed credits name</dict:name>
						<dict:desc>fixed credits name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="fixed.credits.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>fixed credits desc</dict:name>
						<dict:desc>fixed credits desc</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="fixed.credits.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>fixed.credits.desc.plain</dict:name>
												<dict:desc>fixed.credits.desc.plain</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="fixed.credits.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>fixed.credits.desc.formatted</dict:name>
												<dict:desc>fixed.credits.desc.formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="fixed.credits.resultValueIds" key="resultValueIds">
					<dict:fieldDescriptor>
						<dict:name>fixed credits result value Ids</dict:name>
						<dict:desc>the list of ids correspondign to the available credits values for fixed credit</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.resultValueId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="fixed.credits.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>fixed credits effective date</dict:name>
						<dict:desc>fixed credits effective date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="fixed.credits.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>fixed credits expiration date</dict:name>
						<dict:desc>fixed credits expiration date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="fixed.credits.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>fixed credits attributes</dict:name>
						<dict:desc>fixed credits attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="fixed.credits.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>fixed credits metainfo</dict:name>
						<dict:desc>fixed credits metainfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="fixed.credits.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>fixed credits meta versionInd</dict:name>
												<dict:desc>Version number for this resultComponent info</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="fixed.credits.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>fixed credits meta createTime</dict:name>
												<dict:desc>Date-time this resultComponent was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="fixed.credits.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>fixed credits meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this resultComponent</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="fixed.credits.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>fixed credits meta updateTime</dict:name>
												<dict:desc>Date-time this resultComponent was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="fixed.credits.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>fixed credits meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this resultComponent</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="fixed.credits.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>fixed credits type</dict:name>
						<dict:desc>fixed credits type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="hard.coded.fixed.credit"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="fixed.credits.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>fixed credits state</dict:name>
						<dict:desc>fixed credits state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="fixed.credits.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>fixed credits internal id</dict:name>
						<dict:desc>fixed credits internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="inactive">
			<!-- resultComponent is inactive -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				<dict:fieldRef bean="fixed.credits.name"/>
				<dict:fieldRef bean="fixed.credits.desc"/>
				<dict:fieldRef bean="fixed.credits.resultValueIds"/>
				<dict:fieldRef bean="fixed.credits.effectiveDate"/>
				<dict:fieldRef bean="fixed.credits.expirationDate"/>
				<dict:fieldRef bean="fixed.credits.attributes"/>
				<dict:fieldRef bean="fixed.credits.metaInfo"/>
				<dict:fieldRef bean="fixed.credits.type"/>
				<dict:fieldRef bean="fixed.credits.state"/>
				<dict:fieldRef bean="fixed.credits.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.resultComponentType.credit.degree.range">
		<!-- This records a range of number of credits that can be awarded for this course. -->
		<!-- TO DO: Fix Simples name -->
			<dict:state key="active">
			<!-- resultComponent is active -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				
				<dict:field id="variable.credits.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>variable credits name</dict:name>
						<dict:desc>variable credits name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="variable.credits.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>variable credits desc</dict:name>
						<dict:desc>variable credits desc</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="variable.credits.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>variable.credits.desc.plain</dict:name>
												<dict:desc>variable.credits.desc.plain</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="variable.credits.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>variable.credits.desc.formatted</dict:name>
												<dict:desc>variable.credits.desc.formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="variable.credits.resultValueIds" key="resultValueIds">
					<dict:fieldDescriptor>
						<dict:name>variable credits result value Ids</dict:name>
						<dict:desc>the list of ids correspondign to the available credits values for variable credit</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.resultValueId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="variable.credits.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>variable credits effective date</dict:name>
						<dict:desc>variable credits effective date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="variable.credits.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>variable credits expiration date</dict:name>
						<dict:desc>variable credits expiration date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="variable.credits.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>variable credits attributes</dict:name>
						<dict:desc>variable credits attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="variable.credits.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>variable credits metainfo</dict:name>
						<dict:desc>variable credits metainfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="variable.credits.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>variable credits meta versionInd</dict:name>
												<dict:desc>Version number for this resultComponent info</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="variable.credits.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>variable credits meta createTime</dict:name>
												<dict:desc>Date-time this resultComponent was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="variable.credits.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>variable credits meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this resultComponent</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="variable.credits.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>variable credits meta updateTime</dict:name>
												<dict:desc>Date-time this resultComponent was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="variable.credits.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>variable credits meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this resultComponent</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="variable.credits.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>variable credits type</dict:name>
						<dict:desc>variable credits type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="hard.coded.variable.credit"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="variable.credits.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>variable credits state</dict:name>
						<dict:desc>variable credits state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="variable.credits.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>variable credits internal id</dict:name>
						<dict:desc>variable credits internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="inactive">
			<!-- resultComponent is inactive -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				<dict:fieldRef bean="variable.credits.name"/>
				<dict:fieldRef bean="variable.credits.desc"/>
				<dict:fieldRef bean="variable.credits.resultValueIds"/>
				<dict:fieldRef bean="variable.credits.effectiveDate"/>
				<dict:fieldRef bean="variable.credits.expirationDate"/>
				<dict:fieldRef bean="variable.credits.attributes"/>
				<dict:fieldRef bean="variable.credits.metaInfo"/>
				<dict:fieldRef bean="variable.credits.type"/>
				<dict:fieldRef bean="variable.credits.state"/>
				<dict:fieldRef bean="variable.credits.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.resultComponentType.finalGrade">
		<!-- This records that a final grade is a result for this course -->
		<!-- TO DO: add to Simples -->
			<dict:state key="active">
			<!-- resultComponent is active -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				
				<dict:field id="final.grades.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>final grade name</dict:name>
						<dict:desc>final grade name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.grades.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>final grade desc</dict:name>
						<dict:desc>final grade desc</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="final.grades.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>final.grades.desc.plain</dict:name>
												<dict:desc>final.grades.desc.plain</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.grades.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>final.grades.desc.formatted</dict:name>
												<dict:desc>final.grades.desc.formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.grades.resultValueIds" key="resultValueIds">
					<dict:fieldDescriptor>
						<dict:name>final grade result value Ids</dict:name>
						<dict:desc>the list of ids correspondign to the available credits values for fixed credit</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.resultValueId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.grades.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>final grade effective date</dict:name>
						<dict:desc>final grade effective date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.grades.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>final grade expiration date</dict:name>
						<dict:desc>final grade expiration date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.grades.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>final grade attributes</dict:name>
						<dict:desc>final grade attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.grades.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>final grade metainfo</dict:name>
						<dict:desc>final grade metainfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="final.grades.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>final grade meta versionInd</dict:name>
												<dict:desc>Version number for this resultComponent info</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.grades.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>final grade meta createTime</dict:name>
												<dict:desc>Date-time this resultComponent was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.grades.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>final grade meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this resultComponent</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.grades.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>final grade meta updateTime</dict:name>
												<dict:desc>Date-time this resultComponent was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.grades.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>final grade meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this resultComponent</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.grades.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>final grade type</dict:name>
						<dict:desc>final grade type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="hard.coded.final.grade"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.grades.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>final grade state</dict:name>
						<dict:desc>final grade state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="final.grades.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>final grade internal id</dict:name>
						<dict:desc>final grade internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="inactive">
			<!-- resultComponent is inactive -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				<dict:fieldRef bean="final.grades.name"/>
				<dict:fieldRef bean="final.grades.desc"/>
				<dict:fieldRef bean="final.grades.resultValueIds"/>
				<dict:fieldRef bean="final.grades.effectiveDate"/>
				<dict:fieldRef bean="final.grades.expirationDate"/>
				<dict:fieldRef bean="final.grades.attributes"/>
				<dict:fieldRef bean="final.grades.metaInfo"/>
				<dict:fieldRef bean="final.grades.type"/>
				<dict:fieldRef bean="final.grades.state"/>
				<dict:fieldRef bean="final.grades.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.resultComponentType.finalQualitative">
		<!-- This records that a Qualitative assessment is possible for this course -->
		<!-- TO DO: add to Simples -->
			<dict:state key="active">
			<!-- resultComponent is active -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				
				<dict:field id="final.qualitative.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>final qualitative name</dict:name>
						<dict:desc>final grade name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.qualitative.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>final qualitative desc</dict:name>
						<dict:desc>final grade desc</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="final.qualitative.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>final.qualitative.desc.plain</dict:name>
												<dict:desc>final.grades.desc.plain</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.qualitative.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>final.qualitative.desc.formatted</dict:name>
												<dict:desc>final.grades.desc.formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.qualitative.resultValueIds" key="resultValueIds">
					<dict:fieldDescriptor>
						<dict:name>final qualitative result value Ids</dict:name>
						<dict:desc>the list of ids correspondign to the available credits values for fixed credit</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.resultValueId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.qualitative.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>final qualitative effective date</dict:name>
						<dict:desc>final grade effective date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.qualitative.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>final qualitative expiration date</dict:name>
						<dict:desc>final grade expiration date</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.qualitative.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>final qualitative attributes</dict:name>
						<dict:desc>final grade attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.qualitative.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>final qualitative metainfo</dict:name>
						<dict:desc>final grade metainfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="final.qualitative.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>final qualitative meta versionInd</dict:name>
												<dict:desc>Version number for this resultComponent info</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.qualitative.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>final qualitative meta createTime</dict:name>
												<dict:desc>Date-time this resultComponent was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.qualitative.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>final qualitative meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this resultComponent</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.qualitative.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>final qualitative meta updateTime</dict:name>
												<dict:desc>Date-time this resultComponent was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="final.qualitative.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>final qualitative meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this resultComponent</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.qualitative.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>final qualitative type</dict:name>
						<dict:desc>final grade type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="hard.coded.final.qualitative"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="final.qualitative.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>final qualitative state</dict:name>
						<dict:desc>final grade state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="final.qualitative.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>final qualitative internal id</dict:name>
						<dict:desc>final grade internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="inactive">
			<!-- resultComponent is inactive -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				<dict:fieldRef bean="final.qualitative.name"/>
				<dict:fieldRef bean="final.qualitative.desc"/>
				<dict:fieldRef bean="final.qualitative.resultValueIds"/>
				<dict:fieldRef bean="final.qualitative.effectiveDate"/>
				<dict:fieldRef bean="final.qualitative.expirationDate"/>
				<dict:fieldRef bean="final.qualitative.attributes"/>
				<dict:fieldRef bean="final.qualitative.metaInfo"/>
				<dict:fieldRef bean="final.qualitative.type"/>
				<dict:fieldRef bean="final.qualitative.state"/>
				<dict:fieldRef bean="final.qualitative.internal.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key="org.kuali.student.lum.lu.dto.LuStatementInfo">
		<!-- Detailed information about a single LU statement. -->
		<dict:type key="kuali.luStatementType.req.corequisite">
		<!-- Rules that describe the need for concurrent enrollment in two courses. -->
			<dict:state key="active">
			<!-- Statement is active -->
			<!-- TODO: Add to simple spec -->
				
				<dict:field id="requisite.statement.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>requisite statement name</dict:name>
						<dict:desc>requisite statement name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.statement.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>requisite statement desc</dict:name>
						<dict:desc>requisite statement desc</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="requisite.statement.desc.plain" key="plain">
											<!-- calculated by stripping out formatting -->
											<dict:fieldDescriptor>
												<dict:name>requisite statement desc plain</dict:name>
												<dict:desc>requisite statement desc plain</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.requisite.statement.desc.plain">
														<dict:maxLength>14000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="requisite.statement.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>requisite statement desc formatted</dict:name>
												<dict:desc>requisite statement desc formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.requisite.statement.desc.formatted">
														<dict:maxLength>14000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.statement.operator" key="operator">
					<dict:fieldDescriptor>
						<dict:name>requisite statement operator</dict:name>
						<dict:desc>requisite statement operator</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="code"/>
							<dict:constraintRef bean="lu.statement.operators"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.statement.sub.statements" key="luStatementIds">
					<!-- services has both statement ids and requirement component ids as required but this can't be true.  What is required is that either a statement or requirement component is required so there is a cross field constraint but not both -->
					<dict:fieldDescriptor>
						<dict:name>requisite statement sub statements</dict:name>
						<dict:desc>requisite statement sub statements</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.luStatementd"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.statement.components" key="reqComponentIds">
					<!-- services has both statement ids and requirement component ids as required but this can't be true.  What is required is that either a statement or requirement component is required so there is a cross field constraint but not both -->
					<dict:fieldDescriptor>
						<dict:name>requisite statement components</dict:name>
						<dict:desc>requisite statement components</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.requirementComponentId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.statement.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>requisite statement attributes</dict:name>
						<dict:desc>requisite statement attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.statement.metainfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>requisite statement metainfo</dict:name>
						<dict:desc>requisite statement metainfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="requisite.statement.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>requisite statement meta versionInd</dict:name>
												<dict:desc>requisite statement meta versionInd</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="requisite.statement.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>requisite statement meta createTime</dict:name>
												<dict:desc>requisite statement meta createTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="requisite.statement.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>requisite statement meta createId</dict:name>
												<dict:desc>requisite statement meta createId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="requisite.statement.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>requisite statement meta updateTime</dict:name>
												<dict:desc>requisite statement meta updateTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="requisite.statement.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>requisite statement meta updateId</dict:name>
												<dict:desc>requisite statement meta updateId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.statement.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>requisite statement type</dict:name>
						<dict:desc>requisite statement type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="lu.statement.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.statement.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>requisite statement state</dict:name>
						<dict:desc>requisite statement state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
							<dict:constraintRef bean="lu.statement.states"/>
							<dict:constraintRef bean="hard.coded.active"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.statement.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>requisite statement id</dict:name>
						<dict:desc>requisite statement id</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="inactive">
			<!-- Statement is inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.statement.name"/>
				<dict:fieldRef bean="requisite.statement.desc"/>
				<dict:fieldRef bean="requisite.statement.operator"/>
				<dict:fieldRef bean="requisite.statement.sub.statements"/>
				<dict:fieldRef bean="requisite.statement.components"/>
				<dict:fieldRef bean="requisite.statement.attributes"/>
				<dict:fieldRef bean="requisite.statement.metainfo"/>
				<dict:fieldRef bean="requisite.statement.type"/>
				<dict:fieldRef bean="requisite.statement.state"/>
				<dict:fieldRef bean="requisite.statement.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.luStatementType.req.antirequisite">
		<!-- Rules identifying a specific course or level of attainment which, if already successfully completed, does not permit registration for credit in another desired course, or which may not be taken for credit concurrently with another course -->
			<dict:state key="active">
			<!-- Statement is active -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.statement.name"/>
				<dict:fieldRef bean="requisite.statement.desc"/>
				<dict:fieldRef bean="requisite.statement.operator"/>
				<dict:fieldRef bean="requisite.statement.sub.statements"/>
				<dict:fieldRef bean="requisite.statement.components"/>
				<dict:fieldRef bean="requisite.statement.attributes"/>
				<dict:fieldRef bean="requisite.statement.metainfo"/>
				<dict:fieldRef bean="requisite.statement.type"/>
				<dict:fieldRef bean="requisite.statement.state"/>
				<dict:fieldRef bean="requisite.statement.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- Statement is inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.statement.name"/>
				<dict:fieldRef bean="requisite.statement.desc"/>
				<dict:fieldRef bean="requisite.statement.operator"/>
				<dict:fieldRef bean="requisite.statement.sub.statements"/>
				<dict:fieldRef bean="requisite.statement.components"/>
				<dict:fieldRef bean="requisite.statement.attributes"/>
				<dict:fieldRef bean="requisite.statement.metainfo"/>
				<dict:fieldRef bean="requisite.statement.type"/>
				<dict:fieldRef bean="requisite.statement.state"/>
				<dict:fieldRef bean="requisite.statement.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.luStatementType.req.enrollmentRestriction">
		<!-- Rules other than perquisites that limit or restrict students from enrolling in a course that do not strictly deal with the student's academic ability to handle the material. -->
			<dict:state key="active">
			<!-- Statement is active -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.statement.name"/>
				<dict:fieldRef bean="requisite.statement.desc"/>
				<dict:fieldRef bean="requisite.statement.operator"/>
				<dict:fieldRef bean="requisite.statement.sub.statements"/>
				<dict:fieldRef bean="requisite.statement.components"/>
				<dict:fieldRef bean="requisite.statement.attributes"/>
				<dict:fieldRef bean="requisite.statement.metainfo"/>
				<dict:fieldRef bean="requisite.statement.type"/>
				<dict:fieldRef bean="requisite.statement.state"/>
				<dict:fieldRef bean="requisite.statement.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- Statement is inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.statement.name"/>
				<dict:fieldRef bean="requisite.statement.desc"/>
				<dict:fieldRef bean="requisite.statement.operator"/>
				<dict:fieldRef bean="requisite.statement.sub.statements"/>
				<dict:fieldRef bean="requisite.statement.components"/>
				<dict:fieldRef bean="requisite.statement.attributes"/>
				<dict:fieldRef bean="requisite.statement.metainfo"/>
				<dict:fieldRef bean="requisite.statement.type"/>
				<dict:fieldRef bean="requisite.statement.state"/>
				<dict:fieldRef bean="requisite.statement.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key="org.kuali.student.lum.lu.dto.ReqComponentInfo">
		<!-- Information about a requirement component. -->
		<dict:type key="kuali.reqCompType.requisite.courseList.coreq.all">
		<!-- Student must be enrolled in all of the following courses -->
			<dict:state key="active">
			<!-- requirement componenent is active -->
			<!-- TODO: Add to simple spec -->
				
				<dict:field id="requisite.req.component.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>requisite req component desc</dict:name>
						<dict:desc>requisite req component desc</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="requisite.req.component.desc.plain" key="plain">
											<!-- calculated by stripping out formatting -->
											<dict:fieldDescriptor>
												<dict:name>requisite.req.component.desc.plain</dict:name>
												<dict:desc>requisite.req.component.desc.plain</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.requisite.req.component.desc.plain">
														<dict:maxLength>14000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="requisite.req.component.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>requisite.req.component.desc.formatted</dict:name>
												<dict:desc>requisite.req.component.desc.formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.requisite.req.component.desc.formatted">
														<dict:maxLength>14000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.req.component.field.none.of.courses" key="reqCompField">
					<dict:fieldDescriptor>
						<dict:name>requisite req component field none of courses</dict:name>
						<dict:desc>requisite req component field none of courses</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.ReqCompFieldInfo">
								<!-- Detailed information about a requirement component field value. -->
								<dict:type key="kuali.reqCompFieldType.credit.course">
								<!-- An Id of a Clu of type Credit Course -->
								<!-- The value must be a cluId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="requisite.req.component.field.credit.course.cluId" key="value">
											<dict:fieldDescriptor>
												<dict:name>requisite req component field credit course cluId</dict:name>
												<dict:desc>requisite req component field credit course cluId</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="related.cluId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="requisite.req.component.field.credit.course.cluId.key" key="key">
											<dict:fieldDescriptor>
												<dict:name>requisite req component field credit course cluId key</dict:name>
												<dict:desc>requisite req component field credit course cluId key</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="lu.requirement.component.field.keys"/>
													<dict:constraintRef bean="hard.coded.credit.course.clu"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.credit.course.set">
								<!-- An Id of a Set of Credit Course Clus -->
								<!-- The value must be a cluSetId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="requisite.req.component.field.credit.course.cluSetId" key="value">
											<dict:fieldDescriptor>
												<dict:name>requisite req component field credit course cluSetId</dict:name>
												<dict:desc>requisite req component field credit course cluSetId</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="related.clu.set.id"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="requisite.req.component.field.credit.course.cluISetId.key" key="key">
											<dict:fieldDescriptor>
												<dict:name>requisite req component field credit course cluISetd key</dict:name>
												<dict:desc>requisite req component field credit course cluISetd key</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="lu.requirement.component.field.keys"/>
													<dict:constraintRef bean="hard.coded.credit.course.clu.set"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.requiredCount">
								<!-- A number to be compared to a count of clu's -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="requisite.req.component.field.required.count" key="value">
											<dict:fieldDescriptor>
												<dict:name>requisite req component field required count</dict:name>
												<dict:desc>requisite req component field required count</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="integer"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="requisite.req.component.field.required.count.key" key="key">
											<dict:fieldDescriptor>
												<dict:name>requisite req component field required count key</dict:name>
												<dict:desc>requisite req component field required count key</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="lu.requirement.component.field.keys"/>
													<dict:constraintRef bean="hard.coded.required.count"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.lrd.credit.course.final.grade">
								<!-- A credit course paired with a minimum grade -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="requisite.req.component.field.lrd.credit.course.final.grade.value" key="value">
											<dict:fieldDescriptor>
												<dict:name>requisite req component field lrd credit course final grade</dict:name>
												<dict:desc>requisite req component field lrd credit course final grade</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="related.lrd.Id"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="requisite.req.component.field.lrd.credit.course.final.grade.key" key="key">
											<dict:fieldDescriptor>
												<dict:name>requisite req component field lrd credit course final grade key</dict:name>
												<dict:desc>requisite req component field lrd credit course final grade key</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="lu.requirement.component.field.keys"/>
													<dict:constraintRef bean="hard.coded.lrd.credit.course.final.grade"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.gpa">
								<!-- GPA -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="requisite.req.component.field.gpa" key="value">
											<dict:fieldDescriptor>
												<dict:name>requisite req component field gpa</dict:name>
												<dict:desc>requisite req component field gpa</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="non.negative.decimal"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="requisite.req.component.field.gpa.key" key="key">
											<dict:fieldDescriptor>
												<dict:name>requisite req component field gpa key</dict:name>
												<dict:desc>requisite req component field gpa key</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="lu.requirement.component.field.keys"/>
													<dict:constraintRef bean="hard.coded.overall.gpa"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.totalCredits">
								<!-- Total Credits -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="requisite.req.component.field.total.credits" key="value">
											<dict:fieldDescriptor>
												<dict:name>requisite req component field total credits</dict:name>
												<dict:desc>requisite req component field total credits</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="non.negative.decimal"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="requisite.req.component.field.total.credits.key" key="key">
											<dict:fieldDescriptor>
												<dict:name>requisite req component field total credits key</dict:name>
												<dict:desc>requisite req component field total credits key</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="lu.requirement.component.field.keys"/>
													<dict:constraintRef bean="hard.coded.overall.totalCredits"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.operator">
								<!-- The operator use to compare other data fields -->
								<!-- Enumerated list we have equal_to, not_equal_to, greater_than, less_than, greater_than_or_equal_to, less_than_or_equal_to
are we sure this isn't the operator used for Learning Result Definitions -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="requisite.req.component.field.operator" key="value">
											<dict:fieldDescriptor>
												<dict:name>requisite req component field operator</dict:name>
												<dict:desc>requisite req component field operator</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="lrd.operators"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="requisite.req.component.field.operator.key" key="key">
											<dict:fieldDescriptor>
												<dict:name>requisite req component field operator key</dict:name>
												<dict:desc>requisite req component field operator key</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="lu.requirement.component.field.keys"/>
													<dict:constraintRef bean="hard.coded.operator"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.countType">
								<!-- Type of counting -->
								<!-- determines how counting is performed (credits/courses/etc) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="requisite.req.component.field.count.type" key="value">
											<dict:fieldDescriptor>
												<dict:name>requisite req component field count type</dict:name>
												<dict:desc>requisite req component field count type</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="code"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="requisite.req.component.field.count.type.key" key="key">
											<dict:fieldDescriptor>
												<dict:name>requisite req component field count type key</dict:name>
												<dict:desc>requisite req component field count type key</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="lu.requirement.component.field.keys"/>
													<dict:constraintRef bean="hard.coded.countType"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.req.component.field.one.of.courses.coreq" key="reqCompField">
					<dict:fieldDescriptor>
						<dict:name>requisite req component field one of courses coreq</dict:name>
						<dict:desc>requisite req component field one of courses coreq</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.ReqCompFieldInfo">
								<!-- Detailed information about a requirement component field value. -->
								<dict:type key="kuali.reqCompFieldType.credit.course">
								<!-- An Id of a Clu of type Credit Course -->
								<!-- The value must be a cluId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.credit.course.set">
								<!-- An Id of a Set of Credit Course Clus -->
								<!-- The value must be a cluSetId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluSetId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluISetId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.requiredCount">
								<!-- A number to be compared to a count of clu's -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.required.count"/>
										<dict:fieldRef bean="requisite.req.component.field.required.count.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.lrd.credit.course.final.grade">
								<!-- A credit course paired with a minimum grade -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.value"/>
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.gpa">
								<!-- GPA -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.gpa"/>
										<dict:fieldRef bean="requisite.req.component.field.gpa.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.totalCredits">
								<!-- Total Credits -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.total.credits"/>
										<dict:fieldRef bean="requisite.req.component.field.total.credits.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.operator">
								<!-- The operator use to compare other data fields -->
								<!-- Enumerated list we have equal_to, not_equal_to, greater_than, less_than, greater_than_or_equal_to, less_than_or_equal_to
are we sure this isn't the operator used for Learning Result Definitions -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.operator"/>
										<dict:fieldRef bean="requisite.req.component.field.operator.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.countType">
								<!-- Type of counting -->
								<!-- determines how counting is performed (credits/courses/etc) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.count.type"/>
										<dict:fieldRef bean="requisite.req.component.field.count.type.key"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.req.component.field.all.of.courses.coreq" key="reqCompField">
					<dict:fieldDescriptor>
						<dict:name>requisite req component field all of courses coreq</dict:name>
						<dict:desc>requisite req component field all of courses coreq</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.ReqCompFieldInfo">
								<!-- Detailed information about a requirement component field value. -->
								<dict:type key="kuali.reqCompFieldType.credit.course">
								<!-- An Id of a Clu of type Credit Course -->
								<!-- The value must be a cluId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.credit.course.set">
								<!-- An Id of a Set of Credit Course Clus -->
								<!-- The value must be a cluSetId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluSetId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluISetId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.requiredCount">
								<!-- A number to be compared to a count of clu's -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.required.count"/>
										<dict:fieldRef bean="requisite.req.component.field.required.count.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.lrd.credit.course.final.grade">
								<!-- A credit course paired with a minimum grade -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.value"/>
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.gpa">
								<!-- GPA -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.gpa"/>
										<dict:fieldRef bean="requisite.req.component.field.gpa.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.totalCredits">
								<!-- Total Credits -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.total.credits"/>
										<dict:fieldRef bean="requisite.req.component.field.total.credits.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.operator">
								<!-- The operator use to compare other data fields -->
								<!-- Enumerated list we have equal_to, not_equal_to, greater_than, less_than, greater_than_or_equal_to, less_than_or_equal_to
are we sure this isn't the operator used for Learning Result Definitions -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.operator"/>
										<dict:fieldRef bean="requisite.req.component.field.operator.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.countType">
								<!-- Type of counting -->
								<!-- determines how counting is performed (credits/courses/etc) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.count.type"/>
										<dict:fieldRef bean="requisite.req.component.field.count.type.key"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.req.component.field.all.of.courses" key="reqCompField">
					<dict:fieldDescriptor>
						<dict:name>requisite req component field all of courses</dict:name>
						<dict:desc>requisite req component field all of courses</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.ReqCompFieldInfo">
								<!-- Detailed information about a requirement component field value. -->
								<dict:type key="kuali.reqCompFieldType.credit.course">
								<!-- An Id of a Clu of type Credit Course -->
								<!-- The value must be a cluId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.credit.course.set">
								<!-- An Id of a Set of Credit Course Clus -->
								<!-- The value must be a cluSetId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluSetId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluISetId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.requiredCount">
								<!-- A number to be compared to a count of clu's -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.required.count"/>
										<dict:fieldRef bean="requisite.req.component.field.required.count.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.lrd.credit.course.final.grade">
								<!-- A credit course paired with a minimum grade -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.value"/>
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.gpa">
								<!-- GPA -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.gpa"/>
										<dict:fieldRef bean="requisite.req.component.field.gpa.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.totalCredits">
								<!-- Total Credits -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.total.credits"/>
										<dict:fieldRef bean="requisite.req.component.field.total.credits.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.operator">
								<!-- The operator use to compare other data fields -->
								<!-- Enumerated list we have equal_to, not_equal_to, greater_than, less_than, greater_than_or_equal_to, less_than_or_equal_to
are we sure this isn't the operator used for Learning Result Definitions -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.operator"/>
										<dict:fieldRef bean="requisite.req.component.field.operator.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.countType">
								<!-- Type of counting -->
								<!-- determines how counting is performed (credits/courses/etc) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.count.type"/>
										<dict:fieldRef bean="requisite.req.component.field.count.type.key"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.req.component.field.one.of.courses" key="reqCompField">
					<dict:fieldDescriptor>
						<dict:name>requisite req component field one of courses</dict:name>
						<dict:desc>requisite req component field one of courses</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.ReqCompFieldInfo">
								<!-- Detailed information about a requirement component field value. -->
								<dict:type key="kuali.reqCompFieldType.credit.course">
								<!-- An Id of a Clu of type Credit Course -->
								<!-- The value must be a cluId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.credit.course.set">
								<!-- An Id of a Set of Credit Course Clus -->
								<!-- The value must be a cluSetId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluSetId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluISetId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.requiredCount">
								<!-- A number to be compared to a count of clu's -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.required.count"/>
										<dict:fieldRef bean="requisite.req.component.field.required.count.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.lrd.credit.course.final.grade">
								<!-- A credit course paired with a minimum grade -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.value"/>
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.gpa">
								<!-- GPA -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.gpa"/>
										<dict:fieldRef bean="requisite.req.component.field.gpa.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.totalCredits">
								<!-- Total Credits -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.total.credits"/>
										<dict:fieldRef bean="requisite.req.component.field.total.credits.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.operator">
								<!-- The operator use to compare other data fields -->
								<!-- Enumerated list we have equal_to, not_equal_to, greater_than, less_than, greater_than_or_equal_to, less_than_or_equal_to
are we sure this isn't the operator used for Learning Result Definitions -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.operator"/>
										<dict:fieldRef bean="requisite.req.component.field.operator.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.countType">
								<!-- Type of counting -->
								<!-- determines how counting is performed (credits/courses/etc) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.count.type"/>
										<dict:fieldRef bean="requisite.req.component.field.count.type.key"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.req.component.field.n.of.courses" key="reqCompField">
					<dict:fieldDescriptor>
						<dict:name>requisite req component field n of courses</dict:name>
						<dict:desc>requisite req component field n of courses</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.ReqCompFieldInfo">
								<!-- Detailed information about a requirement component field value. -->
								<dict:type key="kuali.reqCompFieldType.credit.course">
								<!-- An Id of a Clu of type Credit Course -->
								<!-- The value must be a cluId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.credit.course.set">
								<!-- An Id of a Set of Credit Course Clus -->
								<!-- The value must be a cluSetId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluSetId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluISetId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.requiredCount">
								<!-- A number to be compared to a count of clu's -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.required.count"/>
										<dict:fieldRef bean="requisite.req.component.field.required.count.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.lrd.credit.course.final.grade">
								<!-- A credit course paired with a minimum grade -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.value"/>
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.gpa">
								<!-- GPA -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.gpa"/>
										<dict:fieldRef bean="requisite.req.component.field.gpa.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.totalCredits">
								<!-- Total Credits -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.total.credits"/>
										<dict:fieldRef bean="requisite.req.component.field.total.credits.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.operator">
								<!-- The operator use to compare other data fields -->
								<!-- Enumerated list we have equal_to, not_equal_to, greater_than, less_than, greater_than_or_equal_to, less_than_or_equal_to
are we sure this isn't the operator used for Learning Result Definitions -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.operator"/>
										<dict:fieldRef bean="requisite.req.component.field.operator.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.countType">
								<!-- Type of counting -->
								<!-- determines how counting is performed (credits/courses/etc) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.count.type"/>
										<dict:fieldRef bean="requisite.req.component.field.count.type.key"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.req.component.field.mininum.overall.gpa" key="reqCompField">
					<dict:fieldDescriptor>
						<dict:name>requisite req component field mininum overall gpa</dict:name>
						<dict:desc>requisite req component field mininum overall gpa</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.ReqCompFieldInfo">
								<!-- Detailed information about a requirement component field value. -->
								<dict:type key="kuali.reqCompFieldType.credit.course">
								<!-- An Id of a Clu of type Credit Course -->
								<!-- The value must be a cluId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.credit.course.set">
								<!-- An Id of a Set of Credit Course Clus -->
								<!-- The value must be a cluSetId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluSetId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluISetId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.requiredCount">
								<!-- A number to be compared to a count of clu's -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.required.count"/>
										<dict:fieldRef bean="requisite.req.component.field.required.count.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.lrd.credit.course.final.grade">
								<!-- A credit course paired with a minimum grade -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.value"/>
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.gpa">
								<!-- GPA -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.gpa"/>
										<dict:fieldRef bean="requisite.req.component.field.gpa.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.totalCredits">
								<!-- Total Credits -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.total.credits"/>
										<dict:fieldRef bean="requisite.req.component.field.total.credits.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.operator">
								<!-- The operator use to compare other data fields -->
								<!-- Enumerated list we have equal_to, not_equal_to, greater_than, less_than, greater_than_or_equal_to, less_than_or_equal_to
are we sure this isn't the operator used for Learning Result Definitions -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.operator"/>
										<dict:fieldRef bean="requisite.req.component.field.operator.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.countType">
								<!-- Type of counting -->
								<!-- determines how counting is performed (credits/courses/etc) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.count.type"/>
										<dict:fieldRef bean="requisite.req.component.field.count.type.key"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.req.component.field.mininum.overall.total.credits" key="reqCompField">
					<dict:fieldDescriptor>
						<dict:name>requisite req component field mininum overall total credits</dict:name>
						<dict:desc>requisite req component field mininum overall total credits</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.ReqCompFieldInfo">
								<!-- Detailed information about a requirement component field value. -->
								<dict:type key="kuali.reqCompFieldType.credit.course">
								<!-- An Id of a Clu of type Credit Course -->
								<!-- The value must be a cluId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.credit.course.set">
								<!-- An Id of a Set of Credit Course Clus -->
								<!-- The value must be a cluSetId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluSetId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluISetId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.requiredCount">
								<!-- A number to be compared to a count of clu's -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.required.count"/>
										<dict:fieldRef bean="requisite.req.component.field.required.count.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.lrd.credit.course.final.grade">
								<!-- A credit course paired with a minimum grade -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.value"/>
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.gpa">
								<!-- GPA -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.gpa"/>
										<dict:fieldRef bean="requisite.req.component.field.gpa.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.totalCredits">
								<!-- Total Credits -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.total.credits"/>
										<dict:fieldRef bean="requisite.req.component.field.total.credits.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.operator">
								<!-- The operator use to compare other data fields -->
								<!-- Enumerated list we have equal_to, not_equal_to, greater_than, less_than, greater_than_or_equal_to, less_than_or_equal_to
are we sure this isn't the operator used for Learning Result Definitions -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.operator"/>
										<dict:fieldRef bean="requisite.req.component.field.operator.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.countType">
								<!-- Type of counting -->
								<!-- determines how counting is performed (credits/courses/etc) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.count.type"/>
										<dict:fieldRef bean="requisite.req.component.field.count.type.key"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.req.component.field.lrd.credit.course.final.grade" key="reqCompField">
					<dict:fieldDescriptor>
						<dict:name>requisite req component field lrd credit course final grade</dict:name>
						<dict:desc>requisite req component field lrd credit course final grade</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.ReqCompFieldInfo">
								<!-- Detailed information about a requirement component field value. -->
								<dict:type key="kuali.reqCompFieldType.credit.course">
								<!-- An Id of a Clu of type Credit Course -->
								<!-- The value must be a cluId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.credit.course.set">
								<!-- An Id of a Set of Credit Course Clus -->
								<!-- The value must be a cluSetId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluSetId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluISetId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.requiredCount">
								<!-- A number to be compared to a count of clu's -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.required.count"/>
										<dict:fieldRef bean="requisite.req.component.field.required.count.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.lrd.credit.course.final.grade">
								<!-- A credit course paired with a minimum grade -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.value"/>
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.gpa">
								<!-- GPA -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.gpa"/>
										<dict:fieldRef bean="requisite.req.component.field.gpa.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.totalCredits">
								<!-- Total Credits -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.total.credits"/>
										<dict:fieldRef bean="requisite.req.component.field.total.credits.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.operator">
								<!-- The operator use to compare other data fields -->
								<!-- Enumerated list we have equal_to, not_equal_to, greater_than, less_than, greater_than_or_equal_to, less_than_or_equal_to
are we sure this isn't the operator used for Learning Result Definitions -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.operator"/>
										<dict:fieldRef bean="requisite.req.component.field.operator.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.countType">
								<!-- Type of counting -->
								<!-- determines how counting is performed (credits/courses/etc) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.count.type"/>
										<dict:fieldRef bean="requisite.req.component.field.count.type.key"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.req.component.field.one.of.programs" key="reqCompField">
					<dict:fieldDescriptor>
						<dict:name>requisite req component field one of programs</dict:name>
						<dict:desc>requisite req component field one of programs</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.ReqCompFieldInfo">
								<!-- Detailed information about a requirement component field value. -->
								<dict:type key="kuali.reqCompFieldType.credit.course">
								<!-- An Id of a Clu of type Credit Course -->
								<!-- The value must be a cluId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.credit.course.set">
								<!-- An Id of a Set of Credit Course Clus -->
								<!-- The value must be a cluSetId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluSetId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluISetId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.requiredCount">
								<!-- A number to be compared to a count of clu's -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.required.count"/>
										<dict:fieldRef bean="requisite.req.component.field.required.count.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.lrd.credit.course.final.grade">
								<!-- A credit course paired with a minimum grade -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.value"/>
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.gpa">
								<!-- GPA -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.gpa"/>
										<dict:fieldRef bean="requisite.req.component.field.gpa.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.totalCredits">
								<!-- Total Credits -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.total.credits"/>
										<dict:fieldRef bean="requisite.req.component.field.total.credits.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.operator">
								<!-- The operator use to compare other data fields -->
								<!-- Enumerated list we have equal_to, not_equal_to, greater_than, less_than, greater_than_or_equal_to, less_than_or_equal_to
are we sure this isn't the operator used for Learning Result Definitions -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.operator"/>
										<dict:fieldRef bean="requisite.req.component.field.operator.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.countType">
								<!-- Type of counting -->
								<!-- determines how counting is performed (credits/courses/etc) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.count.type"/>
										<dict:fieldRef bean="requisite.req.component.field.count.type.key"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.req.component.field.none.of.programs" key="reqCompField">
					<dict:fieldDescriptor>
						<dict:name>requisite req component field none of programs</dict:name>
						<dict:desc>requisite req component field none of programs</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.lum.lu.dto.ReqCompFieldInfo">
								<!-- Detailed information about a requirement component field value. -->
								<dict:type key="kuali.reqCompFieldType.credit.course">
								<!-- An Id of a Clu of type Credit Course -->
								<!-- The value must be a cluId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.credit.course.set">
								<!-- An Id of a Set of Credit Course Clus -->
								<!-- The value must be a cluSetId -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluSetId"/>
										<dict:fieldRef bean="requisite.req.component.field.credit.course.cluISetId.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.requiredCount">
								<!-- A number to be compared to a count of clu's -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.required.count"/>
										<dict:fieldRef bean="requisite.req.component.field.required.count.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.lrd.credit.course.final.grade">
								<!-- A credit course paired with a minimum grade -->
								<!-- The value must be an integer -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.value"/>
										<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.gpa">
								<!-- GPA -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.gpa"/>
										<dict:fieldRef bean="requisite.req.component.field.gpa.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.overall.totalCredits">
								<!-- Total Credits -->
								<!-- The value must be a number -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.total.credits"/>
										<dict:fieldRef bean="requisite.req.component.field.total.credits.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.operator">
								<!-- The operator use to compare other data fields -->
								<!-- Enumerated list we have equal_to, not_equal_to, greater_than, less_than, greater_than_or_equal_to, less_than_or_equal_to
are we sure this isn't the operator used for Learning Result Definitions -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.operator"/>
										<dict:fieldRef bean="requisite.req.component.field.operator.key"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.reqCompFieldType.countType">
								<!-- Type of counting -->
								<!-- determines how counting is performed (credits/courses/etc) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										<dict:fieldRef bean="requisite.req.component.field.count.type"/>
										<dict:fieldRef bean="requisite.req.component.field.count.type.key"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.req.component.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>requisite req component effectiveDate</dict:name>
						<dict:desc>requisite req component effectiveDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.req.component.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>requisite req component expirationDate</dict:name>
						<dict:desc>requisite req component expirationDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.req.component.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>requisite req component metaInfo</dict:name>
						<dict:desc>requisite req component metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="requisite.req.component.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>requisite req component meta versionInd</dict:name>
												<dict:desc>requisite req component meta versionInd</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="requisite.req.component.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>requisite req component meta createTime</dict:name>
												<dict:desc>requisite req component meta createTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="requisite.req.component.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>requisite req component meta createId</dict:name>
												<dict:desc>requisite req component meta createId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="requisite.req.component.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>requisite req component meta updateTime</dict:name>
												<dict:desc>requisite req component meta updateTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="requisite.req.component.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>requisite req component meta updateId</dict:name>
												<dict:desc>requisite req component meta updateId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.req.component.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>requisite req component type</dict:name>
						<dict:desc>requisite req component type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="lu.requirement.component.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.req.component.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>requisite req component state</dict:name>
						<dict:desc>requisite req component state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
							<dict:constraintRef bean="lu.requirement.component.states"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="requisite.req.component.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>requisite req component id</dict:name>
						<dict:desc>requisite req component id</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="inactive">
			<!-- requirement componenent is inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.reqCompType.requisite.courseList.coreq.oneof">
		<!-- Student must be enrolled in one of the following courses -->
			<dict:state key="active">
			<!-- requirement componenent is active -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- requirement componenent is inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.reqCompType.requisite.courseList.1of2">
		<!-- Student must take one of two specified courses -->
			<dict:state key="active">
			<!-- requirement componenent is active -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- requirement componenent is inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.reqCompType.requisite.courseList.nof">
		<!-- Student must take <n> courses from the specified courses -->
			<dict:state key="active">
			<!-- requirement componenent is active -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- requirement componenent is inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.reqCompType.requisite.programList.oneof">
		<!-- Enrollment is limited to students in the following programs -->
			<dict:state key="active">
			<!-- requirement componenent is active -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- requirement componenent is inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.reqCompType.requisite.overall.gpa">
		<!-- Student needs to have attained a minimum specified GPA -->
			<dict:state key="active">
			<!-- requirement componenent is active -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- requirement componenent is inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.reqCompType.requisite.overall.credit">
		<!-- Student needs to have earned a minimum specified Total Credits -->
			<dict:state key="active">
			<!-- requirement componenent is active -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- requirement componenent is inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.reqCompType.requisite.courseList.all">
		<!-- Student must take all of the specified courses -->
			<dict:state key="active">
			<!-- requirement componenent is active -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- requirement componenent is inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.reqCompType.requisite.programList.none">
		<!-- Enrollment is not available to students in the following programs -->
			<dict:state key="active">
			<!-- requirement componenent is active -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- requirement componenent is inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.reqCompType.requisite.grdCondCourseList">
		<!-- Student must have completed the specified course with a minium specified grade -->
			<dict:state key="active">
			<!-- requirement componenent is active -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- requirement componenent is inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="requisite.req.component.desc"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses.coreq"/>
				<dict:fieldRef bean="requisite.req.component.field.all.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.n.of.courses"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.gpa"/>
				<dict:fieldRef bean="requisite.req.component.field.mininum.overall.total.credits"/>
				<dict:fieldRef bean="requisite.req.component.field.lrd.credit.course.final.grade"/>
				<dict:fieldRef bean="requisite.req.component.field.one.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.field.none.of.programs"/>
				<dict:fieldRef bean="requisite.req.component.effectiveDate"/>
				<dict:fieldRef bean="requisite.req.component.expirationDate"/>
				<dict:fieldRef bean="requisite.req.component.metaInfo"/>
				<dict:fieldRef bean="requisite.req.component.type"/>
				<dict:fieldRef bean="requisite.req.component.state"/>
				<dict:fieldRef bean="requisite.req.component.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key="org.kuali.student.lum.lu.dto.CluSetInfo">
		<!-- Detailed information about a single CLU Set. -->
		<dict:type key="kuali.cluSet.type.CreditCourse">
		<!-- Sets composed of credit courses -->
			<dict:state key="active">
			<!-- clu set is active -->
			<!-- TODO: Add to simple spec -->
				
				<dict:field id="credit.course.set.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>credit course set name</dict:name>
						<dict:desc>credit course set name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
							<dict:constraint key="in-line.constraint.for.dictionary.credit.course.set.name">
								<dict:maxLength>100</dict:maxLength>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.set.description" key="desc">
					<dict:fieldDescriptor>
						<dict:name>credit course set description</dict:name>
						<dict:desc>credit course set description</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="credit.course.set.description.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>credit course set description plain</dict:name>
												<dict:desc>credit course set description plain</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.credit.course.set.description.plain">
														<dict:maxLength>2000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="credit.course.set.description.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>credit course set description formatted</dict:name>
												<dict:desc>credit course set description formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.credit.course.set.description.formatted">
														<dict:maxLength>2000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.set.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>credit course set effectiveDate</dict:name>
						<dict:desc>credit course set effectiveDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.set.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>credit course set expirationDate</dict:name>
						<dict:desc>credit course set expirationDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.set.dynanic" key="membershipQuery">
					<!-- I've been told that dynamic clu sets are not being used but since I defined them already I didn't want to not write them out because if they are not written out it causes the dictionary generator to fail -->
					<dict:fieldDescriptor>
						<dict:name>credit course set dynanic set</dict:name>
						<dict:desc>credit course set dynanic set</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key=".MembershipQueryInfo">
								<!-- Specifies a search for CLU identifiers. -->
								<dict:type key="kuali.lu.searchTypes.CoursesForDynamicCLUSet">
								<!-- Named Search Associated with Dynamic CLU Sets to select Courses when the dynamic CLU Set is executed -->
								<!-- (n/a) -->
								<!-- See    https://test.kuali.org/confluence/x/AgBwCg -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="credit.course.set.dynamic.search.type" key="searchTypeKey">
											<!-- right now there is just a single search type defined in support of dynamic clu sets so this is really hard coded to be "kuali.lu.searchTypes.CoursesForDynamicCLUSet" -->
											<dict:fieldDescriptor>
												<dict:name>credit course dynamic set search type key</dict:name>
												<dict:desc>credit course dynamic set search type key</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="search.types"/>
													<dict:constraintRef bean="valid.credit.course.clu.set.search.types"/>
													<dict:constraint key="in-line.constraint.for.dictionary.credit.course.set.dynamic.search.type">
														<dict:validChars>
														<dict:value>regex:kuali\.lu\.searchTypes\.CoursesForDynamicCLUSet</dict:value>
														</dict:validChars>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="credit.course.set.dynamic.search.params" key="queryParamValueList">
											<dict:fieldDescriptor>
												<dict:name>credit course set dynanic set parameters</dict:name>
												<dict:desc>credit course set dynanic set parameters</dict:desc>
												<dict:dataType>complex</dict:dataType>
													
													<dict:objectStructure key="org.kuali.student.core.search.dto.QueryParamValue">
														<!-- Value(s) for a given query parameter. -->
														<dict:type key="kuali.lu.searchParameter.LuTypeKey">
														<!-- Lu Type to search for -->
														<!-- (n/a) -->
														<!-- See    https://test.kuali.org/confluence/x/AgBwCg -->
															<dict:state key="(n/a)">
															<!-- Not applicable -->
																
																<dict:field id="credit.course.set.dynamic.search.param.lu.type.value" key="value">
																	<!-- Not sure why services has this as optional -->
																	<!-- Hard coded to be "kuali.lu.type.CreditCourse" -->
																	<dict:fieldDescriptor>
																		<dict:name>credit course dynamic set search parameter lu type value</dict:name>
																		<dict:desc>credit course dynamic set search parameter lu type value</dict:desc>
																		<dict:dataType>string</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="optional"/>
																			<dict:constraintRef bean="repeating"/>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="kuali.type"/>
																			<dict:constraintRef bean="lu.types"/>
																			<dict:constraint key="in-line.constraint.for.dictionary.credit.course.set.dynamic.search.param.lu.type.value">
																				<dict:validChars>
																				<dict:value>regex:kuali\.lu\.type\.CreditCourse</dict:value>
																				</dict:validChars>
																				</dict:constraint>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="credit.course.set.dynamic.search.param.lu.type.key" key="key">
																	<!-- Hard coded to be "kuali.lu.searchParameter.LuTypeKey" -->
																	<dict:fieldDescriptor>
																		<dict:name>credit course dynamic set search parameter lu type key</dict:name>
																		<dict:desc>credit course dynamic set search parameter lu type key</dict:desc>
																		<dict:dataType>string</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="kuali.type"/>
																			<dict:constraintRef bean="query.param.value.types"/>
																			<dict:constraint key="in-line.constraint.for.dictionary.credit.course.set.dynamic.search.param.lu.type.key">
																				<dict:validChars>
																				<dict:value>regex:kuali\.lu\.searchParameter\.LuTypeKey</dict:value>
																				</dict:validChars>
																				</dict:constraint>
																	</dict:constraintDescriptor>
																</dict:field>
															</dict:state>
														</dict:type>
														<dict:type key="kuali.lu.searchParameter.LuStates">
														<!-- Lu States to include in search -->
														<!-- (n/a) -->
														<!-- See    https://test.kuali.org/confluence/x/AgBwCg -->
															<dict:state key="(n/a)">
															<!-- Not applicable -->
																
																<dict:field id="credit.course.set.dynamic.search.param.lu.states.value" key="value">
																	<!-- Not sure why services has this as optional -->
																	<dict:fieldDescriptor>
																		<dict:name>credit course dynamic set search parameter lu states value</dict:name>
																		<dict:desc>credit course dynamic set search parameter lu states value</dict:desc>
																		<dict:dataType>string</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="optional"/>
																			<dict:constraintRef bean="repeating"/>
																			<dict:constraintRef bean="kuali.state"/>
																			<dict:constraintRef bean="lu.states"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="credit.course.set.dynamic.search.param.lu.states.key" key="key">
																	<!-- Hard coded to be "kuali.lu.searchParameter.LuStates" -->
																	<dict:fieldDescriptor>
																		<dict:name>credit course dynamic set search parameter lu states key</dict:name>
																		<dict:desc>credit course dynamic set search parameter lu states key</dict:desc>
																		<dict:dataType>string</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="kuali.type"/>
																			<dict:constraintRef bean="query.param.value.types"/>
																			<dict:constraint key="in-line.constraint.for.dictionary.credit.course.set.dynamic.search.param.lu.states.key">
																				<dict:validChars>
																				<dict:value>regex:kuali\.lu\.searchParameter\.LuStates</dict:value>
																				</dict:validChars>
																				</dict:constraint>
																	</dict:constraintDescriptor>
																</dict:field>
															</dict:state>
														</dict:type>
														<dict:type key="kuali.lu.searchParameter.EffectiveDate">
														<!-- A date for which the CLU must be effective on (falls between or on the effective and expiration dates of a CLU - if no expiration date exists must be >= to effective date) -->
														<!-- (n/a) -->
														<!-- See    https://test.kuali.org/confluence/x/AgBwCg -->
															<dict:state key="(n/a)">
															<!-- Not applicable -->
																
																<dict:field id="credit.course.set.dynamic.search.param.lu.effective.date.value" key="value">
																	<!-- Not sure why services has this as optional -->
																	<dict:fieldDescriptor>
																		<dict:name>credit course dynamic set search parameter lu effective date value</dict:name>
																		<dict:desc>credit course dynamic set search parameter lu effective date value</dict:desc>
																		<dict:dataType>string</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="optional"/>
																			<dict:constraintRef bean="repeating"/>
																			<dict:constraintRef bean="kuali.type"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="date"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="credit.course.set.dynamic.search.param.lu.effective.date.key" key="key">
																	<!-- Hard coded to be "kuali.lu.searchParameter.EffectiveDate" -->
																	<dict:fieldDescriptor>
																		<dict:name>credit course dynamic set search parameter lu effective date key</dict:name>
																		<dict:desc>credit course dynamic set search parameter lu effective date key</dict:desc>
																		<dict:dataType>string</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="kuali.type"/>
																			<dict:constraintRef bean="query.param.value.types"/>
																			<dict:constraint key="in-line.constraint.for.dictionary.credit.course.set.dynamic.search.param.lu.effective.date.key">
																				<dict:validChars>
																				<dict:value>regex:kuali\.lu\.searchParameter\.EffectiveDate</dict:value>
																				</dict:validChars>
																				</dict:constraint>
																	</dict:constraintDescriptor>
																</dict:field>
															</dict:state>
														</dict:type>
														<dict:type key="kuali.lu.searchParameter.StudySubjectArea">
														<!-- Subject Area Code -->
														<!-- (n/a) -->
														<!-- See    https://test.kuali.org/confluence/x/AgBwCg -->
															<dict:state key="(n/a)">
															<!-- Not applicable -->
																
																<dict:field id="credit.course.set.dynamic.search.param.subject.area.value" key="value">
																	<!-- Not sure why services has this as optional -->
																	<dict:fieldDescriptor>
																		<dict:name>credit course dynamic set search parameter subject area value</dict:name>
																		<dict:desc>credit course dynamic set search parameter subject area value</dict:desc>
																		<dict:dataType>string</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="optional"/>
																			<dict:constraintRef bean="repeating"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="code"/>
																			<dict:constraintRef bean="subject.areas"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="credit.course.set.dynamic.search.param.subject.area.key" key="key">
																	<!-- Hard coded to be "kuali.lu.searchParameter.StudySubjectArea" -->
																	<dict:fieldDescriptor>
																		<dict:name>credit course dynamic set search parameter subject area key</dict:name>
																		<dict:desc>credit course dynamic set search parameter subject area key</dict:desc>
																		<dict:dataType>string</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="kuali.type"/>
																			<dict:constraintRef bean="query.param.value.types"/>
																			<dict:constraint key="in-line.constraint.for.dictionary.credit.course.set.dynamic.search.param.subject.area.key">
																				<dict:validChars>
																				<dict:value>regex:kuali\.lu\.searchParameter\.StudySubjectArea</dict:value>
																				</dict:validChars>
																				</dict:constraint>
																	</dict:constraintDescriptor>
																</dict:field>
															</dict:state>
														</dict:type>
														<dict:type key="kuali.lu.searchParameter.AdminOrgs">
														<!-- Primary Admin Organizations -->
														<!-- (n/a) -->
														<!-- See    https://test.kuali.org/confluence/x/AgBwCg -->
															<dict:state key="(n/a)">
															<!-- Not applicable -->
																
																<dict:field id="credit.course.set.dynamic.search.param.primary.admin.orgs.value" key="value">
																	<!-- Not sure why services has this as optional -->
																	<dict:fieldDescriptor>
																		<dict:name>credit course dynamic set search parameter primary admin orgs value</dict:name>
																		<dict:desc>credit course dynamic set search parameter primary admin orgs value</dict:desc>
																		<dict:dataType>string</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="optional"/>
																			<dict:constraintRef bean="repeating"/>
																			<dict:constraintRef bean="related.orgId"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="credit.course.set.dynamic.search.param.primary.admin.orgs.key" key="key">
																	<!-- Hard coded to be "kuali.lu.searchParameter.AdminOrgs" -->
																	<dict:fieldDescriptor>
																		<dict:name>credit course dynamic set search parameter primary admin orgs key</dict:name>
																		<dict:desc>credit course dynamic set search parameter primary admin orgs key</dict:desc>
																		<dict:dataType>string</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="kuali.type"/>
																			<dict:constraintRef bean="query.param.value.types"/>
																			<dict:constraint key="in-line.constraint.for.dictionary.credit.course.set.dynamic.search.param.primary.admin.orgs.key">
																				<dict:validChars>
																				<dict:value>regex:kuali\.lu\.searchParameter\.AdminOrgs</dict:value>
																				</dict:validChars>
																				</dict:constraint>
																	</dict:constraintDescriptor>
																</dict:field>
															</dict:state>
														</dict:type>
														<dict:type key="kuali.lu.searchParameter.Level">
														<!-- Level -->
														<!-- (n/a) -->
														<!-- See    https://test.kuali.org/confluence/x/AgBwCg -->
															<dict:state key="(n/a)">
															<!-- Not applicable -->
																
																<dict:field id="credit.course.set.dynamic.search.param.level.value" key="value">
																	<!-- Not sure why services has this as optional -->
																	<dict:fieldDescriptor>
																		<dict:name>credit course dynamic set search parameter level value</dict:name>
																		<dict:desc>credit course dynamic set search parameter level value</dict:desc>
																		<dict:dataType>string</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="optional"/>
																			<dict:constraintRef bean="repeating"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="code"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="credit.course.set.dynamic.search.param.level.key" key="key">
																	<!-- Hard coded to be "kuali.lu.searchParameter.Level" -->
																	<dict:fieldDescriptor>
																		<dict:name>credit course dynamic set search parameter level key</dict:name>
																		<dict:desc>credit course dynamic set search parameter level key</dict:desc>
																		<dict:dataType>string</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="kuali.type"/>
																			<dict:constraintRef bean="query.param.value.types"/>
																			<dict:constraint key="in-line.constraint.for.dictionary.credit.course.set.dynamic.search.param.level.key">
																				<dict:validChars>
																				<dict:value>regex:kuali\.lu\.searchParameter\.Level</dict:value>
																				</dict:validChars>
																				</dict:constraint>
																	</dict:constraintDescriptor>
																</dict:field>
															</dict:state>
														</dict:type>
														<dict:type key="kuali.lu.searchParameter.Division">
														<!-- Division -->
														<!-- (n/a) -->
														<!-- See    https://test.kuali.org/confluence/x/AgBwCg -->
															<dict:state key="(n/a)">
															<!-- Not applicable -->
																
																<dict:field id="credit.course.set.dynamic.search.param.division.value" key="value">
																	<!-- Not sure why services has this as optional -->
																	<dict:fieldDescriptor>
																		<dict:name>credit course dynamic set search parameter division value</dict:name>
																		<dict:desc>credit course dynamic set search parameter division value</dict:desc>
																		<dict:dataType>string</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="optional"/>
																			<dict:constraintRef bean="repeating"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="code"/>
																	</dict:constraintDescriptor>
																</dict:field>
																
																<dict:field id="credit.course.set.dynamic.search.param.division.key" key="key">
																	<!-- kuali.lu.searchParameter.Division -->
																	<dict:fieldDescriptor>
																		<dict:name>credit course dynamic set search parameter division key</dict:name>
																		<dict:desc>credit course dynamic set search parameter division key</dict:desc>
																		<dict:dataType>string</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<dict:constraintRef bean="required"/>
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="kuali.type"/>
																			<dict:constraintRef bean="query.param.value.types"/>
																			<dict:constraint key="in-line.constraint.for.dictionary.credit.course.set.dynamic.search.param.division.key">
																				<dict:validChars>
																				<dict:value>regex:kuali\.lu\.searchParameter\.Division</dict:value>
																				</dict:validChars>
																				</dict:constraint>
																	</dict:constraintDescriptor>
																</dict:field>
															</dict:state>
														</dict:type>
													</dict:objectStructure>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="repeating"/>
													<dict:constraint key="in-line.constraint.for.dictionary.credit.course.set.dynamic.search.params">
														<dict:minOccurs>7</dict:minOccurs>
														<dict:maxOccurs>7</dict:maxOccurs>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.set.credit.course.set.ids" key="cluSetIds">
					<dict:fieldDescriptor>
						<dict:name>credit course set credit course set ids</dict:name>
						<dict:desc>credit course set credit course set ids</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.clu.set.id"/>
							<dict:constraintRef bean="kuali.type"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.set.credit.course.ids" key="cluIds">
					<dict:fieldDescriptor>
						<dict:name>credit course set credit course ids</dict:name>
						<dict:desc>credit course set credit course ids</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.cluId"/>
							<dict:constraintRef bean="kuali.type"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.set.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>credit course set attributes</dict:name>
						<dict:desc>credit course set attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.set.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>credit course set metaInfo</dict:name>
						<dict:desc>credit course set metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="credit.course.set.metaInfo.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>credit course set metaInfo versionInd</dict:name>
												<dict:desc>credit course set metaInfo versionInd</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="credit.course.set.metaInfo.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>credit course set metaInfo createTime</dict:name>
												<dict:desc>credit course set metaInfo createTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="credit.course.set.metaInfo.creditId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>credit course set metaInfo creditId</dict:name>
												<dict:desc>credit course set metaInfo creditId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="credit.course.set.metaInfo.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>credit course set metaInfo updateTime</dict:name>
												<dict:desc>credit course set metaInfo updateTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="credit.course.set.metaInfo.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>credit course set metaInfo updateId</dict:name>
												<dict:desc>credit course set metaInfo updateId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.set.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>credit course set type</dict:name>
						<dict:desc>credit course set type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="clu.set.types"/>
							<dict:constraintRef bean="hard.coded.credit.course.clu.set"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.set.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>credit course set state</dict:name>
						<dict:desc>credit course set state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
							<dict:constraintRef bean="clu.set.states"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.set.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>credit course set id</dict:name>
						<dict:desc>credit course set id</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="inactive">
			<!-- clu set is inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="credit.course.set.name"/>
				<dict:fieldRef bean="credit.course.set.description"/>
				<dict:fieldRef bean="credit.course.set.effectiveDate"/>
				<dict:fieldRef bean="credit.course.set.expirationDate"/>
				<dict:fieldRef bean="credit.course.set.dynanic"/>
				<dict:fieldRef bean="credit.course.set.credit.course.set.ids"/>
				<dict:fieldRef bean="credit.course.set.credit.course.ids"/>
				<dict:fieldRef bean="credit.course.set.attributes"/>
				<dict:fieldRef bean="credit.course.set.metaInfo"/>
				<dict:fieldRef bean="credit.course.set.type"/>
				<dict:fieldRef bean="credit.course.set.state"/>
				<dict:fieldRef bean="credit.course.set.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key=".LrDefinitionInfo">
		<!-- Detailed information about a learning result definition. -->
		<dict:type key="kuali.lrc.lrd.CreditCourseFinalGrade">
		<!-- This defines getting the result of a final grade in a credi course -->
		<!-- (n/a) -->
		<!-- TODO: update simples -->
			<dict:state key="(n/a)">
			<!-- Not applicable -->
			<!-- not sure why it has no state field but it should, at least active/inactive -->
				
				<dict:field id="credit.course.with.final.grade.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>credit course with final grade name</dict:name>
						<dict:desc>credit course with final grade name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.with.final.grade.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>credit course with final grade desc</dict:name>
						<dict:desc>credit course with final grade desc</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="multi.line.text"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.with.final.grade.type" key="lrType">
					<!-- Hard coded to be "kuali.lrc.lrd.CreditCourseFinalGrade" -->
					<dict:fieldDescriptor>
						<dict:name>credit course with final grade type</dict:name>
						<dict:desc>credit course with final grade type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="lrd.types"/>
							<dict:constraint key="in-line.constraint.for.dictionary.credit.course.with.final.grade.type">
								<dict:validChars>
								<dict:value>regex:kuali\.lrc\.lrd\.CreditCourseFinalGrade</dict:value>
								</dict:validChars>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.with.final.grade.scale" key="lrScale">
					<!-- The lrScaleTypeKey as a type is deprected so I am not sure if it is really in use or if it should really point to a different type "scaleKey"?  

This field does not make sense. The GradeKey points to the GradeInfo object that tells us what the scale is -->
					<dict:fieldDescriptor>
						<dict:name>credit course with final grade scale</dict:name>
						<dict:desc>credit course with final grade scale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="learning.result.scale.types"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.with.final.grade.gradeKey" key="value">
					<!-- Isn't this really an ID or KEY that points to either a GradeInfo or a CreditInfo or a CredentialInfo object similar to resultComponentInfo.resultValueIds? -->
					<dict:fieldDescriptor>
						<dict:name>credit course with final grade gradeKey</dict:name>
						<dict:desc>credit course with final grade gradeKey</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="related.gradekey"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.with.final.grade.operator" key="operator">
					<dict:fieldDescriptor>
						<dict:name>credit course with final grade operator</dict:name>
						<dict:desc>credit course with final grade operator</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="code"/>
							<dict:constraintRef bean="lrd.operators"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.with.final.grade.dynamic.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>credit course with final grade dynamic attributes</dict:name>
						<dict:desc>credit course with final grade dynamic attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.with.final.grade.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>credit course with final grade metaInfo</dict:name>
						<dict:desc>credit course with final grade metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="credit.course.with.final.grade.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>credit course with final grade meta versionInd</dict:name>
												<dict:desc>credit course with final grade meta versionInd</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="credit.course.with.final.grade.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>credit course with final grade meta createTime</dict:name>
												<dict:desc>credit course with final grade meta createTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="credit.course.with.final.grade.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>credit course with final grade meta createId</dict:name>
												<dict:desc>credit course with final grade meta createId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="credit.course.with.final.grade.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>credit course with final grade meta updateTime</dict:name>
												<dict:desc>credit course with final grade meta updateTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="credit.course.with.final.grade.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>credit course with final grade meta updateId</dict:name>
												<dict:desc>credit course with final grade meta updateId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="credit.course.with.final.grade.internal.id" key="lrDefinitionId">
					<dict:fieldDescriptor>
						<dict:name>credit course with final grade internal id</dict:name>
						<dict:desc>credit course with final grade internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.lrc.lrd.OverallProgramGPA">
		<!-- This defines the calculated GPA result of enrollment in the overall program -->
		<!-- (n/a) -->
		<!-- For now we have to live without defining "Overall" even though it is a fuzzy word.. What if a person was in multiple overall programs sequentially (undergrad then grad) or parallel (dual major)?  Which program?
TODO: update simples -->
			<dict:state key="(n/a)">
			<!-- Not applicable -->
			<!-- not sure why it has no state field but it should, at least active/inactive -->
				
				<dict:field id="gpa.in.overall.program.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>gpa in overall program name</dict:name>
						<dict:desc>gpa in overall program name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="gpa.in.overall.program.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>gpa in overall program desc</dict:name>
						<dict:desc>gpa in overall program desc</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="multi.line.text"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="gpa.in.overall.program.type" key="lrType">
					<!-- Hard coded to be "kuali.lrc.lrd.OverallProgramGPA" -->
					<dict:fieldDescriptor>
						<dict:name>gpa in overall program type</dict:name>
						<dict:desc>gpa in overall program type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="lrd.types"/>
							<dict:constraint key="in-line.constraint.for.dictionary.gpa.in.overall.program.type">
								<dict:validChars>
								<dict:value>regex:kuali\.lrc\.lrd\.OverallProgramGPA</dict:value>
								</dict:validChars>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="gpa.in.overall.program.scale" key="lrScale">
					<!-- The lrScaleTypeKey as a type is deprected so I am not sure if it is really in use or if it should really point to a different type "scaleKey"?  

This field does not make sense. The GradeKey points to the GradeInfo object that tells us what the scale is -->
					<dict:fieldDescriptor>
						<dict:name>gpa in overall program scale</dict:name>
						<dict:desc>gpa in overall program scale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="learning.result.scale.types"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="gpa.in.overall.program.gpa" key="value">
					<!-- Isn't this really an ID or KEY that points to either a GradeInfo or a CreditInfo or a CredentialInfo object similar to resultComponentInfo.resultValueIds? -->
					<!-- not sure the minimum GPA is stored here or on the requirement component -->
					<dict:fieldDescriptor>
						<dict:name>gpa in overall program gpa</dict:name>
						<dict:desc>gpa in overall program gpa</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="non.negative.decimal"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="gpa.in.overall.program.operator" key="operator">
					<dict:fieldDescriptor>
						<dict:name>gpa in overall program operator</dict:name>
						<dict:desc>gpa in overall program operator</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="code"/>
							<dict:constraintRef bean="lrd.operators"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="gpa.in.overall.program.dynamic.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>gpa in overall program dynamic attributes</dict:name>
						<dict:desc>gpa in overall program dynamic attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="gpa.in.overall.program.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>gpa in overall program metaInfo</dict:name>
						<dict:desc>gpa in overall program metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="gpa.in.overall.program.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>gpa in overall program meta versionInd</dict:name>
												<dict:desc>gpa in overall program meta versionInd</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="gpa.in.overall.program.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>gpa in overall program meta createTime</dict:name>
												<dict:desc>gpa in overall program meta createTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="gpa.in.overall.program.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>gpa in overall program meta createId</dict:name>
												<dict:desc>gpa in overall program meta createId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="gpa.in.overall.program.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>gpa in overall program meta updateTime</dict:name>
												<dict:desc>gpa in overall program meta updateTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="gpa.in.overall.program.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>gpa in overall program meta updateId</dict:name>
												<dict:desc>gpa in overall program meta updateId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="gpa.in.overall.program.internal.id" key="lrDefinitionId">
					<dict:fieldDescriptor>
						<dict:name>gpa in overall program internal id</dict:name>
						<dict:desc>gpa in overall program internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.lrc.lrd.OverallProgramTotalCredits">
		<!-- This defines the calculated Total Credits result of enrollment in the overall program. -->
		<!-- (n/a) -->
		<!-- For now we have to live without defining "Overall" even though it is a fuzzy word.. What if a person was in multiple overall programs sequentially (undergrad then grad) or parallel (dual major)?  Which program?
TODO: update simples -->
			<dict:state key="(n/a)">
			<!-- Not applicable -->
			<!-- not sure why it has no state field but it should, at least active/inactive -->
				
				<dict:field id="total.credits.in.overall.program.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>total credits in overall program name</dict:name>
						<dict:desc>total credits in overall program name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="total.credits.in.overall.program.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>total credits in overall program desc</dict:name>
						<dict:desc>total credits in overall program desc</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="multi.line.text"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="total.credits.in.overall.program.type" key="lrType">
					<!-- Hard coded to be "kuali.lrc.lrd.OverallProgramTotalCredits" -->
					<dict:fieldDescriptor>
						<dict:name>total credits in overall program type</dict:name>
						<dict:desc>total credits in overall program type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="lrd.types"/>
							<dict:constraint key="in-line.constraint.for.dictionary.total.credits.in.overall.program.type">
								<dict:validChars>
								<dict:value>regex:kuali\.lrc\.lrd\.OverallProgramTotalCredits</dict:value>
								</dict:validChars>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="total.credits.in.overall.program.scale" key="lrScale">
					<!-- The lrScaleTypeKey as a type is deprected so I am not sure if it is really in use or if it should really point to a different type "scaleKey"?  

This field does not make sense. The GradeKey points to the GradeInfo object that tells us what the scale is -->
					<dict:fieldDescriptor>
						<dict:name>total credits in overall program scale</dict:name>
						<dict:desc>total credits in overall program scale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="learning.result.scale.types"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="total.credits.in.overall.program.gpa" key="value">
					<!-- Isn't this really an ID or KEY that points to either a GradeInfo or a CreditInfo or a CredentialInfo object similar to resultComponentInfo.resultValueIds? -->
					<!-- not sure the minimum Credits is stored here or on the requirement component -->
					<dict:fieldDescriptor>
						<dict:name>total credits in overall program gpa</dict:name>
						<dict:desc>total credits in overall program gpa</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="non.negative.decimal"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="total.credits.in.overall.program.operator" key="operator">
					<dict:fieldDescriptor>
						<dict:name>total credits in overall program operator</dict:name>
						<dict:desc>total credits in overall program operator</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="code"/>
							<dict:constraintRef bean="lrd.operators"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="total.credits.in.overall.program.dynamic.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>total credits in overall program dynamic attributes</dict:name>
						<dict:desc>total credits in overall program dynamic attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="total.credits.in.overall.program.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>total credits in overall program metaInfo</dict:name>
						<dict:desc>total credits in overall program metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="total.credits.in.overall.program.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>total credits in overall program meta versionInd</dict:name>
												<dict:desc>total credits in overall program meta versionInd</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="total.credits.in.overall.program.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>total credits in overall program meta createTime</dict:name>
												<dict:desc>total credits in overall program meta createTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="total.credits.in.overall.program.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>total credits in overall program meta createId</dict:name>
												<dict:desc>total credits in overall program meta createId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="total.credits.in.overall.program.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>total credits in overall program meta updateTime</dict:name>
												<dict:desc>total credits in overall program meta updateTime</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="total.credits.in.overall.program.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>total credits in overall program meta updateId</dict:name>
												<dict:desc>total credits in overall program meta updateId</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="total.credits.in.overall.program.internal.id" key="lrDefinitionId">
					<dict:fieldDescriptor>
						<dict:name>total credits in overall program internal id</dict:name>
						<dict:desc>total credits in overall program internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key="org.kuali.student.core.proposal.dto.ProposalInfo">
		<!-- Detailed information about a proposal. -->
		<dict:type key="kuali.proposal.type.course.create">
		<!-- Proposal to create a new Credit Course -->
		<!-- changed keys - need CHANGE IN SMPLES -->
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				
				<dict:field id="all.course.proposals.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>all course proposals name</dict:name>
						<dict:desc>all course proposals name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.proposerPerson" key="proposerPerson">
					<dict:fieldDescriptor>
						<dict:name>all course proposals proposerPerson</dict:name>
						<dict:desc>all course proposals proposerPerson</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.personId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.proposerOrg" key="proposerOrg">
					<dict:fieldDescriptor>
						<dict:name>all course proposals proposerOrg</dict:name>
						<dict:desc>all course proposals proposerOrg</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.orgId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.proposalReferenceType" key="proposalReferenceType">
					<dict:fieldDescriptor>
						<dict:name>all course proposals proposalReferenceType</dict:name>
						<dict:desc>all course proposals proposalReferenceType</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="reference.types"/>
							<dict:constraintRef bean="hard.coded.referenceType.CLU"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.proposalReference" key="proposalReference">
					<dict:fieldDescriptor>
						<dict:name>all course proposals proposalReference</dict:name>
						<dict:desc>all course proposals proposalReference</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.cluId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.rationale.draft.private" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all course proposals rationale</dict:name>
						<dict:desc>all course proposals rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="multi.line.text"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.detailDesc" key="detailDesc">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all course proposals detailDesc</dict:name>
						<dict:desc>all course proposals detailDesc</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="multi.line.text"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>all course proposals effectiveDate</dict:name>
						<dict:desc>all course proposals effectiveDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>all course proposals expirationDate</dict:name>
						<dict:desc>all course proposals expirationDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>all course proposals attributes</dict:name>
						<dict:desc>all course proposals attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="all.course.proposals.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>all course proposals metaInfo</dict:name>
						<dict:desc>all course proposals metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="all.course.proposals.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>all course proposals meta versionInd</dict:name>
												<dict:desc>Version number for this all course proposals</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.course.proposals.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>all course proposals meta createTime</dict:name>
												<dict:desc>Date-time this all course proposals was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.course.proposals.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>all course proposals meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this all course proposals</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.course.proposals.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>all course proposals meta updateTime</dict:name>
												<dict:desc>Date-time this  all course proposals was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.course.proposals.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>all course proposals meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this  all course proposals</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>all course proposals type</dict:name>
						<dict:desc>all course proposals type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="proposal.types"/>
							<dict:constraintRef bean="course.proposal.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>all course proposals state</dict:name>
						<dict:desc>all course proposals state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="all.course.proposals.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>all course proposals internal id</dict:name>
						<dict:desc>all course proposals internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				
				<dict:field id="all.course.proposals.rationale.draft.public" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all course proposals rationale</dict:name>
						<dict:desc>all course proposals rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="multi.line.text"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
			<!-- NOT IN SIMPLEs -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				
				<dict:field id="all.course.proposals.rationale" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all course proposals rationale</dict:name>
						<dict:desc>all course proposals rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="multi.line.text"/>
							<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved -->
			<!-- not sure if we will have to create different declined states for different types of rejections -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before published) -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- we may have to differentiate between 'retired' and proposals that are simply 'older versions' -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- Inactive -->
			<!-- used for proposals created as part of revision history - not sure if we need -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.proposal.type.course.retire">
		<!-- Proposal to retire an existing Credit Course -->
		<!-- do these really need to be course specific? -->
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale.draft.private"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale.draft.public"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
			<!-- NOT IN SIMPLEs -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved -->
			<!-- not sure if we will have to create different declined states for different types of rejections -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before published) -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- we may have to differentiate between 'retired' and proposals that are simply 'older versions' -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- Inactive -->
			<!-- used for proposals created as part of revision history - not sure if we need -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.proposal.type.course.reinstate">
		<!-- Proposal to bring an existing Credit Course out of retirement -->
		<!-- do these really need to be course specific? -->
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale.draft.private"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale.draft.public"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
			<!-- NOT IN SIMPLEs -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved -->
			<!-- not sure if we will have to create different declined states for different types of rejections -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before published) -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- we may have to differentiate between 'retired' and proposals that are simply 'older versions' -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- Inactive -->
			<!-- used for proposals created as part of revision history - not sure if we need -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.proposal.type.course.modify">
		<!-- Proposal to modify an existing Credit Course -->
		<!-- do these really need to be course specific? -->
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale.draft.private"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale.draft.public"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
			<!-- NOT IN SIMPLEs -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved -->
			<!-- not sure if we will have to create different declined states for different types of rejections -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before published) -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- we may have to differentiate between 'retired' and proposals that are simply 'older versions' -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- Inactive -->
			<!-- used for proposals created as part of revision history - not sure if we need -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.proposal.type.program.create">
		<!-- Proposal to create a new Program -->
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				
				<dict:field id="all.program.proposals.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>all program proposals name</dict:name>
						<dict:desc>all program proposals name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.proposerPerson" key="proposerPerson">
					<dict:fieldDescriptor>
						<dict:name>all program proposals proposerPerson</dict:name>
						<dict:desc>all program proposals proposerPerson</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.personId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.proposerOrg" key="proposerOrg">
					<dict:fieldDescriptor>
						<dict:name>all program proposals proposerOrg</dict:name>
						<dict:desc>all program proposals proposerOrg</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.orgId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.proposalReferenceType" key="proposalReferenceType">
					<dict:fieldDescriptor>
						<dict:name>all program proposals proposalReferenceType</dict:name>
						<dict:desc>all program proposals proposalReferenceType</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="reference.types"/>
							<dict:constraintRef bean="hard.coded.referenceType.CLU"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.proposalReference" key="proposalReference">
					<dict:fieldDescriptor>
						<dict:name>all program proposals proposalReference</dict:name>
						<dict:desc>all program proposals proposalReference</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.cluId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.rationale.draft.private" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all program proposals rationale</dict:name>
						<dict:desc>all program proposals rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="multi.line.text"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.detailDesc" key="detailDesc">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all program proposals detailDesc</dict:name>
						<dict:desc>all program proposals detailDesc</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="multi.line.text"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>all program proposals effectiveDate</dict:name>
						<dict:desc>all program proposals effectiveDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>all program proposals expirationDate</dict:name>
						<dict:desc>all program proposals expirationDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>all program proposals attributes</dict:name>
						<dict:desc>all program proposals attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="all.program.proposals.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>all program proposals metaInfo</dict:name>
						<dict:desc>all program proposals metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="all.program.proposals.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>all program proposals meta versionInd</dict:name>
												<dict:desc>Version number for this all program proposals</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.program.proposals.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>all program proposals meta createTime</dict:name>
												<dict:desc>Date-time this all program proposals was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.program.proposals.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>all program proposals meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this all program proposals</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.program.proposals.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>all program proposals meta updateTime</dict:name>
												<dict:desc>Date-time this  all program proposals was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.program.proposals.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>all program proposals meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this  all program proposals</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>all program proposals type</dict:name>
						<dict:desc>all program proposals type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="proposal.types"/>
							<dict:constraintRef bean="program.proposal.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>all program proposals state</dict:name>
						<dict:desc>all program proposals state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="all.program.proposals.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>all program proposals internal id</dict:name>
						<dict:desc>all program proposals internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="all.program.proposals.name"/>
				<dict:fieldRef bean="all.program.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.program.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.program.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.program.proposals.proposalReference"/>
				
				<dict:field id="all.program.proposals.rationale.draft.public" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all program proposals rationale</dict:name>
						<dict:desc>all program proposals rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="multi.line.text"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="all.program.proposals.detailDesc"/>
				<dict:fieldRef bean="all.program.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.program.proposals.expirationDate"/>
				<dict:fieldRef bean="all.program.proposals.attributes"/>
				<dict:fieldRef bean="all.program.proposals.metaInfo"/>
				<dict:fieldRef bean="all.program.proposals.type"/>
				<dict:fieldRef bean="all.program.proposals.state"/>
				<dict:fieldRef bean="all.program.proposals.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
			<!-- NOT IN SIMPLEs -->
				<dict:fieldRef bean="all.program.proposals.name"/>
				<dict:fieldRef bean="all.program.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.program.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.program.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.program.proposals.proposalReference"/>
				
				<dict:field id="all.program.proposals.rationale" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all program proposals rationale</dict:name>
						<dict:desc>all program proposals rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="multi.line.text"/>
							<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="all.program.proposals.detailDesc"/>
				<dict:fieldRef bean="all.program.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.program.proposals.expirationDate"/>
				<dict:fieldRef bean="all.program.proposals.attributes"/>
				<dict:fieldRef bean="all.program.proposals.metaInfo"/>
				<dict:fieldRef bean="all.program.proposals.type"/>
				<dict:fieldRef bean="all.program.proposals.state"/>
				<dict:fieldRef bean="all.program.proposals.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="all.program.proposals.name"/>
				<dict:fieldRef bean="all.program.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.program.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.program.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.program.proposals.proposalReference"/>
				<dict:fieldRef bean="all.program.proposals.rationale"/>
				<dict:fieldRef bean="all.program.proposals.detailDesc"/>
				<dict:fieldRef bean="all.program.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.program.proposals.expirationDate"/>
				<dict:fieldRef bean="all.program.proposals.attributes"/>
				<dict:fieldRef bean="all.program.proposals.metaInfo"/>
				<dict:fieldRef bean="all.program.proposals.type"/>
				<dict:fieldRef bean="all.program.proposals.state"/>
				<dict:fieldRef bean="all.program.proposals.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved -->
			<!-- not sure if we will have to create different declined states for different types of rejections -->
				<dict:fieldRef bean="all.program.proposals.name"/>
				<dict:fieldRef bean="all.program.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.program.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.program.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.program.proposals.proposalReference"/>
				<dict:fieldRef bean="all.program.proposals.rationale"/>
				<dict:fieldRef bean="all.program.proposals.detailDesc"/>
				<dict:fieldRef bean="all.program.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.program.proposals.expirationDate"/>
				<dict:fieldRef bean="all.program.proposals.attributes"/>
				<dict:fieldRef bean="all.program.proposals.metaInfo"/>
				<dict:fieldRef bean="all.program.proposals.type"/>
				<dict:fieldRef bean="all.program.proposals.state"/>
				<dict:fieldRef bean="all.program.proposals.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before published) -->
				<dict:fieldRef bean="all.program.proposals.name"/>
				<dict:fieldRef bean="all.program.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.program.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.program.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.program.proposals.proposalReference"/>
				<dict:fieldRef bean="all.program.proposals.rationale"/>
				<dict:fieldRef bean="all.program.proposals.detailDesc"/>
				<dict:fieldRef bean="all.program.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.program.proposals.expirationDate"/>
				<dict:fieldRef bean="all.program.proposals.attributes"/>
				<dict:fieldRef bean="all.program.proposals.metaInfo"/>
				<dict:fieldRef bean="all.program.proposals.type"/>
				<dict:fieldRef bean="all.program.proposals.state"/>
				<dict:fieldRef bean="all.program.proposals.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- we may have to differentiate between 'retired' and proposals that are simply 'older versions' -->
				<dict:fieldRef bean="all.program.proposals.name"/>
				<dict:fieldRef bean="all.program.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.program.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.program.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.program.proposals.proposalReference"/>
				<dict:fieldRef bean="all.program.proposals.rationale"/>
				<dict:fieldRef bean="all.program.proposals.detailDesc"/>
				<dict:fieldRef bean="all.program.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.program.proposals.expirationDate"/>
				<dict:fieldRef bean="all.program.proposals.attributes"/>
				<dict:fieldRef bean="all.program.proposals.metaInfo"/>
				<dict:fieldRef bean="all.program.proposals.type"/>
				<dict:fieldRef bean="all.program.proposals.state"/>
				<dict:fieldRef bean="all.program.proposals.internal.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- Inactive -->
			<!-- used for proposals created as part of revision history - not sure if we need -->
				<dict:fieldRef bean="all.program.proposals.name"/>
				<dict:fieldRef bean="all.program.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.program.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.program.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.program.proposals.proposalReference"/>
				<dict:fieldRef bean="all.program.proposals.rationale"/>
				<dict:fieldRef bean="all.program.proposals.detailDesc"/>
				<dict:fieldRef bean="all.program.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.program.proposals.expirationDate"/>
				<dict:fieldRef bean="all.program.proposals.attributes"/>
				<dict:fieldRef bean="all.program.proposals.metaInfo"/>
				<dict:fieldRef bean="all.program.proposals.type"/>
				<dict:fieldRef bean="all.program.proposals.state"/>
				<dict:fieldRef bean="all.program.proposals.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.proposal.type.group">
		<!-- A  group of proposals -->
		<!-- do these really need to be course specific? -->
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				
				<dict:field id="group.proposal.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>group proposal name</dict:name>
						<dict:desc>group proposal name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.proposerPerson" key="proposerPerson">
					<dict:fieldDescriptor>
						<dict:name>group proposal proposerPerson</dict:name>
						<dict:desc>group proposal proposerPerson</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.personId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.proposerOrg" key="proposerOrg">
					<dict:fieldDescriptor>
						<dict:name>group proposal proposerOrg</dict:name>
						<dict:desc>group proposal proposerOrg</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.orgId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.proposalReferenceType" key="proposalReferenceType">
					<dict:fieldDescriptor>
						<dict:name>group proposal proposalReferenceType</dict:name>
						<dict:desc>group proposal proposalReferenceType</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="reference.types"/>
							<dict:constraintRef bean="hard.coded.referenceType.Proposal"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.proposalReference" key="proposalReference">
					<dict:fieldDescriptor>
						<dict:name>group proposal proposalReference</dict:name>
						<dict:desc>group proposal proposalReference</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.proposal"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.rationale.draft.private" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>group proposal rationale</dict:name>
						<dict:desc>group proposal rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="multi.line.text"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.detailDesc" key="detailDesc">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>group proposal detailDesc</dict:name>
						<dict:desc>group proposal detailDesc</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="multi.line.text"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>group proposal effectiveDate</dict:name>
						<dict:desc>group proposal effectiveDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
							<dict:constraintRef bean="default.today"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>group proposal expirationDate</dict:name>
						<dict:desc>group proposal expirationDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>group proposal attributes</dict:name>
						<dict:desc>group proposal attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="group.proposal.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>group proposal metaInfo</dict:name>
						<dict:desc>group proposal metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="group.proposal.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>create course proposal meta versionInd</dict:name>
												<dict:desc>Version number for this create course proposal</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="group.proposal.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>create course proposal meta createTime</dict:name>
												<dict:desc>Date-time this create course proposal was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="group.proposal.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>create course proposal meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this create course proposal</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="group.proposal.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>create course proposal meta updateTime</dict:name>
												<dict:desc>Date-time this  create course proposal was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="group.proposal.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>create course proposal meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this  create course proposal</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>group proposal type</dict:name>
						<dict:desc>group proposal type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="proposal.types"/>
							<dict:constraintRef bean="hard.coded.group.proposal"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>group proposal state</dict:name>
						<dict:desc>group proposal state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="group.proposal.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>group proposal internal id</dict:name>
						<dict:desc>group proposal internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="group.proposal.name"/>
				<dict:fieldRef bean="group.proposal.proposerPerson"/>
				<dict:fieldRef bean="group.proposal.proposerOrg"/>
				<dict:fieldRef bean="group.proposal.proposalReferenceType"/>
				<dict:fieldRef bean="group.proposal.proposalReference"/>
				
				<dict:field id="group.proposal.rationale.draft.public" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>group proposal rationale</dict:name>
						<dict:desc>group proposal rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="multi.line.text"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="group.proposal.detailDesc"/>
				<dict:fieldRef bean="group.proposal.effectiveDate"/>
				<dict:fieldRef bean="group.proposal.expirationDate"/>
				<dict:fieldRef bean="group.proposal.attributes"/>
				<dict:fieldRef bean="group.proposal.metaInfo"/>
				<dict:fieldRef bean="group.proposal.type"/>
				<dict:fieldRef bean="group.proposal.state"/>
				<dict:fieldRef bean="group.proposal.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
			<!-- NOT IN SIMPLEs -->
				<dict:fieldRef bean="group.proposal.name"/>
				<dict:fieldRef bean="group.proposal.proposerPerson"/>
				<dict:fieldRef bean="group.proposal.proposerOrg"/>
				<dict:fieldRef bean="group.proposal.proposalReferenceType"/>
				<dict:fieldRef bean="group.proposal.proposalReference"/>
				
				<dict:field id="group.proposal.rationale" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>group proposal rationale</dict:name>
						<dict:desc>group proposal rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="multi.line.text"/>
							<dict:constraintRef bean="required"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="group.proposal.detailDesc"/>
				<dict:fieldRef bean="group.proposal.effectiveDate"/>
				<dict:fieldRef bean="group.proposal.expirationDate"/>
				<dict:fieldRef bean="group.proposal.attributes"/>
				<dict:fieldRef bean="group.proposal.metaInfo"/>
				<dict:fieldRef bean="group.proposal.type"/>
				<dict:fieldRef bean="group.proposal.state"/>
				<dict:fieldRef bean="group.proposal.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="group.proposal.name"/>
				<dict:fieldRef bean="group.proposal.proposerPerson"/>
				<dict:fieldRef bean="group.proposal.proposerOrg"/>
				<dict:fieldRef bean="group.proposal.proposalReferenceType"/>
				<dict:fieldRef bean="group.proposal.proposalReference"/>
				<dict:fieldRef bean="group.proposal.rationale"/>
				<dict:fieldRef bean="group.proposal.detailDesc"/>
				<dict:fieldRef bean="group.proposal.effectiveDate"/>
				<dict:fieldRef bean="group.proposal.expirationDate"/>
				<dict:fieldRef bean="group.proposal.attributes"/>
				<dict:fieldRef bean="group.proposal.metaInfo"/>
				<dict:fieldRef bean="group.proposal.type"/>
				<dict:fieldRef bean="group.proposal.state"/>
				<dict:fieldRef bean="group.proposal.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved -->
			<!-- not sure if we will have to create different declined states for different types of rejections -->
				<dict:fieldRef bean="group.proposal.name"/>
				<dict:fieldRef bean="group.proposal.proposerPerson"/>
				<dict:fieldRef bean="group.proposal.proposerOrg"/>
				<dict:fieldRef bean="group.proposal.proposalReferenceType"/>
				<dict:fieldRef bean="group.proposal.proposalReference"/>
				<dict:fieldRef bean="group.proposal.rationale"/>
				<dict:fieldRef bean="group.proposal.detailDesc"/>
				<dict:fieldRef bean="group.proposal.effectiveDate"/>
				<dict:fieldRef bean="group.proposal.expirationDate"/>
				<dict:fieldRef bean="group.proposal.attributes"/>
				<dict:fieldRef bean="group.proposal.metaInfo"/>
				<dict:fieldRef bean="group.proposal.type"/>
				<dict:fieldRef bean="group.proposal.state"/>
				<dict:fieldRef bean="group.proposal.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before published) -->
				<dict:fieldRef bean="group.proposal.name"/>
				<dict:fieldRef bean="group.proposal.proposerPerson"/>
				<dict:fieldRef bean="group.proposal.proposerOrg"/>
				<dict:fieldRef bean="group.proposal.proposalReferenceType"/>
				<dict:fieldRef bean="group.proposal.proposalReference"/>
				<dict:fieldRef bean="group.proposal.rationale"/>
				<dict:fieldRef bean="group.proposal.detailDesc"/>
				<dict:fieldRef bean="group.proposal.effectiveDate"/>
				<dict:fieldRef bean="group.proposal.expirationDate"/>
				<dict:fieldRef bean="group.proposal.attributes"/>
				<dict:fieldRef bean="group.proposal.metaInfo"/>
				<dict:fieldRef bean="group.proposal.type"/>
				<dict:fieldRef bean="group.proposal.state"/>
				<dict:fieldRef bean="group.proposal.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- we may have to differentiate between 'retired' and proposals that are simply 'older versions' -->
				<dict:fieldRef bean="group.proposal.name"/>
				<dict:fieldRef bean="group.proposal.proposerPerson"/>
				<dict:fieldRef bean="group.proposal.proposerOrg"/>
				<dict:fieldRef bean="group.proposal.proposalReferenceType"/>
				<dict:fieldRef bean="group.proposal.proposalReference"/>
				<dict:fieldRef bean="group.proposal.rationale"/>
				<dict:fieldRef bean="group.proposal.detailDesc"/>
				<dict:fieldRef bean="group.proposal.effectiveDate"/>
				<dict:fieldRef bean="group.proposal.expirationDate"/>
				<dict:fieldRef bean="group.proposal.attributes"/>
				<dict:fieldRef bean="group.proposal.metaInfo"/>
				<dict:fieldRef bean="group.proposal.type"/>
				<dict:fieldRef bean="group.proposal.state"/>
				<dict:fieldRef bean="group.proposal.internal.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- Inactive -->
			<!-- used for proposals created as part of revision history - not sure if we need -->
				<dict:fieldRef bean="group.proposal.name"/>
				<dict:fieldRef bean="group.proposal.proposerPerson"/>
				<dict:fieldRef bean="group.proposal.proposerOrg"/>
				<dict:fieldRef bean="group.proposal.proposalReferenceType"/>
				<dict:fieldRef bean="group.proposal.proposalReference"/>
				<dict:fieldRef bean="group.proposal.rationale"/>
				<dict:fieldRef bean="group.proposal.detailDesc"/>
				<dict:fieldRef bean="group.proposal.effectiveDate"/>
				<dict:fieldRef bean="group.proposal.expirationDate"/>
				<dict:fieldRef bean="group.proposal.attributes"/>
				<dict:fieldRef bean="group.proposal.metaInfo"/>
				<dict:fieldRef bean="group.proposal.type"/>
				<dict:fieldRef bean="group.proposal.state"/>
				<dict:fieldRef bean="group.proposal.internal.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key="org.kuali.student.core.proposal.dto.ProposalDocRelationInfo">
		<!-- Information about the proposal to document relation. -->
		<dict:type key="kuali.proposal.ProposalDocRelationType.syllabus">
		<!-- a syllabus for the clu being proposed -->
			<dict:state key="Active">
			<!-- proposal Doc Relation is Active -->
			<!-- TODO: Add to simple spec -->
				
				<dict:field id="syllabus.proposalId" key="proposalId">
					<dict:fieldDescriptor>
						<dict:name>syllabus proposalId</dict:name>
						<dict:desc>syllabus proposalId</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="related.proposal"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="syllabus.documentId" key="documentId">
					<dict:fieldDescriptor>
						<dict:name>syllabus documentId</dict:name>
						<dict:desc>syllabus documentId</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="related.document"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="syllabus.title" key="title">
					<dict:fieldDescriptor>
						<dict:name>syllabus title</dict:name>
						<dict:desc>syllabus title</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
							<dict:constraint key="in-line.constraint.for.dictionary.syllabus.title">
								<dict:minLength>1</dict:minLength>
								<dict:maxLength>100</dict:maxLength>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="syllabus.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>syllabus desc</dict:name>
						<dict:desc>syllabus desc</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="syllabus.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>syllabus desc plain text</dict:name>
												<dict:desc>syllabus desc plain text</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.syllabus.desc.plain">
														<dict:minLength>0</dict:minLength>
														<dict:maxLength>200</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="syllabus.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>syllabus desc formatted</dict:name>
												<dict:desc>syllabus desc formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.syllabus.desc.formatted">
														<dict:minLength>0</dict:minLength>
														<dict:maxLength>200</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="syllabus.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>syllabus effectiveDate</dict:name>
						<dict:desc>syllabus effectiveDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="syllabus.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>syllabus expirationDate</dict:name>
						<dict:desc>syllabus expirationDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="syllabus.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>syllabus attributes</dict:name>
						<dict:desc>syllabus attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="syllabus.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>syllabus metaInfo</dict:name>
						<dict:desc>syllabus metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="syllabus.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>syllabus meta versionInd</dict:name>
												<dict:desc>Version number for this syllabus</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="syllabus.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>syllabus meta createTime</dict:name>
												<dict:desc>Date-time this syllabus was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="syllabus.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>syllabus meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this syllabus</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="syllabus.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>syllabus meta updateTime</dict:name>
												<dict:desc>Date-time this  syllabus was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="syllabus.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>syllabus meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this  syllabus</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="syllabus.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>syllabus proposalId</dict:name>
						<dict:desc>syllabus proposalId</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="hard.coded.syllabus"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="syllabus.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>syllabus documentId</dict:name>
						<dict:desc>syllabus documentId</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="syllabus.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>syllabus title</dict:name>
						<dict:desc>syllabus title</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="Inactive">
			<!-- proposal Doc Relation is Inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="syllabus.proposalId"/>
				<dict:fieldRef bean="syllabus.documentId"/>
				<dict:fieldRef bean="syllabus.title"/>
				<dict:fieldRef bean="syllabus.desc"/>
				<dict:fieldRef bean="syllabus.effectiveDate"/>
				<dict:fieldRef bean="syllabus.expirationDate"/>
				<dict:fieldRef bean="syllabus.attributes"/>
				<dict:fieldRef bean="syllabus.metaInfo"/>
				<dict:fieldRef bean="syllabus.type"/>
				<dict:fieldRef bean="syllabus.state"/>
				<dict:fieldRef bean="syllabus.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.proposal.ProposalDocRelationType.other">
		<!-- supporting documentation does not fit into another category -->
			<dict:state key="Active">
			<!-- proposal Doc Relation is Active -->
			<!-- TODO: Add to simple spec -->
				
				<dict:field id="other.attachment.proposalId" key="proposalId">
					<dict:fieldDescriptor>
						<dict:name>other proposalId</dict:name>
						<dict:desc>other proposalId</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="related.proposal"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="other.attachment.documentId" key="documentId">
					<dict:fieldDescriptor>
						<dict:name>other documentId</dict:name>
						<dict:desc>other documentId</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="related.document"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="other.attachment.title" key="title">
					<dict:fieldDescriptor>
						<dict:name>other title</dict:name>
						<dict:desc>other title</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
							<dict:constraint key="in-line.constraint.for.dictionary.other.attachment.title">
								<dict:minLength>1</dict:minLength>
								<dict:maxLength>100</dict:maxLength>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="other.attachment.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>other desc</dict:name>
						<dict:desc>other desc</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="other.attachment.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>other desc plain text</dict:name>
												<dict:desc>other desc plain text</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.other.attachment.desc.plain">
														<dict:minLength>0</dict:minLength>
														<dict:maxLength>200</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="other.attachment.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>other desc formatted</dict:name>
												<dict:desc>other desc formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.other.attachment.desc.formatted">
														<dict:minLength>0</dict:minLength>
														<dict:maxLength>200</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="other.attachment.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>other effectiveDate</dict:name>
						<dict:desc>other effectiveDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="other.attachment.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>other expirationDate</dict:name>
						<dict:desc>other expirationDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="other.attachment.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>other attributes</dict:name>
						<dict:desc>other attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="other.attachment.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>other metaInfo</dict:name>
						<dict:desc>other metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="other.attachment.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>other meta versionInd</dict:name>
												<dict:desc>Version number for this other</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="other.attachment.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>other meta createTime</dict:name>
												<dict:desc>Date-time this other was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="other.attachment.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>other meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this other</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="other.attachment.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>other meta updateTime</dict:name>
												<dict:desc>Date-time this  other was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="other.attachment.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>other meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this  other</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="other.attachment.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>other proposalId</dict:name>
						<dict:desc>other proposalId</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="hard.coded.other.document"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="other.attachment.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>other documentId</dict:name>
						<dict:desc>other documentId</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="other.attachment.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>other title</dict:name>
						<dict:desc>other title</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="Inactive">
			<!-- proposal Doc Relation is Inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="other.attachment.proposalId"/>
				<dict:fieldRef bean="other.attachment.documentId"/>
				<dict:fieldRef bean="other.attachment.title"/>
				<dict:fieldRef bean="other.attachment.desc"/>
				<dict:fieldRef bean="other.attachment.effectiveDate"/>
				<dict:fieldRef bean="other.attachment.expirationDate"/>
				<dict:fieldRef bean="other.attachment.attributes"/>
				<dict:fieldRef bean="other.attachment.metaInfo"/>
				<dict:fieldRef bean="other.attachment.type"/>
				<dict:fieldRef bean="other.attachment.state"/>
				<dict:fieldRef bean="other.attachment.internal.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key="org.kuali.student.core.document.dto.DocumentInfo">
		<!-- Detailed information about a document. -->
		<dict:type key="kuali.document.type.file">
		<!-- A document that contains an uploaded file -->
		<!-- NOT IN SIMPLES - services said they will make the change to the type as documented in jira item 121 -->
			<dict:state key="Active">
			<!-- document is active -->
			<!-- TODO: Add to simple spec -->
				
				<dict:field id="file.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>file name</dict:name>
						<dict:desc>file name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="file.fileName" key="fileName">
					<dict:fieldDescriptor>
						<dict:name>file fileName</dict:name>
						<dict:desc>file fileName</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="file.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>file desc</dict:name>
						<dict:desc>file desc</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="file.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>file desc plain text</dict:name>
												<dict:desc>file desc plain text</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="file.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>file desc formatted</dict:name>
												<dict:desc>file desc formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="file.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>file effectiveDate</dict:name>
						<dict:desc>file effectiveDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="file.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>file expirationDate</dict:name>
						<dict:desc>file expirationDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="file.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>file attributes</dict:name>
						<dict:desc>file attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="file.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>file metaInfo</dict:name>
						<dict:desc>file metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="file.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>file meta versionInd</dict:name>
												<dict:desc>Version number for this file</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="file.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>file meta createTime</dict:name>
												<dict:desc>Date-time this file was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="file.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>file meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this file</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="file.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>file meta updateTime</dict:name>
												<dict:desc>Date-time this  file was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="file.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>file meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this  file</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="file.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>file type</dict:name>
						<dict:desc>file type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="hard.coded.file"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="file.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>file state</dict:name>
						<dict:desc>file state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="file.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>file internal id</dict:name>
						<dict:desc>file internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="Inactive">
			<!-- document is inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="file.name"/>
				<dict:fieldRef bean="file.fileName"/>
				<dict:fieldRef bean="file.desc"/>
				<dict:fieldRef bean="file.effectiveDate"/>
				<dict:fieldRef bean="file.expirationDate"/>
				<dict:fieldRef bean="file.attributes"/>
				<dict:fieldRef bean="file.metaInfo"/>
				<dict:fieldRef bean="file.type"/>
				<dict:fieldRef bean="file.state"/>
				<dict:fieldRef bean="file.internal.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key="org.kuali.student.core.comment.dto.CommentInfo">
		<!-- Detailed information about a comment. -->
		<dict:type key="kuali.comment.type.proposal.public">
		<!-- Comments that are visible to anyone who can view the associated proposal -->
		<!-- not in SIMPLES -->
			<dict:state key="active">
			<!-- comment is active -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				
				<dict:field id="public.comment.commentText" key="commentText">
					<dict:fieldDescriptor>
						<dict:name>public comment commentText</dict:name>
						<dict:desc>public comment commentText</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="public.comment.commentText.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>public comment desc plain</dict:name>
												<dict:desc>public comment desc plain</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.public.comment.commentText.plain">
														<dict:maxLength>1000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="public.comment.commentText.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>public comment desc formatted</dict:name>
												<dict:desc>public comment desc formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.public.comment.commentText.formatted">
														<dict:maxLength>1000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="public.comment.referenceTypeKey" key="referenceTypeKey">
					<dict:fieldDescriptor>
						<dict:name>public comment referenceTypeKey</dict:name>
						<dict:desc>public comment referenceTypeKey</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="reference.types"/>
							<dict:constraintRef bean="hard.coded.referenceType.Proposal"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="public.comment.referenceId" key="referenceId">
					<dict:fieldDescriptor>
						<dict:name>public comment referenceId</dict:name>
						<dict:desc>public comment referenceId</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="related.proposal"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="public.comment.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>public comment effectiveDate</dict:name>
						<dict:desc>public comment effectiveDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="public.comment.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>public comment expirationDate</dict:name>
						<dict:desc>public comment expirationDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="public.comment.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>public comment attributes</dict:name>
						<dict:desc>public comment attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="public.comment.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>public comment metaInfo</dict:name>
						<dict:desc>public comment metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="public.comment.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>file meta versionInd</dict:name>
												<dict:desc>Version number for this file</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="public.comment.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>file meta createTime</dict:name>
												<dict:desc>Date-time this file was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="public.comment.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>file meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this file</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="public.comment.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>file meta updateTime</dict:name>
												<dict:desc>Date-time this  file was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="public.comment.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>file meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this  file</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="public.comment.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>public comment type</dict:name>
						<dict:desc>public comment type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="public.comment.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>public comment state</dict:name>
						<dict:desc>public comment state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="public.comment.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>public comment internal id</dict:name>
						<dict:desc>public comment internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="inactive">
			<!-- comment is inactive -->
			<!-- States have not been thought through for results, these are intial stakes - will need to ADD TO Simples -->
				<dict:fieldRef bean="public.comment.commentText"/>
				<dict:fieldRef bean="public.comment.referenceTypeKey"/>
				<dict:fieldRef bean="public.comment.referenceId"/>
				<dict:fieldRef bean="public.comment.effectiveDate"/>
				<dict:fieldRef bean="public.comment.expirationDate"/>
				<dict:fieldRef bean="public.comment.attributes"/>
				<dict:fieldRef bean="public.comment.metaInfo"/>
				<dict:fieldRef bean="public.comment.type"/>
				<dict:fieldRef bean="public.comment.state"/>
				<dict:fieldRef bean="public.comment.internal.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
</beans>
