<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:dict="http://student.kuali.org/xsd/dictionary-extension"
xsi:schemaLocation="
http://student.kuali.org/xsd/dictionary-extension http://student.kuali.org/xsd/dictionary-extension/dictionary-extension.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
">
<!-- *** Automatically Generated ***
by: org.kuali.student.dictionary.writer.dict.DictionaryModelWriter
Using:Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls   and: Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls
 -->

<!-- ******************************************** -->
<!-- object structure for object.lrDefinitionInfo -->
<!-- ******************************************** -->
<!-- Detailed information about a learning result definition. -->
<dict:objectStructure key="NOT_FOUND.LrDefinitionInfo" id="object.lrDefinitionInfo.abstract" abstract="true">
	<dict:typeRef bean="type.lrDefinitionInfo"/>
</dict:objectStructure>
<dict:objectStructure key="NOT_FOUND.LrDefinitionInfo" id="object.lrDefinitionInfo" parent="object.lrDefinitionInfo.abstract"/>

<dict:type key="*" id="type.lrDefinitionInfo.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="state.lrDefinitionInfo"/>
</dict:type>
<dict:type key="*" id="type.lrDefinitionInfo" parent="type.lrDefinitionInfo.abstract"/>

<!-- **************************************************** -->
<!-- State for state.lrDefinitionInfo.(default).(default) -->
<!-- **************************************************** -->

<dict:state key="*" id="state.lrDefinitionInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.lrDefinitionInfo.name"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.desc"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.lrType"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.lrScale"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.value"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.operator"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.metaInfo"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.lrDefinitionId"/>
</dict:state>
<dict:state key="*" id="state.lrDefinitionInfo" parent="state.lrDefinitionInfo.abstract"/>


<dict:field key="name" id="field.lrDefinitionInfo.name.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.lrDefinitionInfo.name.fd"/>
	<dict:constraintDescriptorRef bean="field.lrDefinitionInfo.name.cd"/>
</dict:field>
<dict:field key="name" id="field.lrDefinitionInfo.name" parent="field.lrDefinitionInfo.name.abstract"/>
<dict:fieldDescriptor id="field.lrDefinitionInfo.name.fd.abstract" abstract="true">
	<dict:name>Learning Result Definition Name</dict:name>
	<dict:desc>Friendly name for the learning result definition.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.lrDefinitionInfo.name.fd" parent="field.lrDefinitionInfo.name.fd.abstract"/>
<!-- Required; Single valued (non-repeating); A basic single line of text, no embedded carraige returns or tabs limited to 255 -->
<dict:constraintDescriptor id="field.lrDefinitionInfo.name.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.single.line.text"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="name" id="field.lrDefinitionInfo.name.cd" parent="field.lrDefinitionInfo.name.cd.abstract"/>

<dict:field key="desc" id="field.lrDefinitionInfo.desc.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.lrDefinitionInfo.desc.fd"/>
	<dict:constraintDescriptorRef bean="field.lrDefinitionInfo.desc.cd"/>
</dict:field>
<dict:field key="desc" id="field.lrDefinitionInfo.desc" parent="field.lrDefinitionInfo.desc.abstract"/>
<dict:fieldDescriptor id="field.lrDefinitionInfo.desc.fd.abstract" abstract="true">
	<dict:name>Learning Result Definition Description</dict:name>
	<dict:desc>Any finite sequence of characters with letters, numerals, symbols and punctuation marks. The length can be any natural number between zero or any positive integer.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.lrDefinitionInfo.desc.fd" parent="field.lrDefinitionInfo.desc.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Multi-line text field that accepts all printable characters plus tab, carraige-return and linefeed. -->
<dict:constraintDescriptor id="field.lrDefinitionInfo.desc.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.multi.line.text"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="desc" id="field.lrDefinitionInfo.desc.cd" parent="field.lrDefinitionInfo.desc.cd.abstract"/>

<dict:field key="lrType" id="field.lrDefinitionInfo.lrType.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.lrDefinitionInfo.lrType.fd"/>
	<dict:constraintDescriptorRef bean="field.lrDefinitionInfo.lrType.cd"/>
</dict:field>
<dict:field key="lrType" id="field.lrDefinitionInfo.lrType" parent="field.lrDefinitionInfo.lrType.abstract"/>
<dict:fieldDescriptor id="field.lrDefinitionInfo.lrType.fd.abstract" abstract="true">
	<dict:name>Learning Result Type</dict:name>
	<dict:desc>Unique identifier for a learning result type. This is immutable once set.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.lrDefinitionInfo.lrType.fd" parent="field.lrDefinitionInfo.lrType.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of valid learning result definition types -->
<dict:constraintDescriptor id="field.lrDefinitionInfo.lrType.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.lrd.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="lrType" id="field.lrDefinitionInfo.lrType.cd" parent="field.lrDefinitionInfo.lrType.cd.abstract"/>

<!-- The lrScaleTypeKey as a type is deprected so I am not sure if it is really in use or if it should really point to a different type "scaleKey"?  

This field does not make sense. The GradeKey points to the GradeInfo object that tells us what the scale is -->
<dict:field key="lrScale" id="field.lrDefinitionInfo.lrScale.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.lrDefinitionInfo.lrScale.fd"/>
	<dict:constraintDescriptorRef bean="field.lrDefinitionInfo.lrScale.cd"/>
</dict:field>
<dict:field key="lrScale" id="field.lrDefinitionInfo.lrScale" parent="field.lrDefinitionInfo.lrScale.abstract"/>
<dict:fieldDescriptor id="field.lrDefinitionInfo.lrScale.fd.abstract" abstract="true">
	<dict:name>Learning Result Scale</dict:name>
	<dict:desc>Unique identifier for a learning result scale type. This is immutable once set.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.lrDefinitionInfo.lrScale.fd" parent="field.lrDefinitionInfo.lrScale.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of valid learning result scale types -->
<dict:constraintDescriptor id="field.lrDefinitionInfo.lrScale.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.learning.result.scale.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="lrScale" id="field.lrDefinitionInfo.lrScale.cd" parent="field.lrDefinitionInfo.lrScale.cd.abstract"/>

<!-- Isn't this really an ID or KEY that points to either a GradeInfo or a CreditInfo or a CredentialInfo object similar to resultComponentInfo.resultValueIds? -->
<dict:field key="value" id="field.lrDefinitionInfo.value.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.lrDefinitionInfo.value.fd"/>
	<dict:constraintDescriptorRef bean="field.lrDefinitionInfo.value.cd"/>
</dict:field>
<dict:field key="value" id="field.lrDefinitionInfo.value" parent="field.lrDefinitionInfo.value.abstract"/>
<dict:fieldDescriptor id="field.lrDefinitionInfo.value.fd.abstract" abstract="true">
	<dict:name>Learning Result Value</dict:name>
	<dict:desc>Value for the learning result.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.lrDefinitionInfo.value.fd" parent="field.lrDefinitionInfo.value.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.lrDefinitionInfo.value.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.lrDefinitionInfo.value.cd" parent="field.lrDefinitionInfo.value.cd.abstract"/>

<dict:field key="operator" id="field.lrDefinitionInfo.operator.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.lrDefinitionInfo.operator.fd"/>
	<dict:constraintDescriptorRef bean="field.lrDefinitionInfo.operator.cd"/>
</dict:field>
<dict:field key="operator" id="field.lrDefinitionInfo.operator" parent="field.lrDefinitionInfo.operator.abstract"/>
<dict:fieldDescriptor id="field.lrDefinitionInfo.operator.fd.abstract" abstract="true">
	<dict:name>operator</dict:name>
	<dict:desc>The operator to use with the value, such as &gt;= (greater than or equal to)</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.lrDefinitionInfo.operator.fd" parent="field.lrDefinitionInfo.operator.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Alphanumeric code, hypen and period.; In list of configured learning result definition operators (=, >, < etc) -->
<dict:constraintDescriptor id="field.lrDefinitionInfo.operator.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.code"/>
	<dict:constraintRef bean="constraint.lrd.operators"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="operator" id="field.lrDefinitionInfo.operator.cd" parent="field.lrDefinitionInfo.operator.cd.abstract"/>

<dict:field key="metaInfo" id="field.lrDefinitionInfo.metaInfo.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.lrDefinitionInfo.metaInfo.fd"/>
	<dict:constraintDescriptorRef bean="field.lrDefinitionInfo.metaInfo.cd"/>
</dict:field>
<dict:field key="metaInfo" id="field.lrDefinitionInfo.metaInfo" parent="field.lrDefinitionInfo.metaInfo.abstract"/>
<dict:fieldDescriptor id="field.lrDefinitionInfo.metaInfo.fd.abstract" abstract="true">
	<dict:name>Create/Update meta info</dict:name>
	<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
	<dict:dataType>Complex</dict:dataType>
		<dict:objectStructureRef bean="object.field.lrDefinitionInfo.metaInfo"/>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.lrDefinitionInfo.metaInfo.fd" parent="field.lrDefinitionInfo.metaInfo.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Kuali Meta Data: calculated by service, read-only; Read Only -->
<dict:constraintDescriptor id="field.lrDefinitionInfo.metaInfo.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.meta.data"/>
	<dict:constraintRef bean="constraint.read.only"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="metaInfo" id="field.lrDefinitionInfo.metaInfo.cd" parent="field.lrDefinitionInfo.metaInfo.cd.abstract"/>

<!-- ******************************************************************************* -->
<!-- object structure for object.field.lrDefinitionInfo.metaInfo.(default).(default) -->
<!-- ******************************************************************************* -->
<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="object.field.lrDefinitionInfo.metaInfo.abstract" abstract="true">
	<dict:typeRef bean="type.field.lrDefinitionInfo.metaInfo"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="object.field.lrDefinitionInfo.metaInfo" parent="object.field.lrDefinitionInfo.metaInfo.abstract"/>

<dict:type key="*" id="type.field.lrDefinitionInfo.metaInfo.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="state.field.lrDefinitionInfo.metaInfo"/>
</dict:type>
<dict:type key="*" id="type.field.lrDefinitionInfo.metaInfo" parent="type.field.lrDefinitionInfo.metaInfo.abstract"/>

<!-- *************************************************************************************** -->
<!-- State for state.field.lrDefinitionInfo.metaInfo.(default).(default).(default).(default) -->
<!-- *************************************************************************************** -->

<dict:state key="*" id="state.field.lrDefinitionInfo.metaInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.lrDefinitionInfo.metaInfo.versionInd"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.metaInfo.createTime"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.metaInfo.createId"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.metaInfo.updateTime"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.metaInfo.updateId"/>
</dict:state>
<dict:state key="*" id="state.field.lrDefinitionInfo.metaInfo" parent="state.field.lrDefinitionInfo.metaInfo.abstract"/>


<dict:field key="versionInd" id="field.lrDefinitionInfo.metaInfo.versionInd.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.lrDefinitionInfo.metaInfo.versionInd.fd"/>
	<dict:constraintDescriptorRef bean="field.lrDefinitionInfo.metaInfo.versionInd.cd"/>
</dict:field>
<dict:field key="versionInd" id="field.lrDefinitionInfo.metaInfo.versionInd" parent="field.lrDefinitionInfo.metaInfo.versionInd.abstract"/>
<dict:fieldDescriptor id="field.lrDefinitionInfo.metaInfo.versionInd.fd.abstract" abstract="true">
	<dict:name>Version Indicator</dict:name>
	<dict:desc>An indicator of the version of the thing being described with this meta information. This is set by the service implementation and will be used to determine conflicts in updates.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.lrDefinitionInfo.metaInfo.versionInd.fd" parent="field.lrDefinitionInfo.metaInfo.versionInd.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Calculates the version indicator that is used for optimistic locking; Read Only -->
<dict:constraintDescriptor id="field.lrDefinitionInfo.metaInfo.versionInd.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
	<dict:constraintRef bean="constraint.read.only"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="versionInd" id="field.lrDefinitionInfo.metaInfo.versionInd.cd" parent="field.lrDefinitionInfo.metaInfo.versionInd.cd.abstract"/>

<dict:field key="createTime" id="field.lrDefinitionInfo.metaInfo.createTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.lrDefinitionInfo.metaInfo.createTime.fd"/>
	<dict:constraintDescriptorRef bean="field.lrDefinitionInfo.metaInfo.createTime.cd"/>
</dict:field>
<dict:field key="createTime" id="field.lrDefinitionInfo.metaInfo.createTime" parent="field.lrDefinitionInfo.metaInfo.createTime.abstract"/>
<dict:fieldDescriptor id="field.lrDefinitionInfo.metaInfo.createTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Created</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was created</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.lrDefinitionInfo.metaInfo.createTime.fd" parent="field.lrDefinitionInfo.metaInfo.createTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Defaults to NOW, when the object is created -->
<dict:constraintDescriptor id="field.lrDefinitionInfo.metaInfo.createTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.default.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createTime" id="field.lrDefinitionInfo.metaInfo.createTime.cd" parent="field.lrDefinitionInfo.metaInfo.createTime.cd.abstract"/>

<dict:field key="createId" id="field.lrDefinitionInfo.metaInfo.createId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.lrDefinitionInfo.metaInfo.createId.fd"/>
	<dict:constraintDescriptorRef bean="field.lrDefinitionInfo.metaInfo.createId.cd"/>
</dict:field>
<dict:field key="createId" id="field.lrDefinitionInfo.metaInfo.createId" parent="field.lrDefinitionInfo.metaInfo.createId.abstract"/>
<dict:fieldDescriptor id="field.lrDefinitionInfo.metaInfo.createId.fd.abstract" abstract="true">
	<dict:name>Created By Identifier</dict:name>
	<dict:desc>The principal who created the thing being described with this meta information</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.lrDefinitionInfo.metaInfo.createId.fd" parent="field.lrDefinitionInfo.metaInfo.createId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Defaults to the currently authenticated user -->
<dict:constraintDescriptor id="field.lrDefinitionInfo.metaInfo.createId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createId" id="field.lrDefinitionInfo.metaInfo.createId.cd" parent="field.lrDefinitionInfo.metaInfo.createId.cd.abstract"/>

<dict:field key="updateTime" id="field.lrDefinitionInfo.metaInfo.updateTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.lrDefinitionInfo.metaInfo.updateTime.fd"/>
	<dict:constraintDescriptorRef bean="field.lrDefinitionInfo.metaInfo.updateTime.cd"/>
</dict:field>
<dict:field key="updateTime" id="field.lrDefinitionInfo.metaInfo.updateTime" parent="field.lrDefinitionInfo.metaInfo.updateTime.abstract"/>
<dict:fieldDescriptor id="field.lrDefinitionInfo.metaInfo.updateTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Last Updated</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was last updated. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.lrDefinitionInfo.metaInfo.updateTime.fd" parent="field.lrDefinitionInfo.metaInfo.updateTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Sets a field to the current time -->
<dict:constraintDescriptor id="field.lrDefinitionInfo.metaInfo.updateTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.calc.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateTime" id="field.lrDefinitionInfo.metaInfo.updateTime.cd" parent="field.lrDefinitionInfo.metaInfo.updateTime.cd.abstract"/>

<dict:field key="updateId" id="field.lrDefinitionInfo.metaInfo.updateId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.lrDefinitionInfo.metaInfo.updateId.fd"/>
	<dict:constraintDescriptorRef bean="field.lrDefinitionInfo.metaInfo.updateId.cd"/>
</dict:field>
<dict:field key="updateId" id="field.lrDefinitionInfo.metaInfo.updateId" parent="field.lrDefinitionInfo.metaInfo.updateId.abstract"/>
<dict:fieldDescriptor id="field.lrDefinitionInfo.metaInfo.updateId.fd.abstract" abstract="true">
	<dict:name>Updated By Identifier</dict:name>
	<dict:desc>The principal who last updated the thing being described with this meta information. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.lrDefinitionInfo.metaInfo.updateId.fd" parent="field.lrDefinitionInfo.metaInfo.updateId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Sets a field to the currently authenticated user -->
<dict:constraintDescriptor id="field.lrDefinitionInfo.metaInfo.updateId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateId" id="field.lrDefinitionInfo.metaInfo.updateId.cd" parent="field.lrDefinitionInfo.metaInfo.updateId.cd.abstract"/>

<dict:field key="lrDefinitionId" id="field.lrDefinitionInfo.lrDefinitionId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.lrDefinitionInfo.lrDefinitionId.fd"/>
	<dict:constraintDescriptorRef bean="field.lrDefinitionInfo.lrDefinitionId.cd"/>
</dict:field>
<dict:field key="lrDefinitionId" id="field.lrDefinitionInfo.lrDefinitionId" parent="field.lrDefinitionInfo.lrDefinitionId.abstract"/>
<dict:fieldDescriptor id="field.lrDefinitionInfo.lrDefinitionId.fd.abstract" abstract="true">
	<dict:name>Learning Result Definition Id</dict:name>
	<dict:desc>Unique identifier for a learning result definition record. This is optional, due to the identifier being set at the time of creation. Once the result definition has been created, this should be seen as required.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.lrDefinitionInfo.lrDefinitionId.fd" parent="field.lrDefinitionInfo.lrDefinitionId.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Kuali ID; calculated by service on add, then read-only. -->
<dict:constraintDescriptor id="field.lrDefinitionInfo.lrDefinitionId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.id"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="lrDefinitionId" id="field.lrDefinitionInfo.lrDefinitionId.cd" parent="field.lrDefinitionInfo.lrDefinitionId.cd.abstract"/>
</beans>
