<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:dict="http://student.kuali.org/xsd/dictionary-extension"
xsi:schemaLocation="
http://student.kuali.org/xsd/dictionary-extension http://student.kuali.org/xsd/dictionary-extension/dictionary-extension.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
">
<!-- *** Automatically Generated ***
by: org.kuali.student.dictionary.writer.dict.DictionaryModelWriter
Using:Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls   and: Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls
 -->

<!-- ************************************** -->
<!-- object structure for object.creditInfo -->
<!-- ************************************** -->
<!-- Detailed information about a credit value. -->
<dict:objectStructure key="org.kuali.student.lum.lrc.dto.CreditInfo" id="object.creditInfo.abstract" abstract="true">
	<dict:typeRef bean="type.creditInfo"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.lum.lrc.dto.CreditInfo" id="object.creditInfo" parent="object.creditInfo.abstract"/>

<dict:type key="*" id="type.creditInfo.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="state.creditInfo"/>
</dict:type>
<dict:type key="*" id="type.creditInfo" parent="type.creditInfo.abstract"/>

<!-- ********************************************** -->
<!-- State for state.creditInfo.(default).(default) -->
<!-- ********************************************** -->

<dict:state key="*" id="state.creditInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.creditInfo.name"/>
	<dict:fieldRef bean="field.creditInfo.desc"/>
	<dict:fieldRef bean="field.creditInfo.value"/>
	<dict:fieldRef bean="field.creditInfo.effectiveDate"/>
	<dict:fieldRef bean="field.creditInfo.expirationDate"/>
	<dict:fieldRef bean="field.creditInfo.type"/>
	<dict:fieldRef bean="field.creditInfo.id"/>
</dict:state>
<dict:state key="*" id="state.creditInfo" parent="state.creditInfo.abstract"/>


<dict:field key="name" id="field.creditInfo.name.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.creditInfo.name.fd"/>
	<dict:constraintDescriptorRef bean="field.creditInfo.name.cd"/>
</dict:field>
<dict:field key="name" id="field.creditInfo.name" parent="field.creditInfo.name.abstract"/>
<dict:fieldDescriptor id="field.creditInfo.name.fd.abstract" abstract="true">
	<dict:name>Credit Name</dict:name>
	<dict:desc>Name of this credit. This may have a direct relation to the combination of value and type fields.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.creditInfo.name.fd" parent="field.creditInfo.name.fd.abstract"/>
<!-- Required; Single valued (non-repeating); A basic single line of text, no embedded carraige returns or tabs limited to 255 -->
<dict:constraintDescriptor id="field.creditInfo.name.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.single.line.text"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="name" id="field.creditInfo.name.cd" parent="field.creditInfo.name.cd.abstract"/>

<dict:field key="desc" id="field.creditInfo.desc.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.creditInfo.desc.fd"/>
	<dict:constraintDescriptorRef bean="field.creditInfo.desc.cd"/>
</dict:field>
<dict:field key="desc" id="field.creditInfo.desc" parent="field.creditInfo.desc.abstract"/>
<dict:fieldDescriptor id="field.creditInfo.desc.fd.abstract" abstract="true">
	<dict:name>Credit Description</dict:name>
	<dict:desc>Description of this credit.</dict:desc>
	<dict:dataType>Complex</dict:dataType>
		<dict:objectStructureRef bean="object.field.creditInfo.desc"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.creditInfo.desc.fd" parent="field.creditInfo.desc.fd.abstract"/>
<!-- Optional; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.creditInfo.desc.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="desc" id="field.creditInfo.desc.cd" parent="field.creditInfo.desc.cd.abstract"/>

<!-- ********************************************************************* -->
<!-- object structure for object.field.creditInfo.desc.(default).(default) -->
<!-- ********************************************************************* -->
<!-- Complex type supporting both a plain text and formatted version of a string. -->
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="object.field.creditInfo.desc.abstract" abstract="true">
	<dict:typeRef bean="type.field.creditInfo.desc"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="object.field.creditInfo.desc" parent="object.field.creditInfo.desc.abstract"/>

<dict:type key="*" id="type.field.creditInfo.desc.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="state.field.creditInfo.desc"/>
</dict:type>
<dict:type key="*" id="type.field.creditInfo.desc" parent="type.field.creditInfo.desc.abstract"/>

<!-- ***************************************************************************** -->
<!-- State for state.field.creditInfo.desc.(default).(default).(default).(default) -->
<!-- ***************************************************************************** -->

<dict:state key="*" id="state.field.creditInfo.desc.abstract" abstract="true">
	<dict:fieldRef bean="field.creditInfo.desc.plain"/>
	<dict:fieldRef bean="field.creditInfo.desc.formatted"/>
</dict:state>
<dict:state key="*" id="state.field.creditInfo.desc" parent="state.field.creditInfo.desc.abstract"/>


<dict:field key="plain" id="field.creditInfo.desc.plain.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.creditInfo.desc.plain.fd"/>
	<dict:constraintDescriptorRef bean="field.creditInfo.desc.plain.cd"/>
</dict:field>
<dict:field key="plain" id="field.creditInfo.desc.plain" parent="field.creditInfo.desc.plain.abstract"/>
<dict:fieldDescriptor id="field.creditInfo.desc.plain.fd.abstract" abstract="true">
	<dict:name>Plain Text</dict:name>
	<dict:desc>Plain version of the text. This may be used for searching.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.creditInfo.desc.plain.fd" parent="field.creditInfo.desc.plain.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Multi-line text field that accepts all printable characters plus tab, carraige-return and linefeed. -->
<dict:constraintDescriptor id="field.creditInfo.desc.plain.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.multi.line.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="plain" id="field.creditInfo.desc.plain.cd" parent="field.creditInfo.desc.plain.cd.abstract"/>

<dict:field key="formatted" id="field.creditInfo.desc.formatted.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.creditInfo.desc.formatted.fd"/>
	<dict:constraintDescriptorRef bean="field.creditInfo.desc.formatted.cd"/>
</dict:field>
<dict:field key="formatted" id="field.creditInfo.desc.formatted" parent="field.creditInfo.desc.formatted.abstract"/>
<dict:fieldDescriptor id="field.creditInfo.desc.formatted.fd.abstract" abstract="true">
	<dict:name>Formatted Text</dict:name>
	<dict:desc>Formatted version of the text.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.creditInfo.desc.formatted.fd" parent="field.creditInfo.desc.formatted.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Text field that accepts all types of characters using some sort of escaping convention along with the ability to specify bolding, font size, color etc. -->
<dict:constraintDescriptor id="field.creditInfo.desc.formatted.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.rich.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="formatted" id="field.creditInfo.desc.formatted.cd" parent="field.creditInfo.desc.formatted.cd.abstract"/>

<dict:field key="value" id="field.creditInfo.value.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.creditInfo.value.fd"/>
	<dict:constraintDescriptorRef bean="field.creditInfo.value.cd"/>
</dict:field>
<dict:field key="value" id="field.creditInfo.value" parent="field.creditInfo.value.abstract"/>
<dict:fieldDescriptor id="field.creditInfo.value.fd.abstract" abstract="true">
	<dict:name>Credit Value</dict:name>
	<dict:desc>The number of the credits. This is typically numeric, but string is used to cover cases such as fractional and unbounded.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.creditInfo.value.fd" parent="field.creditInfo.value.fd.abstract"/>
<!-- Required; Single valued (non-repeating); A basic single line of text, no embedded carraige returns or tabs limited to 255 -->
<dict:constraintDescriptor id="field.creditInfo.value.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.single.line.text"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.creditInfo.value.cd" parent="field.creditInfo.value.cd.abstract"/>

<dict:field key="effectiveDate" id="field.creditInfo.effectiveDate.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.creditInfo.effectiveDate.fd"/>
	<dict:constraintDescriptorRef bean="field.creditInfo.effectiveDate.cd"/>
</dict:field>
<dict:field key="effectiveDate" id="field.creditInfo.effectiveDate" parent="field.creditInfo.effectiveDate.abstract"/>
<dict:fieldDescriptor id="field.creditInfo.effectiveDate.fd.abstract" abstract="true">
	<dict:name>Effective Date</dict:name>
	<dict:desc>Date and time that this credit value became effective. This is a similar concept to the effective date on enumerated values. When an expiration date has been specified, this field must be less than or equal to the expiration date.</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.creditInfo.effectiveDate.fd" parent="field.creditInfo.effectiveDate.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time -->
<dict:constraintDescriptor id="field.creditInfo.effectiveDate.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="effectiveDate" id="field.creditInfo.effectiveDate.cd" parent="field.creditInfo.effectiveDate.cd.abstract"/>

<dict:field key="expirationDate" id="field.creditInfo.expirationDate.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.creditInfo.expirationDate.fd"/>
	<dict:constraintDescriptorRef bean="field.creditInfo.expirationDate.cd"/>
</dict:field>
<dict:field key="expirationDate" id="field.creditInfo.expirationDate" parent="field.creditInfo.expirationDate.abstract"/>
<dict:fieldDescriptor id="field.creditInfo.expirationDate.fd.abstract" abstract="true">
	<dict:name>Expiration Date</dict:name>
	<dict:desc>Date and time that this credit value expires. This is a similar concept to the expiration date on enumerated values. If specified, this should be greater than or equal to the effective date. If this field is not specified, then no expiration date has been currently defined and should automatically be considered greater than the effective date.</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.creditInfo.expirationDate.fd" parent="field.creditInfo.expirationDate.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Date-Time; Must be empty or a date greater than the entity's effective date -->
<dict:constraintDescriptor id="field.creditInfo.expirationDate.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.cross.greaterthan.effective.date"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="expirationDate" id="field.creditInfo.expirationDate.cd" parent="field.creditInfo.expirationDate.cd.abstract"/>

<dict:field key="type" id="field.creditInfo.type.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.creditInfo.type.fd"/>
	<dict:constraintDescriptorRef bean="field.creditInfo.type.cd"/>
</dict:field>
<dict:field key="type" id="field.creditInfo.type" parent="field.creditInfo.type.abstract"/>
<dict:fieldDescriptor id="field.creditInfo.type.fd.abstract" abstract="true">
	<dict:name>Credit Type</dict:name>
	<dict:desc>Unique identifier for a credit type.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.creditInfo.type.fd" parent="field.creditInfo.type.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only -->
<dict:constraintDescriptor id="field.creditInfo.type.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="type" id="field.creditInfo.type.cd" parent="field.creditInfo.type.cd.abstract"/>

<dict:field key="id" id="field.creditInfo.id.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.creditInfo.id.fd"/>
	<dict:constraintDescriptorRef bean="field.creditInfo.id.cd"/>
</dict:field>
<dict:field key="id" id="field.creditInfo.id" parent="field.creditInfo.id.abstract"/>
<dict:fieldDescriptor id="field.creditInfo.id.fd.abstract" abstract="true">
	<dict:name>Credit Identifier</dict:name>
	<dict:desc>Unique identifier for a credit value.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.creditInfo.id.fd" parent="field.creditInfo.id.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Kuali ID; calculated by service on add, then read-only.; Read Only -->
<dict:constraintDescriptor id="field.creditInfo.id.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.id"/>
	<dict:constraintRef bean="constraint.read.only"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="id" id="field.creditInfo.id.cd" parent="field.creditInfo.id.cd.abstract"/>
</beans>
