<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:dict="http://student.kuali.org/xsd/dictionary-extension"
xsi:schemaLocation="
http://student.kuali.org/xsd/dictionary-extension dictionary-extension.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
">
<!-- *** Automatically Generated ***
on: Tue Feb 09 17:01:44 EST 2010
by: org.kuali.student.dictionary.writer.DictionaryModelWriter
Using:Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls   and: Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls
 -->
<import resource="constraints-dictionary-config.xml"/>

<!-- ******************************************* -->
<!-- object structure for object.luStatementInfo -->
<!-- ******************************************* -->
<!-- Detailed information about a single LU statement. -->
<dict:objectStructure key="org.kuali.student.lum.lu.dto.LuStatementInfo" id="object.luStatementInfo.abstract" abstract="true">
	<dict:typeRef bean="object.luStatementInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.lum.lu.dto.LuStatementInfo" id="object.luStatementInfo" parent="object.luStatementInfo.abstract"/>

<dict:type key="*" id="object.luStatementInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="object.luStatementInfo.type.DEFAULT.state.DEFAULT"/>
</dict:type>
<dict:type key="*" id="object.luStatementInfo.type.DEFAULT" parent="object.luStatementInfo.type.DEFAULT.abstract"/>

<!-- **************************************************************** -->
<!-- fields for object.luStatementInfo.type.(default).state.(default) -->
<!-- **************************************************************** -->

<dict:state key="*" id="object.luStatementInfo.type.DEFAULT.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.name"/>
	<dict:fieldRef bean="field.luStatementInfo.desc"/>
	<dict:fieldRef bean="field.luStatementInfo.operator"/>
	<dict:fieldRef bean="field.luStatementInfo.luStatementIds"/>
	<dict:fieldRef bean="field.luStatementInfo.reqComponentIds"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo"/>
	<dict:fieldRef bean="field.luStatementInfo.type"/>
	<dict:fieldRef bean="field.luStatementInfo.state"/>
	<dict:fieldRef bean="field.luStatementInfo.id"/>
</dict:state>
<dict:state key="*" id="object.luStatementInfo.type.DEFAULT.state.DEFAULT" parent="object.luStatementInfo.type.DEFAULT.state.DEFAULT.abstract"/>


<dict:field key="name" id="field.luStatementInfo.name.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.name.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.name.cd"/>
</dict:field>
<dict:field key="name" id="field.luStatementInfo.name" parent="field.luStatementInfo.name.abstract"/>
<dict:fieldDescriptor key="name" id="field.luStatementInfo.name.fd.abstract" abstract="true">
	<dict:name>LU Statement Name</dict:name>
	<dict:desc>Friendly name for the LU statement.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="name" id="field.luStatementInfo.name.fd" parent="field.luStatementInfo.name.fd.abstract"/>
<!-- Required; Single valued (non-repeating); A basic single line of text, no embedded carraige returns or tabs limited to 255 -->
<dict:constraintDescriptor id="field.luStatementInfo.name.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.single.line.text"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="name" id="field.luStatementInfo.name.cd" parent="field.luStatementInfo.name.cd.abstract"/>

<dict:field key="desc" id="field.luStatementInfo.desc.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.cd"/>
</dict:field>
<dict:field key="desc" id="field.luStatementInfo.desc" parent="field.luStatementInfo.desc.abstract"/>
<dict:fieldDescriptor key="desc" id="field.luStatementInfo.desc.fd.abstract" abstract="true">
	<dict:name>LU Statement Description</dict:name>
	<dict:desc>Narrative description for the LU statement.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.desc.richTextInfo"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="desc" id="field.luStatementInfo.desc.fd" parent="field.luStatementInfo.desc.fd.abstract"/>
<!-- Optional; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="desc" id="field.luStatementInfo.desc.cd" parent="field.luStatementInfo.desc.cd.abstract"/>

<!-- ******************************************************************************************* -->
<!-- object structure for field.luStatementInfo.desc.type.(default).state.(default).richTextInfo -->
<!-- ******************************************************************************************* -->
<!-- Complex type supporting both a plain text and formatted version of a string. -->
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="field.luStatementInfo.desc.richTextInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.desc.richTextInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="field.luStatementInfo.desc.richTextInfo" parent="field.luStatementInfo.desc.richTextInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.desc.richTextInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.desc.richTextInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.desc.richTextInfo.type.DEFAULT" parent="field.luStatementInfo.desc.richTextInfo.type.DEFAULT.abstract"/>

<!-- **************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.desc.type.(default).state.(default).richTextInfo.type.(default).state.(default) -->
<!-- **************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.desc.richTextInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.desc.richTextInfo.plain"/>
	<dict:fieldRef bean="field.luStatementInfo.desc.richTextInfo.formatted"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.desc.richTextInfo" parent="field.luStatementInfo.desc.richTextInfo.abstract"/>


<dict:field key="plain" id="field.luStatementInfo.desc.richTextInfo.plain.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.richTextInfo.plain.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.richTextInfo.plain.cd"/>
</dict:field>
<dict:field key="plain" id="field.luStatementInfo.desc.richTextInfo.plain" parent="field.luStatementInfo.desc.richTextInfo.plain.abstract"/>
<dict:fieldDescriptor key="plain" id="field.luStatementInfo.desc.richTextInfo.plain.fd.abstract" abstract="true">
	<dict:name>Plain Text</dict:name>
	<dict:desc>Plain version of the text. This may be used for searching.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="plain" id="field.luStatementInfo.desc.richTextInfo.plain.fd" parent="field.luStatementInfo.desc.richTextInfo.plain.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Multi-line text field that accepts all printable characters plus tab, carraige-return and linefeed. -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.richTextInfo.plain.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.multi.line.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="plain" id="field.luStatementInfo.desc.richTextInfo.plain.cd" parent="field.luStatementInfo.desc.richTextInfo.plain.cd.abstract"/>

<dict:field key="formatted" id="field.luStatementInfo.desc.richTextInfo.formatted.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.richTextInfo.formatted.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.richTextInfo.formatted.cd"/>
</dict:field>
<dict:field key="formatted" id="field.luStatementInfo.desc.richTextInfo.formatted" parent="field.luStatementInfo.desc.richTextInfo.formatted.abstract"/>
<dict:fieldDescriptor key="formatted" id="field.luStatementInfo.desc.richTextInfo.formatted.fd.abstract" abstract="true">
	<dict:name>Formatted Text</dict:name>
	<dict:desc>Formatted version of the text.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="formatted" id="field.luStatementInfo.desc.richTextInfo.formatted.fd" parent="field.luStatementInfo.desc.richTextInfo.formatted.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Text field that accepts all types of characters using some sort of escaping convention along with the ability to specify bolding, font size, color etc. -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.richTextInfo.formatted.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.rich.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="formatted" id="field.luStatementInfo.desc.richTextInfo.formatted.cd" parent="field.luStatementInfo.desc.richTextInfo.formatted.cd.abstract"/>

<dict:field key="operator" id="field.luStatementInfo.operator.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.operator.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.operator.cd"/>
</dict:field>
<dict:field key="operator" id="field.luStatementInfo.operator" parent="field.luStatementInfo.operator.abstract"/>
<dict:fieldDescriptor key="operator" id="field.luStatementInfo.operator.fd.abstract" abstract="true">
	<dict:name>LU Statement Operator</dict:name>
	<dict:desc>Logical operator used to assemble statements. Acceptable values are restricted to AND and OR. This operator applies to both the LU statements and requirement components contained within this statement.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="operator" id="field.luStatementInfo.operator.fd" parent="field.luStatementInfo.operator.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Alphanumeric code, hypen and period.; In list of configured lu statement operators (AND and OR) -->
<dict:constraintDescriptor id="field.luStatementInfo.operator.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.code"/>
	<dict:constraintRef bean="constraint.lu.statement.operators"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="operator" id="field.luStatementInfo.operator.cd" parent="field.luStatementInfo.operator.cd.abstract"/>

<!-- services has both statement ids and requirement component ids as required but this can't be true.  What is required is that either a statement or requirement component is required so there is a cross field constraint but not both -->
<dict:field key="luStatementIds" id="field.luStatementInfo.luStatementIds.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.luStatementIds.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.luStatementIds.cd"/>
</dict:field>
<dict:field key="luStatementIds" id="field.luStatementInfo.luStatementIds" parent="field.luStatementInfo.luStatementIds.abstract"/>
<dict:fieldDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.fd.abstract" abstract="true">
	<dict:name>Contained LU Statement Identifiers</dict:name>
	<dict:desc>List of LU statement identifiers.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.fd" parent="field.luStatementInfo.luStatementIds.fd.abstract"/>
<!-- Optional; Repeating; Id of an existing LU Statement -->
<dict:constraintDescriptor id="field.luStatementInfo.luStatementIds.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
	<dict:constraintRef bean="constraint.related.luStatementd"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.cd" parent="field.luStatementInfo.luStatementIds.cd.abstract"/>

<!-- services has both statement ids and requirement component ids as required but this can't be true.  What is required is that either a statement or requirement component is required so there is a cross field constraint but not both -->
<dict:field key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.reqComponentIds.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.reqComponentIds.cd"/>
</dict:field>
<dict:field key="reqComponentIds" id="field.luStatementInfo.reqComponentIds" parent="field.luStatementInfo.reqComponentIds.abstract"/>
<dict:fieldDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.fd.abstract" abstract="true">
	<dict:name>Contained Requirement Component Identifiers</dict:name>
	<dict:desc>List of requirement component identifiers.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.fd" parent="field.luStatementInfo.reqComponentIds.fd.abstract"/>
<!-- Optional; Repeating; Id of an existing requirement component -->
<dict:constraintDescriptor id="field.luStatementInfo.reqComponentIds.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
	<dict:constraintRef bean="constraint.related.requirementComponentId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.cd" parent="field.luStatementInfo.reqComponentIds.cd.abstract"/>

<dict:field key="attributes" id="field.luStatementInfo.attributes.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.cd"/>
</dict:field>
<dict:field key="attributes" id="field.luStatementInfo.attributes" parent="field.luStatementInfo.attributes.abstract"/>
<dict:fieldDescriptor key="attributes" id="field.luStatementInfo.attributes.fd.abstract" abstract="true">
	<dict:name>Generic/dynamic attributes</dict:name>
	<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.attributes.attributeInfo"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="attributes" id="field.luStatementInfo.attributes.fd" parent="field.luStatementInfo.attributes.fd.abstract"/>
<!-- Optional; Repeating -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="attributes" id="field.luStatementInfo.attributes.cd" parent="field.luStatementInfo.attributes.cd.abstract"/>

<!-- ************************************************************************************************** -->
<!-- object structure for field.luStatementInfo.attributes.type.(default).state.(default).attributeInfo -->
<!-- ************************************************************************************************** -->
<!-- List of key/value pairs, typically used for dynamic attributes. -->
<dict:objectStructure key=".AttributeInfo" id="field.luStatementInfo.attributes.attributeInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.attributes.attributeInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key=".AttributeInfo" id="field.luStatementInfo.attributes.attributeInfo" parent="field.luStatementInfo.attributes.attributeInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.attributes.attributeInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.attributeInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.attributes.attributeInfo.type.DEFAULT" parent="field.luStatementInfo.attributes.attributeInfo.type.DEFAULT.abstract"/>

<!-- *********************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.(default).state.(default).attributeInfo.type.(default).state.(default) -->
<!-- *********************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.attributeInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.attributeInfo.value"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.attributeInfo.key"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.attributeInfo" parent="field.luStatementInfo.attributes.attributeInfo.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.attributeInfo.value.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.attributeInfo.value.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.attributeInfo.value.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.attributeInfo.value" parent="field.luStatementInfo.attributes.attributeInfo.value.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.attributeInfo.value.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.attributeInfo.value.fd" parent="field.luStatementInfo.attributes.attributeInfo.value.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.attributeInfo.value.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.attributeInfo.value.cd" parent="field.luStatementInfo.attributes.attributeInfo.value.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.attributeInfo.key.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.attributeInfo.key.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.attributeInfo.key.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.attributeInfo.key" parent="field.luStatementInfo.attributes.attributeInfo.key.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.attributeInfo.key.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.attributeInfo.key.fd" parent="field.luStatementInfo.attributes.attributeInfo.key.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.attributeInfo.key.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.attributeInfo.key.cd" parent="field.luStatementInfo.attributes.attributeInfo.key.cd.abstract"/>

<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color" id="field.luStatementInfo.attributes.attributeInfo.type.EyeColor.abstract" abstract="true" parent="field.luStatementInfo.attributes.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Eye Color</dict:name>
	<dict:desc>Captures the eye color of students expected to take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.attributeInfo.type.EyeColor.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color" id="field.luStatementInfo.attributes.attributeInfo.type.EyeColor" parent="field.luStatementInfo.attributes.attributeInfo.type.EyeColor.abstract"/>

<!-- *********************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.(default).state.(default).attributeInfo.type.Eye Color.state.(default) -->
<!-- *********************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.attributeInfo.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.attributeInfo.value.type.EyeColor.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.attributeInfo.key.type.EyeColor.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.attributeInfo.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.attributeInfo.type.EyeColor.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.attributeInfo.value.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.attributeInfo.value.type.EyeColor.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.attributeInfo.value.type.EyeColor.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.attributeInfo.value.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.attributeInfo.value.type.EyeColor.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.attributeInfo.value.type.EyeColor.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.attributeInfo.value.type.EyeColor.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.attributeInfo.value.type.EyeColor.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.attributeInfo.value.type.EyeColor.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.attributeInfo.value.type.EyeColor.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.attributeInfo.value.type.EyeColor.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.attributeInfo.key.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.attributeInfo.key.type.EyeColor.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.attributeInfo.key.type.EyeColor.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.attributeInfo.key.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.attributeInfo.key.type.EyeColor.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.attributeInfo.key.type.EyeColor.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.attributeInfo.key.type.EyeColor.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.attributeInfo.key.type.EyeColor.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.attributeInfo.key.type.EyeColor.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.attributeInfo.key.type.EyeColor.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.attributeInfo.key.type.EyeColor.state.DEFAULT.cd.abstract"/>

<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed" id="field.luStatementInfo.attributes.attributeInfo.type.LeftHanded.abstract" abstract="true" parent="field.luStatementInfo.attributes.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Left Handed</dict:name>
	<dict:desc>Captures if the students are expected to be left handed who take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.attributeInfo.type.LeftHanded.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed" id="field.luStatementInfo.attributes.attributeInfo.type.LeftHanded" parent="field.luStatementInfo.attributes.attributeInfo.type.LeftHanded.abstract"/>

<!-- ************************************************************************************************************************* -->
<!-- fields for field.luStatementInfo.attributes.type.(default).state.(default).attributeInfo.type.Left Handed.state.(default) -->
<!-- ************************************************************************************************************************* -->

<dict:state key="*" id="field.luStatementInfo.attributes.attributeInfo.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.attributeInfo.value.type.LeftHanded.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.attributeInfo.key.type.LeftHanded.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.attributeInfo.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.attributeInfo.type.LeftHanded.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.attributeInfo.value.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.attributeInfo.value.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.attributeInfo.value.type.LeftHanded.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.attributeInfo.key.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.attributeInfo.key.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.attributeInfo.key.type.LeftHanded.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd.abstract"/>

<!-- This sequence really belongs on both on CLU-LO and LO-LO relationships for Single Use Los - but the most recent version of the services with the relationships as not in use yet, so it has been put here as a temporary solution -->
<dict:type key="kuali.lo.type.SingleUse.dynamic.sequence" id="field.luStatementInfo.attributes.attributeInfo.type.Sequence.abstract" abstract="true" parent="field.luStatementInfo.attributes.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Sequence</dict:name>
	<dict:desc>Captures the sequence of an LO within a Credit Course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.attributeInfo.type.Sequence.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lo.type.SingleUse.dynamic.sequence" id="field.luStatementInfo.attributes.attributeInfo.type.Sequence" parent="field.luStatementInfo.attributes.attributeInfo.type.Sequence.abstract"/>

<!-- ********************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.(default).state.(default).attributeInfo.type.Sequence.state.(default) -->
<!-- ********************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.attributeInfo.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.attributeInfo.value.type.Sequence.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.attributeInfo.key.type.Sequence.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.attributeInfo.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.attributeInfo.type.Sequence.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.attributeInfo.value.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.attributeInfo.value.type.Sequence.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.attributeInfo.value.type.Sequence.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.attributeInfo.value.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.attributeInfo.value.type.Sequence.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.attributeInfo.value.type.Sequence.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.attributeInfo.value.type.Sequence.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.attributeInfo.value.type.Sequence.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.attributeInfo.value.type.Sequence.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.attributeInfo.value.type.Sequence.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.attributeInfo.value.type.Sequence.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.attributeInfo.key.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.attributeInfo.key.type.Sequence.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.attributeInfo.key.type.Sequence.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.attributeInfo.key.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.attributeInfo.key.type.Sequence.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.attributeInfo.key.type.Sequence.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.attributeInfo.key.type.Sequence.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.attributeInfo.key.type.Sequence.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.attributeInfo.key.type.Sequence.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.attributeInfo.key.type.Sequence.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.attributeInfo.key.type.Sequence.state.DEFAULT.cd.abstract"/>

<dict:field key="metaInfo" id="field.luStatementInfo.metaInfo.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.cd"/>
</dict:field>
<dict:field key="metaInfo" id="field.luStatementInfo.metaInfo" parent="field.luStatementInfo.metaInfo.abstract"/>
<dict:fieldDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.fd.abstract" abstract="true">
	<dict:name>Create/Update meta info</dict:name>
	<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.metaInfo.metaInfo"/>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.fd" parent="field.luStatementInfo.metaInfo.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.cd" parent="field.luStatementInfo.metaInfo.cd.abstract"/>

<!-- ******************************************************************************************* -->
<!-- object structure for field.luStatementInfo.metaInfo.type.(default).state.(default).metaInfo -->
<!-- ******************************************************************************************* -->
<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="field.luStatementInfo.metaInfo.metaInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.metaInfo.metaInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="field.luStatementInfo.metaInfo.metaInfo" parent="field.luStatementInfo.metaInfo.metaInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.metaInfo.metaInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.metaInfo.metaInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.metaInfo.metaInfo.type.DEFAULT" parent="field.luStatementInfo.metaInfo.metaInfo.type.DEFAULT.abstract"/>

<!-- **************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.metaInfo.type.(default).state.(default).metaInfo.type.(default).state.(default) -->
<!-- **************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.metaInfo.metaInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.metaInfo.versionInd"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.metaInfo.createTime"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.metaInfo.createId"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.metaInfo.updateTime"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.metaInfo.updateId"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.metaInfo.metaInfo" parent="field.luStatementInfo.metaInfo.metaInfo.abstract"/>


<dict:field key="versionInd" id="field.luStatementInfo.metaInfo.metaInfo.versionInd.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.metaInfo.versionInd.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.metaInfo.versionInd.cd"/>
</dict:field>
<dict:field key="versionInd" id="field.luStatementInfo.metaInfo.metaInfo.versionInd" parent="field.luStatementInfo.metaInfo.metaInfo.versionInd.abstract"/>
<dict:fieldDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.metaInfo.versionInd.fd.abstract" abstract="true">
	<dict:name>Version Indicator</dict:name>
	<dict:desc>An indicator of the version of the thing being described with this meta information. This is set by the service implementation and will be used to determine conflicts in updates.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.metaInfo.versionInd.fd" parent="field.luStatementInfo.metaInfo.metaInfo.versionInd.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Calculates the version indicator that is used for optimistic locking; Read Only -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.metaInfo.versionInd.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
	<dict:constraintRef bean="constraint.read.only"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.metaInfo.versionInd.cd" parent="field.luStatementInfo.metaInfo.metaInfo.versionInd.cd.abstract"/>

<dict:field key="createTime" id="field.luStatementInfo.metaInfo.metaInfo.createTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.metaInfo.createTime.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.metaInfo.createTime.cd"/>
</dict:field>
<dict:field key="createTime" id="field.luStatementInfo.metaInfo.metaInfo.createTime" parent="field.luStatementInfo.metaInfo.metaInfo.createTime.abstract"/>
<dict:fieldDescriptor key="createTime" id="field.luStatementInfo.metaInfo.metaInfo.createTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Created</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was created</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="createTime" id="field.luStatementInfo.metaInfo.metaInfo.createTime.fd" parent="field.luStatementInfo.metaInfo.metaInfo.createTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Defaults to NOW, when the object is created -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.metaInfo.createTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.default.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createTime" id="field.luStatementInfo.metaInfo.metaInfo.createTime.cd" parent="field.luStatementInfo.metaInfo.metaInfo.createTime.cd.abstract"/>

<dict:field key="createId" id="field.luStatementInfo.metaInfo.metaInfo.createId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.metaInfo.createId.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.metaInfo.createId.cd"/>
</dict:field>
<dict:field key="createId" id="field.luStatementInfo.metaInfo.metaInfo.createId" parent="field.luStatementInfo.metaInfo.metaInfo.createId.abstract"/>
<dict:fieldDescriptor key="createId" id="field.luStatementInfo.metaInfo.metaInfo.createId.fd.abstract" abstract="true">
	<dict:name>Created By Identifier</dict:name>
	<dict:desc>The principal who created the thing being described with this meta information</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="createId" id="field.luStatementInfo.metaInfo.metaInfo.createId.fd" parent="field.luStatementInfo.metaInfo.metaInfo.createId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Defaults to the currently authenticated user -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.metaInfo.createId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createId" id="field.luStatementInfo.metaInfo.metaInfo.createId.cd" parent="field.luStatementInfo.metaInfo.metaInfo.createId.cd.abstract"/>

<dict:field key="updateTime" id="field.luStatementInfo.metaInfo.metaInfo.updateTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.metaInfo.updateTime.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.metaInfo.updateTime.cd"/>
</dict:field>
<dict:field key="updateTime" id="field.luStatementInfo.metaInfo.metaInfo.updateTime" parent="field.luStatementInfo.metaInfo.metaInfo.updateTime.abstract"/>
<dict:fieldDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.metaInfo.updateTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Last Updated</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was last updated. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.metaInfo.updateTime.fd" parent="field.luStatementInfo.metaInfo.metaInfo.updateTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Sets a field to the current time -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.metaInfo.updateTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.calc.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.metaInfo.updateTime.cd" parent="field.luStatementInfo.metaInfo.metaInfo.updateTime.cd.abstract"/>

<dict:field key="updateId" id="field.luStatementInfo.metaInfo.metaInfo.updateId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.metaInfo.updateId.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.metaInfo.updateId.cd"/>
</dict:field>
<dict:field key="updateId" id="field.luStatementInfo.metaInfo.metaInfo.updateId" parent="field.luStatementInfo.metaInfo.metaInfo.updateId.abstract"/>
<dict:fieldDescriptor key="updateId" id="field.luStatementInfo.metaInfo.metaInfo.updateId.fd.abstract" abstract="true">
	<dict:name>Updated By Identifier</dict:name>
	<dict:desc>The principal who last updated the thing being described with this meta information. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="updateId" id="field.luStatementInfo.metaInfo.metaInfo.updateId.fd" parent="field.luStatementInfo.metaInfo.metaInfo.updateId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Sets a field to the currently authenticated user -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.metaInfo.updateId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateId" id="field.luStatementInfo.metaInfo.metaInfo.updateId.cd" parent="field.luStatementInfo.metaInfo.metaInfo.updateId.cd.abstract"/>

<dict:field key="type" id="field.luStatementInfo.type.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.type.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.type.cd"/>
</dict:field>
<dict:field key="type" id="field.luStatementInfo.type" parent="field.luStatementInfo.type.abstract"/>
<dict:fieldDescriptor key="type" id="field.luStatementInfo.type.fd.abstract" abstract="true">
	<dict:name>LU Statement Type Identifier</dict:name>
	<dict:desc>Unique identifier for an LU statement type.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="type" id="field.luStatementInfo.type.fd" parent="field.luStatementInfo.type.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of valid lu statement types -->
<dict:constraintDescriptor id="field.luStatementInfo.type.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.lu.statement.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="type" id="field.luStatementInfo.type.cd" parent="field.luStatementInfo.type.cd.abstract"/>

<dict:field key="state" id="field.luStatementInfo.state.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.state.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.state.cd"/>
</dict:field>
<dict:field key="state" id="field.luStatementInfo.state" parent="field.luStatementInfo.state.abstract"/>
<dict:fieldDescriptor key="state" id="field.luStatementInfo.state.fd.abstract" abstract="true">
	<dict:name>LU Statement State</dict:name>
	<dict:desc>The current status of the LU statement. The values for this field are constrained to those in the luStatementState enumeration. A separate setup operation does not exist for retrieval of the meta data around this value.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="state" id="field.luStatementInfo.state.fd" parent="field.luStatementInfo.state.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali STATE; In list of valid lu statement states -->
<dict:constraintDescriptor id="field.luStatementInfo.state.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.state"/>
	<dict:constraintRef bean="constraint.lu.statement.states"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="state" id="field.luStatementInfo.state.cd" parent="field.luStatementInfo.state.cd.abstract"/>

<dict:field key="id" id="field.luStatementInfo.id.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.id.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.id.cd"/>
</dict:field>
<dict:field key="id" id="field.luStatementInfo.id" parent="field.luStatementInfo.id.abstract"/>
<dict:fieldDescriptor key="id" id="field.luStatementInfo.id.fd.abstract" abstract="true">
	<dict:name>LU Statement Identifier</dict:name>
	<dict:desc>Unique identifier for a single LU statement record. This is optional, due to the identifier being set at the time of creation. Once the LU statement has been created, this should be seen as required.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="id" id="field.luStatementInfo.id.fd" parent="field.luStatementInfo.id.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Kuali ID; calculated by service on add, then read-only. -->
<dict:constraintDescriptor id="field.luStatementInfo.id.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.id"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="id" id="field.luStatementInfo.id.cd" parent="field.luStatementInfo.id.cd.abstract"/>

<dict:type key="kuali.luStatementType.req.*" id="object.luStatementInfo.type.RequisiteTypeRules.abstract" abstract="true" parent="object.luStatementInfo.type.DEFAULT.abstract">
	<dict:name>Requisite Type Rules</dict:name>
	<dict:desc>Group that includes all the &quot;requisite&quot; rules, pre,co,anti and enrollment restrictions</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="object.luStatementInfo.type.RequisiteTypeRules.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.luStatementType.req.*" id="object.luStatementInfo.type.RequisiteTypeRules" parent="object.luStatementInfo.type.RequisiteTypeRules.abstract"/>

<!-- *************************************************************************** -->
<!-- fields for object.luStatementInfo.type.Requisite Type Rules.state.(default) -->
<!-- *************************************************************************** -->

<dict:state key="*" id="object.luStatementInfo.type.RequisiteTypeRules.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.name.type.RequisiteTypeRules.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.operator.type.RequisiteTypeRules.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.luStatementIds.type.RequisiteTypeRules.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.reqComponentIds.type.RequisiteTypeRules.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.type.type.RequisiteTypeRules.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.state.type.RequisiteTypeRules.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.id.type.RequisiteTypeRules.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="object.luStatementInfo.type.RequisiteTypeRules.state.DEFAULT" parent="object.luStatementInfo.type.RequisiteTypeRules.state.DEFAULT.abstract"/>


<dict:field key="name" id="field.luStatementInfo.name.type.RequisiteTypeRules.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.name.type.RequisiteTypeRules.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.name.type.RequisiteTypeRules.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="name" id="field.luStatementInfo.name.type.RequisiteTypeRules.state.DEFAULT" parent="field.luStatementInfo.name.type.RequisiteTypeRules.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="name" id="field.luStatementInfo.name.type.RequisiteTypeRules.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Name</dict:name>
	<dict:desc>Friendly name for the LU statement.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="name" id="field.luStatementInfo.name.type.RequisiteTypeRules.state.DEFAULT.fd" parent="field.luStatementInfo.name.type.RequisiteTypeRules.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); A basic single line of text, no embedded carraige returns or tabs limited to 255 -->
<dict:constraintDescriptor id="field.luStatementInfo.name.type.RequisiteTypeRules.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.single.line.text"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="name" id="field.luStatementInfo.name.type.RequisiteTypeRules.state.DEFAULT.cd" parent="field.luStatementInfo.name.type.RequisiteTypeRules.state.DEFAULT.cd.abstract"/>

<dict:field key="desc" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="desc" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT" parent="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="desc" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Description</dict:name>
	<dict:desc>Narrative description for the LU statement.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="desc" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.fd" parent="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.fd.abstract"/>
<!-- Optional; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="desc" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.cd" parent="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.cd.abstract"/>

<!-- ****************************************************************************************************** -->
<!-- object structure for field.luStatementInfo.desc.type.Requisite Type Rules.state.(default).richTextInfo -->
<!-- ****************************************************************************************************** -->
<!-- Complex type supporting both a plain text and formatted version of a string. -->
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo" parent="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.type.DEFAULT" parent="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.type.DEFAULT.abstract"/>

<!-- *************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.desc.type.Requisite Type Rules.state.(default).richTextInfo.type.(default).state.(default) -->
<!-- *************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.plain"/>
	<dict:fieldRef bean="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.formatted"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo" parent="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.abstract"/>


<dict:field key="plain" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.plain.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.plain.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.plain.cd"/>
</dict:field>
<dict:field key="plain" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.plain" parent="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.plain.abstract"/>
<dict:fieldDescriptor key="plain" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.plain.fd.abstract" abstract="true">
	<dict:name>Plain Text</dict:name>
	<dict:desc>Plain version of the text. This may be used for searching.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="plain" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.plain.fd" parent="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.plain.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Multi-line text field that accepts all printable characters plus tab, carraige-return and linefeed. -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.plain.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.multi.line.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="plain" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.plain.cd" parent="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.plain.cd.abstract"/>

<dict:field key="formatted" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.formatted.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.formatted.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.formatted.cd"/>
</dict:field>
<dict:field key="formatted" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.formatted" parent="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.formatted.abstract"/>
<dict:fieldDescriptor key="formatted" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.formatted.fd.abstract" abstract="true">
	<dict:name>Formatted Text</dict:name>
	<dict:desc>Formatted version of the text.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="formatted" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.formatted.fd" parent="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.formatted.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Text field that accepts all types of characters using some sort of escaping convention along with the ability to specify bolding, font size, color etc. -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.formatted.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.rich.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="formatted" id="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.formatted.cd" parent="field.luStatementInfo.desc.type.RequisiteTypeRules.state.DEFAULT.richTextInfo.formatted.cd.abstract"/>

<dict:field key="operator" id="field.luStatementInfo.operator.type.RequisiteTypeRules.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.operator.type.RequisiteTypeRules.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.operator.type.RequisiteTypeRules.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="operator" id="field.luStatementInfo.operator.type.RequisiteTypeRules.state.DEFAULT" parent="field.luStatementInfo.operator.type.RequisiteTypeRules.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="operator" id="field.luStatementInfo.operator.type.RequisiteTypeRules.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Operator</dict:name>
	<dict:desc>Logical operator used to assemble statements. Acceptable values are restricted to AND and OR. This operator applies to both the LU statements and requirement components contained within this statement.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="operator" id="field.luStatementInfo.operator.type.RequisiteTypeRules.state.DEFAULT.fd" parent="field.luStatementInfo.operator.type.RequisiteTypeRules.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Alphanumeric code, hypen and period.; In list of configured lu statement operators (AND and OR) -->
<dict:constraintDescriptor id="field.luStatementInfo.operator.type.RequisiteTypeRules.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.code"/>
	<dict:constraintRef bean="constraint.lu.statement.operators"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="operator" id="field.luStatementInfo.operator.type.RequisiteTypeRules.state.DEFAULT.cd" parent="field.luStatementInfo.operator.type.RequisiteTypeRules.state.DEFAULT.cd.abstract"/>

<!-- services has both statement ids and requirement component ids as required but this can't be true.  What is required is that either a statement or requirement component is required so there is a cross field constraint but not both -->
<dict:field key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.RequisiteTypeRules.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.luStatementIds.type.RequisiteTypeRules.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.luStatementIds.type.RequisiteTypeRules.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.RequisiteTypeRules.state.DEFAULT" parent="field.luStatementInfo.luStatementIds.type.RequisiteTypeRules.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.RequisiteTypeRules.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Contained LU Statement Identifiers</dict:name>
	<dict:desc>List of LU statement identifiers.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.RequisiteTypeRules.state.DEFAULT.fd" parent="field.luStatementInfo.luStatementIds.type.RequisiteTypeRules.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating; Id of an existing LU Statement -->
<dict:constraintDescriptor id="field.luStatementInfo.luStatementIds.type.RequisiteTypeRules.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
	<dict:constraintRef bean="constraint.related.luStatementd"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.RequisiteTypeRules.state.DEFAULT.cd" parent="field.luStatementInfo.luStatementIds.type.RequisiteTypeRules.state.DEFAULT.cd.abstract"/>

<!-- services has both statement ids and requirement component ids as required but this can't be true.  What is required is that either a statement or requirement component is required so there is a cross field constraint but not both -->
<dict:field key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.RequisiteTypeRules.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.reqComponentIds.type.RequisiteTypeRules.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.reqComponentIds.type.RequisiteTypeRules.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.RequisiteTypeRules.state.DEFAULT" parent="field.luStatementInfo.reqComponentIds.type.RequisiteTypeRules.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.RequisiteTypeRules.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Contained Requirement Component Identifiers</dict:name>
	<dict:desc>List of requirement component identifiers.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.RequisiteTypeRules.state.DEFAULT.fd" parent="field.luStatementInfo.reqComponentIds.type.RequisiteTypeRules.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating; Id of an existing requirement component -->
<dict:constraintDescriptor id="field.luStatementInfo.reqComponentIds.type.RequisiteTypeRules.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
	<dict:constraintRef bean="constraint.related.requirementComponentId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.RequisiteTypeRules.state.DEFAULT.cd" parent="field.luStatementInfo.reqComponentIds.type.RequisiteTypeRules.state.DEFAULT.cd.abstract"/>

<dict:field key="attributes" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="attributes" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="attributes" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Generic/dynamic attributes</dict:name>
	<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="attributes" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="attributes" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.cd.abstract"/>

<!-- ************************************************************************************************************* -->
<!-- object structure for field.luStatementInfo.attributes.type.Requisite Type Rules.state.(default).attributeInfo -->
<!-- ************************************************************************************************************* -->
<!-- List of key/value pairs, typically used for dynamic attributes. -->
<dict:objectStructure key=".AttributeInfo" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key=".AttributeInfo" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.DEFAULT" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.DEFAULT.abstract"/>

<!-- ********************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.Requisite Type Rules.state.(default).attributeInfo.type.(default).state.(default) -->
<!-- ********************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.fd" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.cd" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.fd" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.cd" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.cd.abstract"/>

<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.EyeColor.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Eye Color</dict:name>
	<dict:desc>Captures the eye color of students expected to take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.EyeColor" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.EyeColor.abstract"/>

<!-- ********************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.Requisite Type Rules.state.(default).attributeInfo.type.Eye Color.state.(default) -->
<!-- ********************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd.abstract"/>

<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.LeftHanded.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Left Handed</dict:name>
	<dict:desc>Captures if the students are expected to be left handed who take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.LeftHanded" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.LeftHanded.abstract"/>

<!-- ************************************************************************************************************************************ -->
<!-- fields for field.luStatementInfo.attributes.type.Requisite Type Rules.state.(default).attributeInfo.type.Left Handed.state.(default) -->
<!-- ************************************************************************************************************************************ -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd.abstract"/>

<!-- This sequence really belongs on both on CLU-LO and LO-LO relationships for Single Use Los - but the most recent version of the services with the relationships as not in use yet, so it has been put here as a temporary solution -->
<dict:type key="kuali.lo.type.SingleUse.dynamic.sequence" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.Sequence.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Sequence</dict:name>
	<dict:desc>Captures the sequence of an LO within a Credit Course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lo.type.SingleUse.dynamic.sequence" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.Sequence" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.Sequence.abstract"/>

<!-- ********************************************************************************************************************************* -->
<!-- fields for field.luStatementInfo.attributes.type.Requisite Type Rules.state.(default).attributeInfo.type.Sequence.state.(default) -->
<!-- ********************************************************************************************************************************* -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.RequisiteTypeRules.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd.abstract"/>

<dict:field key="metaInfo" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="metaInfo" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Create/Update meta info</dict:name>
	<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo"/>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.fd" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.cd" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.cd.abstract"/>

<!-- ****************************************************************************************************** -->
<!-- object structure for field.luStatementInfo.metaInfo.type.Requisite Type Rules.state.(default).metaInfo -->
<!-- ****************************************************************************************************** -->
<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.type.DEFAULT" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.type.DEFAULT.abstract"/>

<!-- *************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.metaInfo.type.Requisite Type Rules.state.(default).metaInfo.type.(default).state.(default) -->
<!-- *************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.versionInd"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createTime"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createId"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateTime"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateId"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.abstract"/>


<dict:field key="versionInd" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.versionInd.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.versionInd.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.versionInd.cd"/>
</dict:field>
<dict:field key="versionInd" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.versionInd" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.versionInd.abstract"/>
<dict:fieldDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.versionInd.fd.abstract" abstract="true">
	<dict:name>Version Indicator</dict:name>
	<dict:desc>An indicator of the version of the thing being described with this meta information. This is set by the service implementation and will be used to determine conflicts in updates.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.versionInd.fd" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.versionInd.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Calculates the version indicator that is used for optimistic locking; Read Only -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.versionInd.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
	<dict:constraintRef bean="constraint.read.only"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.versionInd.cd" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.versionInd.cd.abstract"/>

<dict:field key="createTime" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createTime.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createTime.cd"/>
</dict:field>
<dict:field key="createTime" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createTime" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createTime.abstract"/>
<dict:fieldDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Created</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was created</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createTime.fd" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Defaults to NOW, when the object is created -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.default.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createTime.cd" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createTime.cd.abstract"/>

<dict:field key="createId" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createId.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createId.cd"/>
</dict:field>
<dict:field key="createId" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createId" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createId.abstract"/>
<dict:fieldDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createId.fd.abstract" abstract="true">
	<dict:name>Created By Identifier</dict:name>
	<dict:desc>The principal who created the thing being described with this meta information</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createId.fd" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Defaults to the currently authenticated user -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createId.cd" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.createId.cd.abstract"/>

<dict:field key="updateTime" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateTime.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateTime.cd"/>
</dict:field>
<dict:field key="updateTime" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateTime" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateTime.abstract"/>
<dict:fieldDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Last Updated</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was last updated. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateTime.fd" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Sets a field to the current time -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.calc.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateTime.cd" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateTime.cd.abstract"/>

<dict:field key="updateId" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateId.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateId.cd"/>
</dict:field>
<dict:field key="updateId" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateId" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateId.abstract"/>
<dict:fieldDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateId.fd.abstract" abstract="true">
	<dict:name>Updated By Identifier</dict:name>
	<dict:desc>The principal who last updated the thing being described with this meta information. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateId.fd" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Sets a field to the currently authenticated user -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateId.cd" parent="field.luStatementInfo.metaInfo.type.RequisiteTypeRules.state.DEFAULT.metaInfo.updateId.cd.abstract"/>

<dict:field key="type" id="field.luStatementInfo.type.type.RequisiteTypeRules.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.type.type.RequisiteTypeRules.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.type.type.RequisiteTypeRules.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="type" id="field.luStatementInfo.type.type.RequisiteTypeRules.state.DEFAULT" parent="field.luStatementInfo.type.type.RequisiteTypeRules.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="type" id="field.luStatementInfo.type.type.RequisiteTypeRules.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Type Identifier</dict:name>
	<dict:desc>Unique identifier for an LU statement type.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="type" id="field.luStatementInfo.type.type.RequisiteTypeRules.state.DEFAULT.fd" parent="field.luStatementInfo.type.type.RequisiteTypeRules.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of valid lu statement types -->
<dict:constraintDescriptor id="field.luStatementInfo.type.type.RequisiteTypeRules.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.lu.statement.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="type" id="field.luStatementInfo.type.type.RequisiteTypeRules.state.DEFAULT.cd" parent="field.luStatementInfo.type.type.RequisiteTypeRules.state.DEFAULT.cd.abstract"/>

<dict:field key="state" id="field.luStatementInfo.state.type.RequisiteTypeRules.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.state.type.RequisiteTypeRules.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.state.type.RequisiteTypeRules.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="state" id="field.luStatementInfo.state.type.RequisiteTypeRules.state.DEFAULT" parent="field.luStatementInfo.state.type.RequisiteTypeRules.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="state" id="field.luStatementInfo.state.type.RequisiteTypeRules.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement State</dict:name>
	<dict:desc>The current status of the LU statement. The values for this field are constrained to those in the luStatementState enumeration. A separate setup operation does not exist for retrieval of the meta data around this value.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="state" id="field.luStatementInfo.state.type.RequisiteTypeRules.state.DEFAULT.fd" parent="field.luStatementInfo.state.type.RequisiteTypeRules.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali STATE; In list of valid lu statement states -->
<dict:constraintDescriptor id="field.luStatementInfo.state.type.RequisiteTypeRules.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.state"/>
	<dict:constraintRef bean="constraint.lu.statement.states"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="state" id="field.luStatementInfo.state.type.RequisiteTypeRules.state.DEFAULT.cd" parent="field.luStatementInfo.state.type.RequisiteTypeRules.state.DEFAULT.cd.abstract"/>

<dict:field key="id" id="field.luStatementInfo.id.type.RequisiteTypeRules.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.id.type.RequisiteTypeRules.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.id.type.RequisiteTypeRules.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="id" id="field.luStatementInfo.id.type.RequisiteTypeRules.state.DEFAULT" parent="field.luStatementInfo.id.type.RequisiteTypeRules.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="id" id="field.luStatementInfo.id.type.RequisiteTypeRules.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Identifier</dict:name>
	<dict:desc>Unique identifier for a single LU statement record. This is optional, due to the identifier being set at the time of creation. Once the LU statement has been created, this should be seen as required.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="id" id="field.luStatementInfo.id.type.RequisiteTypeRules.state.DEFAULT.fd" parent="field.luStatementInfo.id.type.RequisiteTypeRules.state.DEFAULT.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Kuali ID; calculated by service on add, then read-only. -->
<dict:constraintDescriptor id="field.luStatementInfo.id.type.RequisiteTypeRules.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.id"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="id" id="field.luStatementInfo.id.type.RequisiteTypeRules.state.DEFAULT.cd" parent="field.luStatementInfo.id.type.RequisiteTypeRules.state.DEFAULT.cd.abstract"/>

<dict:type key="kuali.luStatementType.prerequisite,kuali.luStatementType.antirequisite" id="object.luStatementInfo.type.Prereq_Coreq.abstract" abstract="true" parent="object.luStatementInfo.type.DEFAULT.abstract">
	<dict:name>Prereq,Coreq</dict:name>
	<dict:desc>Group that includes prerequisite rules and corequisite rules</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="object.luStatementInfo.type.Prereq_Coreq.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.luStatementType.prerequisite,kuali.luStatementType.antirequisite" id="object.luStatementInfo.type.Prereq_Coreq" parent="object.luStatementInfo.type.Prereq_Coreq.abstract"/>

<!-- ******************************************************************* -->
<!-- fields for object.luStatementInfo.type.Prereq,Coreq.state.(default) -->
<!-- ******************************************************************* -->

<dict:state key="*" id="object.luStatementInfo.type.Prereq_Coreq.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.name.type.Prereq_Coreq.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.operator.type.Prereq_Coreq.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.luStatementIds.type.Prereq_Coreq.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.reqComponentIds.type.Prereq_Coreq.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.type.type.Prereq_Coreq.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.state.type.Prereq_Coreq.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.id.type.Prereq_Coreq.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="object.luStatementInfo.type.Prereq_Coreq.state.DEFAULT" parent="object.luStatementInfo.type.Prereq_Coreq.state.DEFAULT.abstract"/>


<dict:field key="name" id="field.luStatementInfo.name.type.Prereq_Coreq.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.name.type.Prereq_Coreq.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.name.type.Prereq_Coreq.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="name" id="field.luStatementInfo.name.type.Prereq_Coreq.state.DEFAULT" parent="field.luStatementInfo.name.type.Prereq_Coreq.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="name" id="field.luStatementInfo.name.type.Prereq_Coreq.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Name</dict:name>
	<dict:desc>Friendly name for the LU statement.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="name" id="field.luStatementInfo.name.type.Prereq_Coreq.state.DEFAULT.fd" parent="field.luStatementInfo.name.type.Prereq_Coreq.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); A basic single line of text, no embedded carraige returns or tabs limited to 255 -->
<dict:constraintDescriptor id="field.luStatementInfo.name.type.Prereq_Coreq.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.single.line.text"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="name" id="field.luStatementInfo.name.type.Prereq_Coreq.state.DEFAULT.cd" parent="field.luStatementInfo.name.type.Prereq_Coreq.state.DEFAULT.cd.abstract"/>

<dict:field key="desc" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="desc" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT" parent="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="desc" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Description</dict:name>
	<dict:desc>Narrative description for the LU statement.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="desc" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.fd" parent="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.fd.abstract"/>
<!-- Optional; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="desc" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.cd" parent="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.cd.abstract"/>

<!-- ********************************************************************************************** -->
<!-- object structure for field.luStatementInfo.desc.type.Prereq,Coreq.state.(default).richTextInfo -->
<!-- ********************************************************************************************** -->
<!-- Complex type supporting both a plain text and formatted version of a string. -->
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo" parent="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.type.DEFAULT" parent="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.type.DEFAULT.abstract"/>

<!-- ******************************************************************************************************************* -->
<!-- fields for field.luStatementInfo.desc.type.Prereq,Coreq.state.(default).richTextInfo.type.(default).state.(default) -->
<!-- ******************************************************************************************************************* -->

<dict:state key="*" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.plain"/>
	<dict:fieldRef bean="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.formatted"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo" parent="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.abstract"/>


<dict:field key="plain" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.plain.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.plain.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.plain.cd"/>
</dict:field>
<dict:field key="plain" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.plain" parent="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.plain.abstract"/>
<dict:fieldDescriptor key="plain" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.plain.fd.abstract" abstract="true">
	<dict:name>Plain Text</dict:name>
	<dict:desc>Plain version of the text. This may be used for searching.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="plain" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.plain.fd" parent="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.plain.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Multi-line text field that accepts all printable characters plus tab, carraige-return and linefeed. -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.plain.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.multi.line.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="plain" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.plain.cd" parent="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.plain.cd.abstract"/>

<dict:field key="formatted" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.formatted.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.formatted.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.formatted.cd"/>
</dict:field>
<dict:field key="formatted" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.formatted" parent="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.formatted.abstract"/>
<dict:fieldDescriptor key="formatted" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.formatted.fd.abstract" abstract="true">
	<dict:name>Formatted Text</dict:name>
	<dict:desc>Formatted version of the text.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="formatted" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.formatted.fd" parent="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.formatted.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Text field that accepts all types of characters using some sort of escaping convention along with the ability to specify bolding, font size, color etc. -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.formatted.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.rich.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="formatted" id="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.formatted.cd" parent="field.luStatementInfo.desc.type.Prereq_Coreq.state.DEFAULT.richTextInfo.formatted.cd.abstract"/>

<dict:field key="operator" id="field.luStatementInfo.operator.type.Prereq_Coreq.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.operator.type.Prereq_Coreq.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.operator.type.Prereq_Coreq.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="operator" id="field.luStatementInfo.operator.type.Prereq_Coreq.state.DEFAULT" parent="field.luStatementInfo.operator.type.Prereq_Coreq.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="operator" id="field.luStatementInfo.operator.type.Prereq_Coreq.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Operator</dict:name>
	<dict:desc>Logical operator used to assemble statements. Acceptable values are restricted to AND and OR. This operator applies to both the LU statements and requirement components contained within this statement.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="operator" id="field.luStatementInfo.operator.type.Prereq_Coreq.state.DEFAULT.fd" parent="field.luStatementInfo.operator.type.Prereq_Coreq.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Alphanumeric code, hypen and period.; In list of configured lu statement operators (AND and OR) -->
<dict:constraintDescriptor id="field.luStatementInfo.operator.type.Prereq_Coreq.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.code"/>
	<dict:constraintRef bean="constraint.lu.statement.operators"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="operator" id="field.luStatementInfo.operator.type.Prereq_Coreq.state.DEFAULT.cd" parent="field.luStatementInfo.operator.type.Prereq_Coreq.state.DEFAULT.cd.abstract"/>

<!-- services has both statement ids and requirement component ids as required but this can't be true.  What is required is that either a statement or requirement component is required so there is a cross field constraint but not both -->
<dict:field key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.Prereq_Coreq.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.luStatementIds.type.Prereq_Coreq.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.luStatementIds.type.Prereq_Coreq.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.Prereq_Coreq.state.DEFAULT" parent="field.luStatementInfo.luStatementIds.type.Prereq_Coreq.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.Prereq_Coreq.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Contained LU Statement Identifiers</dict:name>
	<dict:desc>List of LU statement identifiers.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.Prereq_Coreq.state.DEFAULT.fd" parent="field.luStatementInfo.luStatementIds.type.Prereq_Coreq.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating; Id of an existing LU Statement -->
<dict:constraintDescriptor id="field.luStatementInfo.luStatementIds.type.Prereq_Coreq.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
	<dict:constraintRef bean="constraint.related.luStatementd"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.Prereq_Coreq.state.DEFAULT.cd" parent="field.luStatementInfo.luStatementIds.type.Prereq_Coreq.state.DEFAULT.cd.abstract"/>

<!-- services has both statement ids and requirement component ids as required but this can't be true.  What is required is that either a statement or requirement component is required so there is a cross field constraint but not both -->
<dict:field key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.Prereq_Coreq.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.reqComponentIds.type.Prereq_Coreq.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.reqComponentIds.type.Prereq_Coreq.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.Prereq_Coreq.state.DEFAULT" parent="field.luStatementInfo.reqComponentIds.type.Prereq_Coreq.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.Prereq_Coreq.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Contained Requirement Component Identifiers</dict:name>
	<dict:desc>List of requirement component identifiers.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.Prereq_Coreq.state.DEFAULT.fd" parent="field.luStatementInfo.reqComponentIds.type.Prereq_Coreq.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating; Id of an existing requirement component -->
<dict:constraintDescriptor id="field.luStatementInfo.reqComponentIds.type.Prereq_Coreq.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
	<dict:constraintRef bean="constraint.related.requirementComponentId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.Prereq_Coreq.state.DEFAULT.cd" parent="field.luStatementInfo.reqComponentIds.type.Prereq_Coreq.state.DEFAULT.cd.abstract"/>

<dict:field key="attributes" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="attributes" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="attributes" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Generic/dynamic attributes</dict:name>
	<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="attributes" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="attributes" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.cd.abstract"/>

<!-- ***************************************************************************************************** -->
<!-- object structure for field.luStatementInfo.attributes.type.Prereq,Coreq.state.(default).attributeInfo -->
<!-- ***************************************************************************************************** -->
<!-- List of key/value pairs, typically used for dynamic attributes. -->
<dict:objectStructure key=".AttributeInfo" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key=".AttributeInfo" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.DEFAULT" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.DEFAULT.abstract"/>

<!-- ************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.Prereq,Coreq.state.(default).attributeInfo.type.(default).state.(default) -->
<!-- ************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.fd" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.cd" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.fd" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.cd" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.cd.abstract"/>

<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.EyeColor.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Eye Color</dict:name>
	<dict:desc>Captures the eye color of students expected to take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.EyeColor" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.EyeColor.abstract"/>

<!-- ************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.Prereq,Coreq.state.(default).attributeInfo.type.Eye Color.state.(default) -->
<!-- ************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd.abstract"/>

<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.LeftHanded.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Left Handed</dict:name>
	<dict:desc>Captures if the students are expected to be left handed who take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.LeftHanded" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.LeftHanded.abstract"/>

<!-- **************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.Prereq,Coreq.state.(default).attributeInfo.type.Left Handed.state.(default) -->
<!-- **************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd.abstract"/>

<!-- This sequence really belongs on both on CLU-LO and LO-LO relationships for Single Use Los - but the most recent version of the services with the relationships as not in use yet, so it has been put here as a temporary solution -->
<dict:type key="kuali.lo.type.SingleUse.dynamic.sequence" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.Sequence.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Sequence</dict:name>
	<dict:desc>Captures the sequence of an LO within a Credit Course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lo.type.SingleUse.dynamic.sequence" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.Sequence" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.Sequence.abstract"/>

<!-- ************************************************************************************************************************* -->
<!-- fields for field.luStatementInfo.attributes.type.Prereq,Coreq.state.(default).attributeInfo.type.Sequence.state.(default) -->
<!-- ************************************************************************************************************************* -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.Prereq_Coreq.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd.abstract"/>

<dict:field key="metaInfo" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="metaInfo" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Create/Update meta info</dict:name>
	<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo"/>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.fd" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.cd" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.cd.abstract"/>

<!-- ********************************************************************************************** -->
<!-- object structure for field.luStatementInfo.metaInfo.type.Prereq,Coreq.state.(default).metaInfo -->
<!-- ********************************************************************************************** -->
<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.type.DEFAULT" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.type.DEFAULT.abstract"/>

<!-- ******************************************************************************************************************* -->
<!-- fields for field.luStatementInfo.metaInfo.type.Prereq,Coreq.state.(default).metaInfo.type.(default).state.(default) -->
<!-- ******************************************************************************************************************* -->

<dict:state key="*" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.versionInd"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createTime"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createId"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateTime"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateId"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.abstract"/>


<dict:field key="versionInd" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.versionInd.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.versionInd.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.versionInd.cd"/>
</dict:field>
<dict:field key="versionInd" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.versionInd" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.versionInd.abstract"/>
<dict:fieldDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.versionInd.fd.abstract" abstract="true">
	<dict:name>Version Indicator</dict:name>
	<dict:desc>An indicator of the version of the thing being described with this meta information. This is set by the service implementation and will be used to determine conflicts in updates.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.versionInd.fd" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.versionInd.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Calculates the version indicator that is used for optimistic locking; Read Only -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.versionInd.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
	<dict:constraintRef bean="constraint.read.only"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.versionInd.cd" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.versionInd.cd.abstract"/>

<dict:field key="createTime" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createTime.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createTime.cd"/>
</dict:field>
<dict:field key="createTime" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createTime" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createTime.abstract"/>
<dict:fieldDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Created</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was created</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createTime.fd" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Defaults to NOW, when the object is created -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.default.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createTime.cd" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createTime.cd.abstract"/>

<dict:field key="createId" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createId.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createId.cd"/>
</dict:field>
<dict:field key="createId" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createId" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createId.abstract"/>
<dict:fieldDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createId.fd.abstract" abstract="true">
	<dict:name>Created By Identifier</dict:name>
	<dict:desc>The principal who created the thing being described with this meta information</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createId.fd" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Defaults to the currently authenticated user -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createId.cd" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.createId.cd.abstract"/>

<dict:field key="updateTime" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateTime.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateTime.cd"/>
</dict:field>
<dict:field key="updateTime" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateTime" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateTime.abstract"/>
<dict:fieldDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Last Updated</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was last updated. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateTime.fd" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Sets a field to the current time -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.calc.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateTime.cd" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateTime.cd.abstract"/>

<dict:field key="updateId" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateId.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateId.cd"/>
</dict:field>
<dict:field key="updateId" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateId" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateId.abstract"/>
<dict:fieldDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateId.fd.abstract" abstract="true">
	<dict:name>Updated By Identifier</dict:name>
	<dict:desc>The principal who last updated the thing being described with this meta information. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateId.fd" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Sets a field to the currently authenticated user -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateId.cd" parent="field.luStatementInfo.metaInfo.type.Prereq_Coreq.state.DEFAULT.metaInfo.updateId.cd.abstract"/>

<dict:field key="type" id="field.luStatementInfo.type.type.Prereq_Coreq.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.type.type.Prereq_Coreq.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.type.type.Prereq_Coreq.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="type" id="field.luStatementInfo.type.type.Prereq_Coreq.state.DEFAULT" parent="field.luStatementInfo.type.type.Prereq_Coreq.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="type" id="field.luStatementInfo.type.type.Prereq_Coreq.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Type Identifier</dict:name>
	<dict:desc>Unique identifier for an LU statement type.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="type" id="field.luStatementInfo.type.type.Prereq_Coreq.state.DEFAULT.fd" parent="field.luStatementInfo.type.type.Prereq_Coreq.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of valid lu statement types -->
<dict:constraintDescriptor id="field.luStatementInfo.type.type.Prereq_Coreq.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.lu.statement.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="type" id="field.luStatementInfo.type.type.Prereq_Coreq.state.DEFAULT.cd" parent="field.luStatementInfo.type.type.Prereq_Coreq.state.DEFAULT.cd.abstract"/>

<dict:field key="state" id="field.luStatementInfo.state.type.Prereq_Coreq.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.state.type.Prereq_Coreq.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.state.type.Prereq_Coreq.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="state" id="field.luStatementInfo.state.type.Prereq_Coreq.state.DEFAULT" parent="field.luStatementInfo.state.type.Prereq_Coreq.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="state" id="field.luStatementInfo.state.type.Prereq_Coreq.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement State</dict:name>
	<dict:desc>The current status of the LU statement. The values for this field are constrained to those in the luStatementState enumeration. A separate setup operation does not exist for retrieval of the meta data around this value.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="state" id="field.luStatementInfo.state.type.Prereq_Coreq.state.DEFAULT.fd" parent="field.luStatementInfo.state.type.Prereq_Coreq.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali STATE; In list of valid lu statement states -->
<dict:constraintDescriptor id="field.luStatementInfo.state.type.Prereq_Coreq.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.state"/>
	<dict:constraintRef bean="constraint.lu.statement.states"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="state" id="field.luStatementInfo.state.type.Prereq_Coreq.state.DEFAULT.cd" parent="field.luStatementInfo.state.type.Prereq_Coreq.state.DEFAULT.cd.abstract"/>

<dict:field key="id" id="field.luStatementInfo.id.type.Prereq_Coreq.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.id.type.Prereq_Coreq.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.id.type.Prereq_Coreq.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="id" id="field.luStatementInfo.id.type.Prereq_Coreq.state.DEFAULT" parent="field.luStatementInfo.id.type.Prereq_Coreq.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="id" id="field.luStatementInfo.id.type.Prereq_Coreq.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Identifier</dict:name>
	<dict:desc>Unique identifier for a single LU statement record. This is optional, due to the identifier being set at the time of creation. Once the LU statement has been created, this should be seen as required.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="id" id="field.luStatementInfo.id.type.Prereq_Coreq.state.DEFAULT.fd" parent="field.luStatementInfo.id.type.Prereq_Coreq.state.DEFAULT.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Kuali ID; calculated by service on add, then read-only. -->
<dict:constraintDescriptor id="field.luStatementInfo.id.type.Prereq_Coreq.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.id"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="id" id="field.luStatementInfo.id.type.Prereq_Coreq.state.DEFAULT.cd" parent="field.luStatementInfo.id.type.Prereq_Coreq.state.DEFAULT.cd.abstract"/>

<!-- How to indicate the advisory nature of the prerequisite, whether the rule is hard or soft has not been clarified. I.e. whether this rule will be enforced or not. This may be indicated as a new type "Advisories" or as a flag on the statement or requirement component's themselves. -->
<dict:type key="kuali.luStatementType.req.prerequisite" id="object.luStatementInfo.type.PrerequisiteRule.abstract" abstract="true" parent="object.luStatementInfo.type.DEFAULT.abstract">
	<dict:name>Prerequisite Rule</dict:name>
	<dict:desc>Rules that describe the academic readiness or preparedness required to be able to enroll in a course and effectively master the material. Also called

Should not include rules that restrict enrollment for other purposes other than academic preparedness, these should be captured as enrollment restrictions</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="object.luStatementInfo.type.PrerequisiteRule.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.luStatementType.req.prerequisite" id="object.luStatementInfo.type.PrerequisiteRule" parent="object.luStatementInfo.type.PrerequisiteRule.abstract"/>

<!-- ************************************************************************ -->
<!-- fields for object.luStatementInfo.type.Prerequisite Rule.state.(default) -->
<!-- ************************************************************************ -->

<dict:state key="*" id="object.luStatementInfo.type.PrerequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.name.type.PrerequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.operator.type.PrerequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.luStatementIds.type.PrerequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.reqComponentIds.type.PrerequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.type.type.PrerequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.state.type.PrerequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.id.type.PrerequisiteRule.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="object.luStatementInfo.type.PrerequisiteRule.state.DEFAULT" parent="object.luStatementInfo.type.PrerequisiteRule.state.DEFAULT.abstract"/>


<dict:field key="name" id="field.luStatementInfo.name.type.PrerequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.name.type.PrerequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.name.type.PrerequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="name" id="field.luStatementInfo.name.type.PrerequisiteRule.state.DEFAULT" parent="field.luStatementInfo.name.type.PrerequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="name" id="field.luStatementInfo.name.type.PrerequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Name</dict:name>
	<dict:desc>Friendly name for the LU statement.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="name" id="field.luStatementInfo.name.type.PrerequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.name.type.PrerequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); A basic single line of text, no embedded carraige returns or tabs limited to 255 -->
<dict:constraintDescriptor id="field.luStatementInfo.name.type.PrerequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.single.line.text"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="name" id="field.luStatementInfo.name.type.PrerequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.name.type.PrerequisiteRule.state.DEFAULT.cd.abstract"/>

<dict:field key="desc" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="desc" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT" parent="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="desc" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Description</dict:name>
	<dict:desc>Narrative description for the LU statement.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="desc" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Optional; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="desc" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.cd.abstract"/>

<!-- *************************************************************************************************** -->
<!-- object structure for field.luStatementInfo.desc.type.Prerequisite Rule.state.(default).richTextInfo -->
<!-- *************************************************************************************************** -->
<!-- Complex type supporting both a plain text and formatted version of a string. -->
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo" parent="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.type.DEFAULT" parent="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.type.DEFAULT.abstract"/>

<!-- ************************************************************************************************************************ -->
<!-- fields for field.luStatementInfo.desc.type.Prerequisite Rule.state.(default).richTextInfo.type.(default).state.(default) -->
<!-- ************************************************************************************************************************ -->

<dict:state key="*" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.plain"/>
	<dict:fieldRef bean="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.formatted"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo" parent="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.abstract"/>


<dict:field key="plain" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.plain.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.plain.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.plain.cd"/>
</dict:field>
<dict:field key="plain" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.plain" parent="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.plain.abstract"/>
<dict:fieldDescriptor key="plain" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.plain.fd.abstract" abstract="true">
	<dict:name>Plain Text</dict:name>
	<dict:desc>Plain version of the text. This may be used for searching.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="plain" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.plain.fd" parent="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.plain.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Multi-line text field that accepts all printable characters plus tab, carraige-return and linefeed. -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.plain.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.multi.line.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="plain" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.plain.cd" parent="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.plain.cd.abstract"/>

<dict:field key="formatted" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.formatted.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.formatted.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.formatted.cd"/>
</dict:field>
<dict:field key="formatted" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.formatted" parent="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.formatted.abstract"/>
<dict:fieldDescriptor key="formatted" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.formatted.fd.abstract" abstract="true">
	<dict:name>Formatted Text</dict:name>
	<dict:desc>Formatted version of the text.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="formatted" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.formatted.fd" parent="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.formatted.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Text field that accepts all types of characters using some sort of escaping convention along with the ability to specify bolding, font size, color etc. -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.formatted.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.rich.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="formatted" id="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.formatted.cd" parent="field.luStatementInfo.desc.type.PrerequisiteRule.state.DEFAULT.richTextInfo.formatted.cd.abstract"/>

<dict:field key="operator" id="field.luStatementInfo.operator.type.PrerequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.operator.type.PrerequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.operator.type.PrerequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="operator" id="field.luStatementInfo.operator.type.PrerequisiteRule.state.DEFAULT" parent="field.luStatementInfo.operator.type.PrerequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="operator" id="field.luStatementInfo.operator.type.PrerequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Operator</dict:name>
	<dict:desc>Logical operator used to assemble statements. Acceptable values are restricted to AND and OR. This operator applies to both the LU statements and requirement components contained within this statement.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="operator" id="field.luStatementInfo.operator.type.PrerequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.operator.type.PrerequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Alphanumeric code, hypen and period.; In list of configured lu statement operators (AND and OR) -->
<dict:constraintDescriptor id="field.luStatementInfo.operator.type.PrerequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.code"/>
	<dict:constraintRef bean="constraint.lu.statement.operators"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="operator" id="field.luStatementInfo.operator.type.PrerequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.operator.type.PrerequisiteRule.state.DEFAULT.cd.abstract"/>

<!-- services has both statement ids and requirement component ids as required but this can't be true.  What is required is that either a statement or requirement component is required so there is a cross field constraint but not both -->
<dict:field key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.PrerequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.luStatementIds.type.PrerequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.luStatementIds.type.PrerequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.PrerequisiteRule.state.DEFAULT" parent="field.luStatementInfo.luStatementIds.type.PrerequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.PrerequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Contained LU Statement Identifiers</dict:name>
	<dict:desc>List of LU statement identifiers.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.PrerequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.luStatementIds.type.PrerequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating; Id of an existing LU Statement -->
<dict:constraintDescriptor id="field.luStatementInfo.luStatementIds.type.PrerequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
	<dict:constraintRef bean="constraint.related.luStatementd"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.PrerequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.luStatementIds.type.PrerequisiteRule.state.DEFAULT.cd.abstract"/>

<!-- services has both statement ids and requirement component ids as required but this can't be true.  What is required is that either a statement or requirement component is required so there is a cross field constraint but not both -->
<dict:field key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.PrerequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.reqComponentIds.type.PrerequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.reqComponentIds.type.PrerequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.PrerequisiteRule.state.DEFAULT" parent="field.luStatementInfo.reqComponentIds.type.PrerequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.PrerequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Contained Requirement Component Identifiers</dict:name>
	<dict:desc>List of requirement component identifiers.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.PrerequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.reqComponentIds.type.PrerequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating; Id of an existing requirement component -->
<dict:constraintDescriptor id="field.luStatementInfo.reqComponentIds.type.PrerequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
	<dict:constraintRef bean="constraint.related.requirementComponentId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.PrerequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.reqComponentIds.type.PrerequisiteRule.state.DEFAULT.cd.abstract"/>

<dict:field key="attributes" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="attributes" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="attributes" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Generic/dynamic attributes</dict:name>
	<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="attributes" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="attributes" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.cd.abstract"/>

<!-- ********************************************************************************************************** -->
<!-- object structure for field.luStatementInfo.attributes.type.Prerequisite Rule.state.(default).attributeInfo -->
<!-- ********************************************************************************************************** -->
<!-- List of key/value pairs, typically used for dynamic attributes. -->
<dict:objectStructure key=".AttributeInfo" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key=".AttributeInfo" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT.abstract"/>

<!-- ******************************************************************************************************************************* -->
<!-- fields for field.luStatementInfo.attributes.type.Prerequisite Rule.state.(default).attributeInfo.type.(default).state.(default) -->
<!-- ******************************************************************************************************************************* -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.fd" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.cd" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.fd" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.cd" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.cd.abstract"/>

<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Eye Color</dict:name>
	<dict:desc>Captures the eye color of students expected to take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor.abstract"/>

<!-- ******************************************************************************************************************************* -->
<!-- fields for field.luStatementInfo.attributes.type.Prerequisite Rule.state.(default).attributeInfo.type.Eye Color.state.(default) -->
<!-- ******************************************************************************************************************************* -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd.abstract"/>

<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Left Handed</dict:name>
	<dict:desc>Captures if the students are expected to be left handed who take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded.abstract"/>

<!-- ********************************************************************************************************************************* -->
<!-- fields for field.luStatementInfo.attributes.type.Prerequisite Rule.state.(default).attributeInfo.type.Left Handed.state.(default) -->
<!-- ********************************************************************************************************************************* -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd.abstract"/>

<!-- This sequence really belongs on both on CLU-LO and LO-LO relationships for Single Use Los - but the most recent version of the services with the relationships as not in use yet, so it has been put here as a temporary solution -->
<dict:type key="kuali.lo.type.SingleUse.dynamic.sequence" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.Sequence.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Sequence</dict:name>
	<dict:desc>Captures the sequence of an LO within a Credit Course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lo.type.SingleUse.dynamic.sequence" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.Sequence" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.Sequence.abstract"/>

<!-- ****************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.Prerequisite Rule.state.(default).attributeInfo.type.Sequence.state.(default) -->
<!-- ****************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.PrerequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd.abstract"/>

<dict:field key="metaInfo" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="metaInfo" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Create/Update meta info</dict:name>
	<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo"/>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.cd.abstract"/>

<!-- *************************************************************************************************** -->
<!-- object structure for field.luStatementInfo.metaInfo.type.Prerequisite Rule.state.(default).metaInfo -->
<!-- *************************************************************************************************** -->
<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.type.DEFAULT" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.type.DEFAULT.abstract"/>

<!-- ************************************************************************************************************************ -->
<!-- fields for field.luStatementInfo.metaInfo.type.Prerequisite Rule.state.(default).metaInfo.type.(default).state.(default) -->
<!-- ************************************************************************************************************************ -->

<dict:state key="*" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.versionInd"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createTime"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createId"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateTime"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateId"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.abstract"/>


<dict:field key="versionInd" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.versionInd.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.versionInd.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.versionInd.cd"/>
</dict:field>
<dict:field key="versionInd" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.versionInd" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.versionInd.abstract"/>
<dict:fieldDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.versionInd.fd.abstract" abstract="true">
	<dict:name>Version Indicator</dict:name>
	<dict:desc>An indicator of the version of the thing being described with this meta information. This is set by the service implementation and will be used to determine conflicts in updates.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.versionInd.fd" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.versionInd.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Calculates the version indicator that is used for optimistic locking; Read Only -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.versionInd.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
	<dict:constraintRef bean="constraint.read.only"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.versionInd.cd" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.versionInd.cd.abstract"/>

<dict:field key="createTime" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createTime.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createTime.cd"/>
</dict:field>
<dict:field key="createTime" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createTime" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createTime.abstract"/>
<dict:fieldDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Created</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was created</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createTime.fd" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Defaults to NOW, when the object is created -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.default.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createTime.cd" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createTime.cd.abstract"/>

<dict:field key="createId" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createId.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createId.cd"/>
</dict:field>
<dict:field key="createId" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createId" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createId.abstract"/>
<dict:fieldDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createId.fd.abstract" abstract="true">
	<dict:name>Created By Identifier</dict:name>
	<dict:desc>The principal who created the thing being described with this meta information</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createId.fd" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Defaults to the currently authenticated user -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createId.cd" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.createId.cd.abstract"/>

<dict:field key="updateTime" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateTime.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateTime.cd"/>
</dict:field>
<dict:field key="updateTime" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateTime" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateTime.abstract"/>
<dict:fieldDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Last Updated</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was last updated. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateTime.fd" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Sets a field to the current time -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.calc.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateTime.cd" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateTime.cd.abstract"/>

<dict:field key="updateId" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateId.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateId.cd"/>
</dict:field>
<dict:field key="updateId" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateId" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateId.abstract"/>
<dict:fieldDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateId.fd.abstract" abstract="true">
	<dict:name>Updated By Identifier</dict:name>
	<dict:desc>The principal who last updated the thing being described with this meta information. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateId.fd" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Sets a field to the currently authenticated user -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateId.cd" parent="field.luStatementInfo.metaInfo.type.PrerequisiteRule.state.DEFAULT.metaInfo.updateId.cd.abstract"/>

<dict:field key="type" id="field.luStatementInfo.type.type.PrerequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.type.type.PrerequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.type.type.PrerequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="type" id="field.luStatementInfo.type.type.PrerequisiteRule.state.DEFAULT" parent="field.luStatementInfo.type.type.PrerequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="type" id="field.luStatementInfo.type.type.PrerequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Type Identifier</dict:name>
	<dict:desc>Unique identifier for an LU statement type.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="type" id="field.luStatementInfo.type.type.PrerequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.type.type.PrerequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of valid lu statement types -->
<dict:constraintDescriptor id="field.luStatementInfo.type.type.PrerequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.lu.statement.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="type" id="field.luStatementInfo.type.type.PrerequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.type.type.PrerequisiteRule.state.DEFAULT.cd.abstract"/>

<dict:field key="state" id="field.luStatementInfo.state.type.PrerequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.state.type.PrerequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.state.type.PrerequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="state" id="field.luStatementInfo.state.type.PrerequisiteRule.state.DEFAULT" parent="field.luStatementInfo.state.type.PrerequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="state" id="field.luStatementInfo.state.type.PrerequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement State</dict:name>
	<dict:desc>The current status of the LU statement. The values for this field are constrained to those in the luStatementState enumeration. A separate setup operation does not exist for retrieval of the meta data around this value.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="state" id="field.luStatementInfo.state.type.PrerequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.state.type.PrerequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali STATE; In list of valid lu statement states -->
<dict:constraintDescriptor id="field.luStatementInfo.state.type.PrerequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.state"/>
	<dict:constraintRef bean="constraint.lu.statement.states"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="state" id="field.luStatementInfo.state.type.PrerequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.state.type.PrerequisiteRule.state.DEFAULT.cd.abstract"/>

<dict:field key="id" id="field.luStatementInfo.id.type.PrerequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.id.type.PrerequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.id.type.PrerequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="id" id="field.luStatementInfo.id.type.PrerequisiteRule.state.DEFAULT" parent="field.luStatementInfo.id.type.PrerequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="id" id="field.luStatementInfo.id.type.PrerequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Identifier</dict:name>
	<dict:desc>Unique identifier for a single LU statement record. This is optional, due to the identifier being set at the time of creation. Once the LU statement has been created, this should be seen as required.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="id" id="field.luStatementInfo.id.type.PrerequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.id.type.PrerequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Kuali ID; calculated by service on add, then read-only. -->
<dict:constraintDescriptor id="field.luStatementInfo.id.type.PrerequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.id"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="id" id="field.luStatementInfo.id.type.PrerequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.id.type.PrerequisiteRule.state.DEFAULT.cd.abstract"/>

<dict:type key="kuali.luStatementType.req.corequisite" id="object.luStatementInfo.type.CorequisiteRule.abstract" abstract="true" parent="object.luStatementInfo.type.DEFAULT.abstract">
	<dict:name>Corequisite Rule</dict:name>
	<dict:desc>Rules that describe the need for concurrent enrollment in two courses.</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="object.luStatementInfo.type.CorequisiteRule.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.luStatementType.req.corequisite" id="object.luStatementInfo.type.CorequisiteRule" parent="object.luStatementInfo.type.CorequisiteRule.abstract"/>

<!-- *********************************************************************** -->
<!-- fields for object.luStatementInfo.type.Corequisite Rule.state.(default) -->
<!-- *********************************************************************** -->

<dict:state key="*" id="object.luStatementInfo.type.CorequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.name.type.CorequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.operator.type.CorequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.luStatementIds.type.CorequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.reqComponentIds.type.CorequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.type.type.CorequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.state.type.CorequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.id.type.CorequisiteRule.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="object.luStatementInfo.type.CorequisiteRule.state.DEFAULT" parent="object.luStatementInfo.type.CorequisiteRule.state.DEFAULT.abstract"/>


<dict:field key="name" id="field.luStatementInfo.name.type.CorequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.name.type.CorequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.name.type.CorequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="name" id="field.luStatementInfo.name.type.CorequisiteRule.state.DEFAULT" parent="field.luStatementInfo.name.type.CorequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="name" id="field.luStatementInfo.name.type.CorequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Name</dict:name>
	<dict:desc>Friendly name for the LU statement.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="name" id="field.luStatementInfo.name.type.CorequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.name.type.CorequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); A basic single line of text, no embedded carraige returns or tabs limited to 255 -->
<dict:constraintDescriptor id="field.luStatementInfo.name.type.CorequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.single.line.text"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="name" id="field.luStatementInfo.name.type.CorequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.name.type.CorequisiteRule.state.DEFAULT.cd.abstract"/>

<dict:field key="desc" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="desc" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT" parent="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="desc" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Description</dict:name>
	<dict:desc>Narrative description for the LU statement.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="desc" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Optional; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="desc" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.cd.abstract"/>

<!-- ************************************************************************************************** -->
<!-- object structure for field.luStatementInfo.desc.type.Corequisite Rule.state.(default).richTextInfo -->
<!-- ************************************************************************************************** -->
<!-- Complex type supporting both a plain text and formatted version of a string. -->
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo" parent="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.type.DEFAULT" parent="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.type.DEFAULT.abstract"/>

<!-- *********************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.desc.type.Corequisite Rule.state.(default).richTextInfo.type.(default).state.(default) -->
<!-- *********************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.plain"/>
	<dict:fieldRef bean="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.formatted"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo" parent="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.abstract"/>


<dict:field key="plain" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.plain.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.plain.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.plain.cd"/>
</dict:field>
<dict:field key="plain" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.plain" parent="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.plain.abstract"/>
<dict:fieldDescriptor key="plain" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.plain.fd.abstract" abstract="true">
	<dict:name>Plain Text</dict:name>
	<dict:desc>Plain version of the text. This may be used for searching.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="plain" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.plain.fd" parent="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.plain.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Multi-line text field that accepts all printable characters plus tab, carraige-return and linefeed. -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.plain.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.multi.line.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="plain" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.plain.cd" parent="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.plain.cd.abstract"/>

<dict:field key="formatted" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.formatted.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.formatted.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.formatted.cd"/>
</dict:field>
<dict:field key="formatted" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.formatted" parent="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.formatted.abstract"/>
<dict:fieldDescriptor key="formatted" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.formatted.fd.abstract" abstract="true">
	<dict:name>Formatted Text</dict:name>
	<dict:desc>Formatted version of the text.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="formatted" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.formatted.fd" parent="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.formatted.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Text field that accepts all types of characters using some sort of escaping convention along with the ability to specify bolding, font size, color etc. -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.formatted.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.rich.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="formatted" id="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.formatted.cd" parent="field.luStatementInfo.desc.type.CorequisiteRule.state.DEFAULT.richTextInfo.formatted.cd.abstract"/>

<dict:field key="operator" id="field.luStatementInfo.operator.type.CorequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.operator.type.CorequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.operator.type.CorequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="operator" id="field.luStatementInfo.operator.type.CorequisiteRule.state.DEFAULT" parent="field.luStatementInfo.operator.type.CorequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="operator" id="field.luStatementInfo.operator.type.CorequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Operator</dict:name>
	<dict:desc>Logical operator used to assemble statements. Acceptable values are restricted to AND and OR. This operator applies to both the LU statements and requirement components contained within this statement.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="operator" id="field.luStatementInfo.operator.type.CorequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.operator.type.CorequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Alphanumeric code, hypen and period.; In list of configured lu statement operators (AND and OR) -->
<dict:constraintDescriptor id="field.luStatementInfo.operator.type.CorequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.code"/>
	<dict:constraintRef bean="constraint.lu.statement.operators"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="operator" id="field.luStatementInfo.operator.type.CorequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.operator.type.CorequisiteRule.state.DEFAULT.cd.abstract"/>

<!-- services has both statement ids and requirement component ids as required but this can't be true.  What is required is that either a statement or requirement component is required so there is a cross field constraint but not both -->
<dict:field key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.CorequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.luStatementIds.type.CorequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.luStatementIds.type.CorequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.CorequisiteRule.state.DEFAULT" parent="field.luStatementInfo.luStatementIds.type.CorequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.CorequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Contained LU Statement Identifiers</dict:name>
	<dict:desc>List of LU statement identifiers.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.CorequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.luStatementIds.type.CorequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating; Id of an existing LU Statement -->
<dict:constraintDescriptor id="field.luStatementInfo.luStatementIds.type.CorequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
	<dict:constraintRef bean="constraint.related.luStatementd"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.CorequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.luStatementIds.type.CorequisiteRule.state.DEFAULT.cd.abstract"/>

<!-- services has both statement ids and requirement component ids as required but this can't be true.  What is required is that either a statement or requirement component is required so there is a cross field constraint but not both -->
<dict:field key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.CorequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.reqComponentIds.type.CorequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.reqComponentIds.type.CorequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.CorequisiteRule.state.DEFAULT" parent="field.luStatementInfo.reqComponentIds.type.CorequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.CorequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Contained Requirement Component Identifiers</dict:name>
	<dict:desc>List of requirement component identifiers.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.CorequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.reqComponentIds.type.CorequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating; Id of an existing requirement component -->
<dict:constraintDescriptor id="field.luStatementInfo.reqComponentIds.type.CorequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
	<dict:constraintRef bean="constraint.related.requirementComponentId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.CorequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.reqComponentIds.type.CorequisiteRule.state.DEFAULT.cd.abstract"/>

<dict:field key="attributes" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="attributes" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="attributes" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Generic/dynamic attributes</dict:name>
	<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="attributes" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="attributes" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.cd.abstract"/>

<!-- ********************************************************************************************************* -->
<!-- object structure for field.luStatementInfo.attributes.type.Corequisite Rule.state.(default).attributeInfo -->
<!-- ********************************************************************************************************* -->
<!-- List of key/value pairs, typically used for dynamic attributes. -->
<dict:objectStructure key=".AttributeInfo" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key=".AttributeInfo" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT.abstract"/>

<!-- ****************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.Corequisite Rule.state.(default).attributeInfo.type.(default).state.(default) -->
<!-- ****************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.fd" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.cd" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.fd" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.cd" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.cd.abstract"/>

<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Eye Color</dict:name>
	<dict:desc>Captures the eye color of students expected to take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor.abstract"/>

<!-- ****************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.Corequisite Rule.state.(default).attributeInfo.type.Eye Color.state.(default) -->
<!-- ****************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd.abstract"/>

<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Left Handed</dict:name>
	<dict:desc>Captures if the students are expected to be left handed who take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded.abstract"/>

<!-- ******************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.Corequisite Rule.state.(default).attributeInfo.type.Left Handed.state.(default) -->
<!-- ******************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd.abstract"/>

<!-- This sequence really belongs on both on CLU-LO and LO-LO relationships for Single Use Los - but the most recent version of the services with the relationships as not in use yet, so it has been put here as a temporary solution -->
<dict:type key="kuali.lo.type.SingleUse.dynamic.sequence" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.Sequence.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Sequence</dict:name>
	<dict:desc>Captures the sequence of an LO within a Credit Course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lo.type.SingleUse.dynamic.sequence" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.Sequence" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.Sequence.abstract"/>

<!-- ***************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.Corequisite Rule.state.(default).attributeInfo.type.Sequence.state.(default) -->
<!-- ***************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.CorequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd.abstract"/>

<dict:field key="metaInfo" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="metaInfo" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Create/Update meta info</dict:name>
	<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo"/>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.cd.abstract"/>

<!-- ************************************************************************************************** -->
<!-- object structure for field.luStatementInfo.metaInfo.type.Corequisite Rule.state.(default).metaInfo -->
<!-- ************************************************************************************************** -->
<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.type.DEFAULT" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.type.DEFAULT.abstract"/>

<!-- *********************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.metaInfo.type.Corequisite Rule.state.(default).metaInfo.type.(default).state.(default) -->
<!-- *********************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.versionInd"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createTime"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createId"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateTime"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateId"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.abstract"/>


<dict:field key="versionInd" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.versionInd.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.versionInd.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.versionInd.cd"/>
</dict:field>
<dict:field key="versionInd" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.versionInd" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.versionInd.abstract"/>
<dict:fieldDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.versionInd.fd.abstract" abstract="true">
	<dict:name>Version Indicator</dict:name>
	<dict:desc>An indicator of the version of the thing being described with this meta information. This is set by the service implementation and will be used to determine conflicts in updates.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.versionInd.fd" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.versionInd.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Calculates the version indicator that is used for optimistic locking; Read Only -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.versionInd.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
	<dict:constraintRef bean="constraint.read.only"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.versionInd.cd" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.versionInd.cd.abstract"/>

<dict:field key="createTime" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createTime.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createTime.cd"/>
</dict:field>
<dict:field key="createTime" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createTime" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createTime.abstract"/>
<dict:fieldDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Created</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was created</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createTime.fd" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Defaults to NOW, when the object is created -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.default.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createTime.cd" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createTime.cd.abstract"/>

<dict:field key="createId" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createId.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createId.cd"/>
</dict:field>
<dict:field key="createId" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createId" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createId.abstract"/>
<dict:fieldDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createId.fd.abstract" abstract="true">
	<dict:name>Created By Identifier</dict:name>
	<dict:desc>The principal who created the thing being described with this meta information</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createId.fd" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Defaults to the currently authenticated user -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createId.cd" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.createId.cd.abstract"/>

<dict:field key="updateTime" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateTime.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateTime.cd"/>
</dict:field>
<dict:field key="updateTime" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateTime" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateTime.abstract"/>
<dict:fieldDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Last Updated</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was last updated. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateTime.fd" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Sets a field to the current time -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.calc.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateTime.cd" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateTime.cd.abstract"/>

<dict:field key="updateId" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateId.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateId.cd"/>
</dict:field>
<dict:field key="updateId" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateId" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateId.abstract"/>
<dict:fieldDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateId.fd.abstract" abstract="true">
	<dict:name>Updated By Identifier</dict:name>
	<dict:desc>The principal who last updated the thing being described with this meta information. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateId.fd" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Sets a field to the currently authenticated user -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateId.cd" parent="field.luStatementInfo.metaInfo.type.CorequisiteRule.state.DEFAULT.metaInfo.updateId.cd.abstract"/>

<dict:field key="type" id="field.luStatementInfo.type.type.CorequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.type.type.CorequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.type.type.CorequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="type" id="field.luStatementInfo.type.type.CorequisiteRule.state.DEFAULT" parent="field.luStatementInfo.type.type.CorequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="type" id="field.luStatementInfo.type.type.CorequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Type Identifier</dict:name>
	<dict:desc>Unique identifier for an LU statement type.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="type" id="field.luStatementInfo.type.type.CorequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.type.type.CorequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of valid lu statement types -->
<dict:constraintDescriptor id="field.luStatementInfo.type.type.CorequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.lu.statement.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="type" id="field.luStatementInfo.type.type.CorequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.type.type.CorequisiteRule.state.DEFAULT.cd.abstract"/>

<dict:field key="state" id="field.luStatementInfo.state.type.CorequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.state.type.CorequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.state.type.CorequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="state" id="field.luStatementInfo.state.type.CorequisiteRule.state.DEFAULT" parent="field.luStatementInfo.state.type.CorequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="state" id="field.luStatementInfo.state.type.CorequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement State</dict:name>
	<dict:desc>The current status of the LU statement. The values for this field are constrained to those in the luStatementState enumeration. A separate setup operation does not exist for retrieval of the meta data around this value.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="state" id="field.luStatementInfo.state.type.CorequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.state.type.CorequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali STATE; In list of valid lu statement states -->
<dict:constraintDescriptor id="field.luStatementInfo.state.type.CorequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.state"/>
	<dict:constraintRef bean="constraint.lu.statement.states"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="state" id="field.luStatementInfo.state.type.CorequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.state.type.CorequisiteRule.state.DEFAULT.cd.abstract"/>

<dict:field key="id" id="field.luStatementInfo.id.type.CorequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.id.type.CorequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.id.type.CorequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="id" id="field.luStatementInfo.id.type.CorequisiteRule.state.DEFAULT" parent="field.luStatementInfo.id.type.CorequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="id" id="field.luStatementInfo.id.type.CorequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Identifier</dict:name>
	<dict:desc>Unique identifier for a single LU statement record. This is optional, due to the identifier being set at the time of creation. Once the LU statement has been created, this should be seen as required.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="id" id="field.luStatementInfo.id.type.CorequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.id.type.CorequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Kuali ID; calculated by service on add, then read-only. -->
<dict:constraintDescriptor id="field.luStatementInfo.id.type.CorequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.id"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="id" id="field.luStatementInfo.id.type.CorequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.id.type.CorequisiteRule.state.DEFAULT.cd.abstract"/>

<dict:type key="kuali.luStatementType.req.enrollmentRestriction" id="object.luStatementInfo.type.EnrollmentRestriction.abstract" abstract="true" parent="object.luStatementInfo.type.DEFAULT.abstract">
	<dict:name>Enrollment Restriction</dict:name>
	<dict:desc>Rules other than perquisites that limit or restrict students from enrolling in a course that do not strictly deal with the student&apos;s academic ability to handle the material.</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="object.luStatementInfo.type.EnrollmentRestriction.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.luStatementType.req.enrollmentRestriction" id="object.luStatementInfo.type.EnrollmentRestriction" parent="object.luStatementInfo.type.EnrollmentRestriction.abstract"/>

<!-- ***************************************************************************** -->
<!-- fields for object.luStatementInfo.type.Enrollment Restriction.state.(default) -->
<!-- ***************************************************************************** -->

<dict:state key="*" id="object.luStatementInfo.type.EnrollmentRestriction.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.name.type.EnrollmentRestriction.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.operator.type.EnrollmentRestriction.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.luStatementIds.type.EnrollmentRestriction.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.reqComponentIds.type.EnrollmentRestriction.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.type.type.EnrollmentRestriction.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.state.type.EnrollmentRestriction.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.id.type.EnrollmentRestriction.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="object.luStatementInfo.type.EnrollmentRestriction.state.DEFAULT" parent="object.luStatementInfo.type.EnrollmentRestriction.state.DEFAULT.abstract"/>


<dict:field key="name" id="field.luStatementInfo.name.type.EnrollmentRestriction.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.name.type.EnrollmentRestriction.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.name.type.EnrollmentRestriction.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="name" id="field.luStatementInfo.name.type.EnrollmentRestriction.state.DEFAULT" parent="field.luStatementInfo.name.type.EnrollmentRestriction.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="name" id="field.luStatementInfo.name.type.EnrollmentRestriction.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Name</dict:name>
	<dict:desc>Friendly name for the LU statement.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="name" id="field.luStatementInfo.name.type.EnrollmentRestriction.state.DEFAULT.fd" parent="field.luStatementInfo.name.type.EnrollmentRestriction.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); A basic single line of text, no embedded carraige returns or tabs limited to 255 -->
<dict:constraintDescriptor id="field.luStatementInfo.name.type.EnrollmentRestriction.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.single.line.text"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="name" id="field.luStatementInfo.name.type.EnrollmentRestriction.state.DEFAULT.cd" parent="field.luStatementInfo.name.type.EnrollmentRestriction.state.DEFAULT.cd.abstract"/>

<dict:field key="desc" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="desc" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT" parent="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="desc" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Description</dict:name>
	<dict:desc>Narrative description for the LU statement.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="desc" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.fd" parent="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.fd.abstract"/>
<!-- Optional; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="desc" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.cd" parent="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.cd.abstract"/>

<!-- ******************************************************************************************************** -->
<!-- object structure for field.luStatementInfo.desc.type.Enrollment Restriction.state.(default).richTextInfo -->
<!-- ******************************************************************************************************** -->
<!-- Complex type supporting both a plain text and formatted version of a string. -->
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo" parent="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.type.DEFAULT" parent="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.type.DEFAULT.abstract"/>

<!-- ***************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.desc.type.Enrollment Restriction.state.(default).richTextInfo.type.(default).state.(default) -->
<!-- ***************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.plain"/>
	<dict:fieldRef bean="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.formatted"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo" parent="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.abstract"/>


<dict:field key="plain" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.plain.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.plain.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.plain.cd"/>
</dict:field>
<dict:field key="plain" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.plain" parent="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.plain.abstract"/>
<dict:fieldDescriptor key="plain" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.plain.fd.abstract" abstract="true">
	<dict:name>Plain Text</dict:name>
	<dict:desc>Plain version of the text. This may be used for searching.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="plain" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.plain.fd" parent="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.plain.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Multi-line text field that accepts all printable characters plus tab, carraige-return and linefeed. -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.plain.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.multi.line.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="plain" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.plain.cd" parent="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.plain.cd.abstract"/>

<dict:field key="formatted" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.formatted.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.formatted.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.formatted.cd"/>
</dict:field>
<dict:field key="formatted" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.formatted" parent="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.formatted.abstract"/>
<dict:fieldDescriptor key="formatted" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.formatted.fd.abstract" abstract="true">
	<dict:name>Formatted Text</dict:name>
	<dict:desc>Formatted version of the text.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="formatted" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.formatted.fd" parent="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.formatted.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Text field that accepts all types of characters using some sort of escaping convention along with the ability to specify bolding, font size, color etc. -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.formatted.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.rich.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="formatted" id="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.formatted.cd" parent="field.luStatementInfo.desc.type.EnrollmentRestriction.state.DEFAULT.richTextInfo.formatted.cd.abstract"/>

<dict:field key="operator" id="field.luStatementInfo.operator.type.EnrollmentRestriction.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.operator.type.EnrollmentRestriction.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.operator.type.EnrollmentRestriction.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="operator" id="field.luStatementInfo.operator.type.EnrollmentRestriction.state.DEFAULT" parent="field.luStatementInfo.operator.type.EnrollmentRestriction.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="operator" id="field.luStatementInfo.operator.type.EnrollmentRestriction.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Operator</dict:name>
	<dict:desc>Logical operator used to assemble statements. Acceptable values are restricted to AND and OR. This operator applies to both the LU statements and requirement components contained within this statement.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="operator" id="field.luStatementInfo.operator.type.EnrollmentRestriction.state.DEFAULT.fd" parent="field.luStatementInfo.operator.type.EnrollmentRestriction.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Alphanumeric code, hypen and period.; In list of configured lu statement operators (AND and OR) -->
<dict:constraintDescriptor id="field.luStatementInfo.operator.type.EnrollmentRestriction.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.code"/>
	<dict:constraintRef bean="constraint.lu.statement.operators"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="operator" id="field.luStatementInfo.operator.type.EnrollmentRestriction.state.DEFAULT.cd" parent="field.luStatementInfo.operator.type.EnrollmentRestriction.state.DEFAULT.cd.abstract"/>

<!-- services has both statement ids and requirement component ids as required but this can't be true.  What is required is that either a statement or requirement component is required so there is a cross field constraint but not both -->
<dict:field key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.EnrollmentRestriction.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.luStatementIds.type.EnrollmentRestriction.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.luStatementIds.type.EnrollmentRestriction.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.EnrollmentRestriction.state.DEFAULT" parent="field.luStatementInfo.luStatementIds.type.EnrollmentRestriction.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.EnrollmentRestriction.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Contained LU Statement Identifiers</dict:name>
	<dict:desc>List of LU statement identifiers.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.EnrollmentRestriction.state.DEFAULT.fd" parent="field.luStatementInfo.luStatementIds.type.EnrollmentRestriction.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating; Id of an existing LU Statement -->
<dict:constraintDescriptor id="field.luStatementInfo.luStatementIds.type.EnrollmentRestriction.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
	<dict:constraintRef bean="constraint.related.luStatementd"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.EnrollmentRestriction.state.DEFAULT.cd" parent="field.luStatementInfo.luStatementIds.type.EnrollmentRestriction.state.DEFAULT.cd.abstract"/>

<!-- services has both statement ids and requirement component ids as required but this can't be true.  What is required is that either a statement or requirement component is required so there is a cross field constraint but not both -->
<dict:field key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.EnrollmentRestriction.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.reqComponentIds.type.EnrollmentRestriction.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.reqComponentIds.type.EnrollmentRestriction.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.EnrollmentRestriction.state.DEFAULT" parent="field.luStatementInfo.reqComponentIds.type.EnrollmentRestriction.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.EnrollmentRestriction.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Contained Requirement Component Identifiers</dict:name>
	<dict:desc>List of requirement component identifiers.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.EnrollmentRestriction.state.DEFAULT.fd" parent="field.luStatementInfo.reqComponentIds.type.EnrollmentRestriction.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating; Id of an existing requirement component -->
<dict:constraintDescriptor id="field.luStatementInfo.reqComponentIds.type.EnrollmentRestriction.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
	<dict:constraintRef bean="constraint.related.requirementComponentId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.EnrollmentRestriction.state.DEFAULT.cd" parent="field.luStatementInfo.reqComponentIds.type.EnrollmentRestriction.state.DEFAULT.cd.abstract"/>

<dict:field key="attributes" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="attributes" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="attributes" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Generic/dynamic attributes</dict:name>
	<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="attributes" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="attributes" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.cd.abstract"/>

<!-- *************************************************************************************************************** -->
<!-- object structure for field.luStatementInfo.attributes.type.Enrollment Restriction.state.(default).attributeInfo -->
<!-- *************************************************************************************************************** -->
<!-- List of key/value pairs, typically used for dynamic attributes. -->
<dict:objectStructure key=".AttributeInfo" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key=".AttributeInfo" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.DEFAULT" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.DEFAULT.abstract"/>

<!-- ************************************************************************************************************************************ -->
<!-- fields for field.luStatementInfo.attributes.type.Enrollment Restriction.state.(default).attributeInfo.type.(default).state.(default) -->
<!-- ************************************************************************************************************************************ -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.fd" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.cd" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.fd" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.cd" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.cd.abstract"/>

<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.EyeColor.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Eye Color</dict:name>
	<dict:desc>Captures the eye color of students expected to take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.EyeColor" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.EyeColor.abstract"/>

<!-- ************************************************************************************************************************************ -->
<!-- fields for field.luStatementInfo.attributes.type.Enrollment Restriction.state.(default).attributeInfo.type.Eye Color.state.(default) -->
<!-- ************************************************************************************************************************************ -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd.abstract"/>

<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.LeftHanded.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Left Handed</dict:name>
	<dict:desc>Captures if the students are expected to be left handed who take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.LeftHanded" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.LeftHanded.abstract"/>

<!-- ************************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.Enrollment Restriction.state.(default).attributeInfo.type.Left Handed.state.(default) -->
<!-- ************************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd.abstract"/>

<!-- This sequence really belongs on both on CLU-LO and LO-LO relationships for Single Use Los - but the most recent version of the services with the relationships as not in use yet, so it has been put here as a temporary solution -->
<dict:type key="kuali.lo.type.SingleUse.dynamic.sequence" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.Sequence.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Sequence</dict:name>
	<dict:desc>Captures the sequence of an LO within a Credit Course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lo.type.SingleUse.dynamic.sequence" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.Sequence" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.Sequence.abstract"/>

<!-- *********************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.Enrollment Restriction.state.(default).attributeInfo.type.Sequence.state.(default) -->
<!-- *********************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.EnrollmentRestriction.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd.abstract"/>

<dict:field key="metaInfo" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="metaInfo" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Create/Update meta info</dict:name>
	<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo"/>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.fd" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.cd" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.cd.abstract"/>

<!-- ******************************************************************************************************** -->
<!-- object structure for field.luStatementInfo.metaInfo.type.Enrollment Restriction.state.(default).metaInfo -->
<!-- ******************************************************************************************************** -->
<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.type.DEFAULT" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.type.DEFAULT.abstract"/>

<!-- ***************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.metaInfo.type.Enrollment Restriction.state.(default).metaInfo.type.(default).state.(default) -->
<!-- ***************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.versionInd"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createTime"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createId"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateTime"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateId"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.abstract"/>


<dict:field key="versionInd" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.versionInd.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.versionInd.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.versionInd.cd"/>
</dict:field>
<dict:field key="versionInd" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.versionInd" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.versionInd.abstract"/>
<dict:fieldDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.versionInd.fd.abstract" abstract="true">
	<dict:name>Version Indicator</dict:name>
	<dict:desc>An indicator of the version of the thing being described with this meta information. This is set by the service implementation and will be used to determine conflicts in updates.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.versionInd.fd" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.versionInd.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Calculates the version indicator that is used for optimistic locking; Read Only -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.versionInd.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
	<dict:constraintRef bean="constraint.read.only"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.versionInd.cd" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.versionInd.cd.abstract"/>

<dict:field key="createTime" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createTime.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createTime.cd"/>
</dict:field>
<dict:field key="createTime" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createTime" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createTime.abstract"/>
<dict:fieldDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Created</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was created</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createTime.fd" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Defaults to NOW, when the object is created -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.default.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createTime.cd" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createTime.cd.abstract"/>

<dict:field key="createId" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createId.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createId.cd"/>
</dict:field>
<dict:field key="createId" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createId" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createId.abstract"/>
<dict:fieldDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createId.fd.abstract" abstract="true">
	<dict:name>Created By Identifier</dict:name>
	<dict:desc>The principal who created the thing being described with this meta information</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createId.fd" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Defaults to the currently authenticated user -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createId.cd" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.createId.cd.abstract"/>

<dict:field key="updateTime" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateTime.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateTime.cd"/>
</dict:field>
<dict:field key="updateTime" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateTime" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateTime.abstract"/>
<dict:fieldDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Last Updated</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was last updated. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateTime.fd" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Sets a field to the current time -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.calc.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateTime.cd" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateTime.cd.abstract"/>

<dict:field key="updateId" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateId.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateId.cd"/>
</dict:field>
<dict:field key="updateId" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateId" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateId.abstract"/>
<dict:fieldDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateId.fd.abstract" abstract="true">
	<dict:name>Updated By Identifier</dict:name>
	<dict:desc>The principal who last updated the thing being described with this meta information. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateId.fd" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Sets a field to the currently authenticated user -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateId.cd" parent="field.luStatementInfo.metaInfo.type.EnrollmentRestriction.state.DEFAULT.metaInfo.updateId.cd.abstract"/>

<dict:field key="type" id="field.luStatementInfo.type.type.EnrollmentRestriction.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.type.type.EnrollmentRestriction.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.type.type.EnrollmentRestriction.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="type" id="field.luStatementInfo.type.type.EnrollmentRestriction.state.DEFAULT" parent="field.luStatementInfo.type.type.EnrollmentRestriction.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="type" id="field.luStatementInfo.type.type.EnrollmentRestriction.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Type Identifier</dict:name>
	<dict:desc>Unique identifier for an LU statement type.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="type" id="field.luStatementInfo.type.type.EnrollmentRestriction.state.DEFAULT.fd" parent="field.luStatementInfo.type.type.EnrollmentRestriction.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of valid lu statement types -->
<dict:constraintDescriptor id="field.luStatementInfo.type.type.EnrollmentRestriction.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.lu.statement.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="type" id="field.luStatementInfo.type.type.EnrollmentRestriction.state.DEFAULT.cd" parent="field.luStatementInfo.type.type.EnrollmentRestriction.state.DEFAULT.cd.abstract"/>

<dict:field key="state" id="field.luStatementInfo.state.type.EnrollmentRestriction.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.state.type.EnrollmentRestriction.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.state.type.EnrollmentRestriction.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="state" id="field.luStatementInfo.state.type.EnrollmentRestriction.state.DEFAULT" parent="field.luStatementInfo.state.type.EnrollmentRestriction.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="state" id="field.luStatementInfo.state.type.EnrollmentRestriction.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement State</dict:name>
	<dict:desc>The current status of the LU statement. The values for this field are constrained to those in the luStatementState enumeration. A separate setup operation does not exist for retrieval of the meta data around this value.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="state" id="field.luStatementInfo.state.type.EnrollmentRestriction.state.DEFAULT.fd" parent="field.luStatementInfo.state.type.EnrollmentRestriction.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali STATE; In list of valid lu statement states -->
<dict:constraintDescriptor id="field.luStatementInfo.state.type.EnrollmentRestriction.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.state"/>
	<dict:constraintRef bean="constraint.lu.statement.states"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="state" id="field.luStatementInfo.state.type.EnrollmentRestriction.state.DEFAULT.cd" parent="field.luStatementInfo.state.type.EnrollmentRestriction.state.DEFAULT.cd.abstract"/>

<dict:field key="id" id="field.luStatementInfo.id.type.EnrollmentRestriction.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.id.type.EnrollmentRestriction.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.id.type.EnrollmentRestriction.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="id" id="field.luStatementInfo.id.type.EnrollmentRestriction.state.DEFAULT" parent="field.luStatementInfo.id.type.EnrollmentRestriction.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="id" id="field.luStatementInfo.id.type.EnrollmentRestriction.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Identifier</dict:name>
	<dict:desc>Unique identifier for a single LU statement record. This is optional, due to the identifier being set at the time of creation. Once the LU statement has been created, this should be seen as required.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="id" id="field.luStatementInfo.id.type.EnrollmentRestriction.state.DEFAULT.fd" parent="field.luStatementInfo.id.type.EnrollmentRestriction.state.DEFAULT.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Kuali ID; calculated by service on add, then read-only. -->
<dict:constraintDescriptor id="field.luStatementInfo.id.type.EnrollmentRestriction.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.id"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="id" id="field.luStatementInfo.id.type.EnrollmentRestriction.state.DEFAULT.cd" parent="field.luStatementInfo.id.type.EnrollmentRestriction.state.DEFAULT.cd.abstract"/>

<dict:type key="kuali.luStatementType.req.antirequisite" id="object.luStatementInfo.type.AntirequisiteRule.abstract" abstract="true" parent="object.luStatementInfo.type.DEFAULT.abstract">
	<dict:name>Antirequisite Rule</dict:name>
	<dict:desc>Rules identifying a specific course or level of attainment which, if already successfully completed, does not permit registration for credit in another desired course, or which may not be taken for credit concurrently with another course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="object.luStatementInfo.type.AntirequisiteRule.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.luStatementType.req.antirequisite" id="object.luStatementInfo.type.AntirequisiteRule" parent="object.luStatementInfo.type.AntirequisiteRule.abstract"/>

<!-- ************************************************************************* -->
<!-- fields for object.luStatementInfo.type.Antirequisite Rule.state.(default) -->
<!-- ************************************************************************* -->

<dict:state key="*" id="object.luStatementInfo.type.AntirequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.name.type.AntirequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.operator.type.AntirequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.luStatementIds.type.AntirequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.reqComponentIds.type.AntirequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.type.type.AntirequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.state.type.AntirequisiteRule.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.id.type.AntirequisiteRule.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="object.luStatementInfo.type.AntirequisiteRule.state.DEFAULT" parent="object.luStatementInfo.type.AntirequisiteRule.state.DEFAULT.abstract"/>


<dict:field key="name" id="field.luStatementInfo.name.type.AntirequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.name.type.AntirequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.name.type.AntirequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="name" id="field.luStatementInfo.name.type.AntirequisiteRule.state.DEFAULT" parent="field.luStatementInfo.name.type.AntirequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="name" id="field.luStatementInfo.name.type.AntirequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Name</dict:name>
	<dict:desc>Friendly name for the LU statement.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="name" id="field.luStatementInfo.name.type.AntirequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.name.type.AntirequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); A basic single line of text, no embedded carraige returns or tabs limited to 255 -->
<dict:constraintDescriptor id="field.luStatementInfo.name.type.AntirequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.single.line.text"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="name" id="field.luStatementInfo.name.type.AntirequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.name.type.AntirequisiteRule.state.DEFAULT.cd.abstract"/>

<dict:field key="desc" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="desc" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT" parent="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="desc" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Description</dict:name>
	<dict:desc>Narrative description for the LU statement.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="desc" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Optional; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="desc" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.cd.abstract"/>

<!-- **************************************************************************************************** -->
<!-- object structure for field.luStatementInfo.desc.type.Antirequisite Rule.state.(default).richTextInfo -->
<!-- **************************************************************************************************** -->
<!-- Complex type supporting both a plain text and formatted version of a string. -->
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo" parent="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.type.DEFAULT" parent="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.type.DEFAULT.abstract"/>

<!-- ************************************************************************************************************************* -->
<!-- fields for field.luStatementInfo.desc.type.Antirequisite Rule.state.(default).richTextInfo.type.(default).state.(default) -->
<!-- ************************************************************************************************************************* -->

<dict:state key="*" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.plain"/>
	<dict:fieldRef bean="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.formatted"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo" parent="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.abstract"/>


<dict:field key="plain" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.plain.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.plain.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.plain.cd"/>
</dict:field>
<dict:field key="plain" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.plain" parent="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.plain.abstract"/>
<dict:fieldDescriptor key="plain" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.plain.fd.abstract" abstract="true">
	<dict:name>Plain Text</dict:name>
	<dict:desc>Plain version of the text. This may be used for searching.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="plain" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.plain.fd" parent="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.plain.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Multi-line text field that accepts all printable characters plus tab, carraige-return and linefeed. -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.plain.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.multi.line.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="plain" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.plain.cd" parent="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.plain.cd.abstract"/>

<dict:field key="formatted" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.formatted.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.formatted.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.formatted.cd"/>
</dict:field>
<dict:field key="formatted" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.formatted" parent="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.formatted.abstract"/>
<dict:fieldDescriptor key="formatted" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.formatted.fd.abstract" abstract="true">
	<dict:name>Formatted Text</dict:name>
	<dict:desc>Formatted version of the text.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="formatted" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.formatted.fd" parent="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.formatted.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Text field that accepts all types of characters using some sort of escaping convention along with the ability to specify bolding, font size, color etc. -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.formatted.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.rich.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="formatted" id="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.formatted.cd" parent="field.luStatementInfo.desc.type.AntirequisiteRule.state.DEFAULT.richTextInfo.formatted.cd.abstract"/>

<dict:field key="operator" id="field.luStatementInfo.operator.type.AntirequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.operator.type.AntirequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.operator.type.AntirequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="operator" id="field.luStatementInfo.operator.type.AntirequisiteRule.state.DEFAULT" parent="field.luStatementInfo.operator.type.AntirequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="operator" id="field.luStatementInfo.operator.type.AntirequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Operator</dict:name>
	<dict:desc>Logical operator used to assemble statements. Acceptable values are restricted to AND and OR. This operator applies to both the LU statements and requirement components contained within this statement.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="operator" id="field.luStatementInfo.operator.type.AntirequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.operator.type.AntirequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Alphanumeric code, hypen and period.; In list of configured lu statement operators (AND and OR) -->
<dict:constraintDescriptor id="field.luStatementInfo.operator.type.AntirequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.code"/>
	<dict:constraintRef bean="constraint.lu.statement.operators"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="operator" id="field.luStatementInfo.operator.type.AntirequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.operator.type.AntirequisiteRule.state.DEFAULT.cd.abstract"/>

<!-- services has both statement ids and requirement component ids as required but this can't be true.  What is required is that either a statement or requirement component is required so there is a cross field constraint but not both -->
<dict:field key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.AntirequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.luStatementIds.type.AntirequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.luStatementIds.type.AntirequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.AntirequisiteRule.state.DEFAULT" parent="field.luStatementInfo.luStatementIds.type.AntirequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.AntirequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Contained LU Statement Identifiers</dict:name>
	<dict:desc>List of LU statement identifiers.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.AntirequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.luStatementIds.type.AntirequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating; Id of an existing LU Statement -->
<dict:constraintDescriptor id="field.luStatementInfo.luStatementIds.type.AntirequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
	<dict:constraintRef bean="constraint.related.luStatementd"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.AntirequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.luStatementIds.type.AntirequisiteRule.state.DEFAULT.cd.abstract"/>

<!-- services has both statement ids and requirement component ids as required but this can't be true.  What is required is that either a statement or requirement component is required so there is a cross field constraint but not both -->
<dict:field key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.AntirequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.reqComponentIds.type.AntirequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.reqComponentIds.type.AntirequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.AntirequisiteRule.state.DEFAULT" parent="field.luStatementInfo.reqComponentIds.type.AntirequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.AntirequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Contained Requirement Component Identifiers</dict:name>
	<dict:desc>List of requirement component identifiers.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.AntirequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.reqComponentIds.type.AntirequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating; Id of an existing requirement component -->
<dict:constraintDescriptor id="field.luStatementInfo.reqComponentIds.type.AntirequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
	<dict:constraintRef bean="constraint.related.requirementComponentId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.AntirequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.reqComponentIds.type.AntirequisiteRule.state.DEFAULT.cd.abstract"/>

<dict:field key="attributes" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="attributes" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="attributes" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Generic/dynamic attributes</dict:name>
	<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="attributes" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="attributes" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.cd.abstract"/>

<!-- *********************************************************************************************************** -->
<!-- object structure for field.luStatementInfo.attributes.type.Antirequisite Rule.state.(default).attributeInfo -->
<!-- *********************************************************************************************************** -->
<!-- List of key/value pairs, typically used for dynamic attributes. -->
<dict:objectStructure key=".AttributeInfo" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key=".AttributeInfo" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT.abstract"/>

<!-- ******************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.Antirequisite Rule.state.(default).attributeInfo.type.(default).state.(default) -->
<!-- ******************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.fd" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.cd" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.fd" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.cd" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.cd.abstract"/>

<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Eye Color</dict:name>
	<dict:desc>Captures the eye color of students expected to take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor.abstract"/>

<!-- ******************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.Antirequisite Rule.state.(default).attributeInfo.type.Eye Color.state.(default) -->
<!-- ******************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd.abstract"/>

<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Left Handed</dict:name>
	<dict:desc>Captures if the students are expected to be left handed who take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded.abstract"/>

<!-- ********************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.Antirequisite Rule.state.(default).attributeInfo.type.Left Handed.state.(default) -->
<!-- ********************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd.abstract"/>

<!-- This sequence really belongs on both on CLU-LO and LO-LO relationships for Single Use Los - but the most recent version of the services with the relationships as not in use yet, so it has been put here as a temporary solution -->
<dict:type key="kuali.lo.type.SingleUse.dynamic.sequence" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.Sequence.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Sequence</dict:name>
	<dict:desc>Captures the sequence of an LO within a Credit Course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lo.type.SingleUse.dynamic.sequence" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.Sequence" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.Sequence.abstract"/>

<!-- ******************************************************************************************************************************* -->
<!-- fields for field.luStatementInfo.attributes.type.Antirequisite Rule.state.(default).attributeInfo.type.Sequence.state.(default) -->
<!-- ******************************************************************************************************************************* -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.AntirequisiteRule.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd.abstract"/>

<dict:field key="metaInfo" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="metaInfo" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Create/Update meta info</dict:name>
	<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo"/>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.cd.abstract"/>

<!-- **************************************************************************************************** -->
<!-- object structure for field.luStatementInfo.metaInfo.type.Antirequisite Rule.state.(default).metaInfo -->
<!-- **************************************************************************************************** -->
<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.type.DEFAULT" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.type.DEFAULT.abstract"/>

<!-- ************************************************************************************************************************* -->
<!-- fields for field.luStatementInfo.metaInfo.type.Antirequisite Rule.state.(default).metaInfo.type.(default).state.(default) -->
<!-- ************************************************************************************************************************* -->

<dict:state key="*" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.versionInd"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createTime"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createId"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateTime"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateId"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.abstract"/>


<dict:field key="versionInd" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.versionInd.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.versionInd.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.versionInd.cd"/>
</dict:field>
<dict:field key="versionInd" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.versionInd" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.versionInd.abstract"/>
<dict:fieldDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.versionInd.fd.abstract" abstract="true">
	<dict:name>Version Indicator</dict:name>
	<dict:desc>An indicator of the version of the thing being described with this meta information. This is set by the service implementation and will be used to determine conflicts in updates.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.versionInd.fd" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.versionInd.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Calculates the version indicator that is used for optimistic locking; Read Only -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.versionInd.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
	<dict:constraintRef bean="constraint.read.only"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.versionInd.cd" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.versionInd.cd.abstract"/>

<dict:field key="createTime" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createTime.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createTime.cd"/>
</dict:field>
<dict:field key="createTime" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createTime" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createTime.abstract"/>
<dict:fieldDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Created</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was created</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createTime.fd" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Defaults to NOW, when the object is created -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.default.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createTime.cd" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createTime.cd.abstract"/>

<dict:field key="createId" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createId.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createId.cd"/>
</dict:field>
<dict:field key="createId" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createId" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createId.abstract"/>
<dict:fieldDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createId.fd.abstract" abstract="true">
	<dict:name>Created By Identifier</dict:name>
	<dict:desc>The principal who created the thing being described with this meta information</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createId.fd" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Defaults to the currently authenticated user -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createId.cd" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.createId.cd.abstract"/>

<dict:field key="updateTime" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateTime.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateTime.cd"/>
</dict:field>
<dict:field key="updateTime" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateTime" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateTime.abstract"/>
<dict:fieldDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Last Updated</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was last updated. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateTime.fd" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Sets a field to the current time -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.calc.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateTime.cd" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateTime.cd.abstract"/>

<dict:field key="updateId" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateId.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateId.cd"/>
</dict:field>
<dict:field key="updateId" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateId" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateId.abstract"/>
<dict:fieldDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateId.fd.abstract" abstract="true">
	<dict:name>Updated By Identifier</dict:name>
	<dict:desc>The principal who last updated the thing being described with this meta information. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateId.fd" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Sets a field to the currently authenticated user -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateId.cd" parent="field.luStatementInfo.metaInfo.type.AntirequisiteRule.state.DEFAULT.metaInfo.updateId.cd.abstract"/>

<dict:field key="type" id="field.luStatementInfo.type.type.AntirequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.type.type.AntirequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.type.type.AntirequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="type" id="field.luStatementInfo.type.type.AntirequisiteRule.state.DEFAULT" parent="field.luStatementInfo.type.type.AntirequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="type" id="field.luStatementInfo.type.type.AntirequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Type Identifier</dict:name>
	<dict:desc>Unique identifier for an LU statement type.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="type" id="field.luStatementInfo.type.type.AntirequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.type.type.AntirequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of valid lu statement types -->
<dict:constraintDescriptor id="field.luStatementInfo.type.type.AntirequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.lu.statement.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="type" id="field.luStatementInfo.type.type.AntirequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.type.type.AntirequisiteRule.state.DEFAULT.cd.abstract"/>

<dict:field key="state" id="field.luStatementInfo.state.type.AntirequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.state.type.AntirequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.state.type.AntirequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="state" id="field.luStatementInfo.state.type.AntirequisiteRule.state.DEFAULT" parent="field.luStatementInfo.state.type.AntirequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="state" id="field.luStatementInfo.state.type.AntirequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement State</dict:name>
	<dict:desc>The current status of the LU statement. The values for this field are constrained to those in the luStatementState enumeration. A separate setup operation does not exist for retrieval of the meta data around this value.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="state" id="field.luStatementInfo.state.type.AntirequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.state.type.AntirequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali STATE; In list of valid lu statement states -->
<dict:constraintDescriptor id="field.luStatementInfo.state.type.AntirequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.state"/>
	<dict:constraintRef bean="constraint.lu.statement.states"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="state" id="field.luStatementInfo.state.type.AntirequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.state.type.AntirequisiteRule.state.DEFAULT.cd.abstract"/>

<dict:field key="id" id="field.luStatementInfo.id.type.AntirequisiteRule.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.id.type.AntirequisiteRule.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.id.type.AntirequisiteRule.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="id" id="field.luStatementInfo.id.type.AntirequisiteRule.state.DEFAULT" parent="field.luStatementInfo.id.type.AntirequisiteRule.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="id" id="field.luStatementInfo.id.type.AntirequisiteRule.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Identifier</dict:name>
	<dict:desc>Unique identifier for a single LU statement record. This is optional, due to the identifier being set at the time of creation. Once the LU statement has been created, this should be seen as required.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="id" id="field.luStatementInfo.id.type.AntirequisiteRule.state.DEFAULT.fd" parent="field.luStatementInfo.id.type.AntirequisiteRule.state.DEFAULT.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Kuali ID; calculated by service on add, then read-only. -->
<dict:constraintDescriptor id="field.luStatementInfo.id.type.AntirequisiteRule.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.id"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="id" id="field.luStatementInfo.id.type.AntirequisiteRule.state.DEFAULT.cd" parent="field.luStatementInfo.id.type.AntirequisiteRule.state.DEFAULT.cd.abstract"/>

<dict:type key="kuali.luStatementType.CourseRepeatCreditApplication" id="object.luStatementInfo.type.CreditApplicationRuleforrepeatedcourses.abstract" abstract="true" parent="object.luStatementInfo.type.DEFAULT.abstract">
	<dict:name>Credit Application Rule for repeated courses</dict:name>
	<dict:desc>Rules that govern or constrain the amount of credit that can be earned when a person takes and completes a credit courses multiple times.</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="object.luStatementInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.luStatementType.CourseRepeatCreditApplication" id="object.luStatementInfo.type.CreditApplicationRuleforrepeatedcourses" parent="object.luStatementInfo.type.CreditApplicationRuleforrepeatedcourses.abstract"/>

<!-- *************************************************************************************************** -->
<!-- fields for object.luStatementInfo.type.Credit Application Rule for repeated courses.state.(default) -->
<!-- *************************************************************************************************** -->

<dict:state key="*" id="object.luStatementInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.name.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.operator.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.luStatementIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.reqComponentIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.type.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.state.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.id.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="object.luStatementInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT" parent="object.luStatementInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract"/>


<dict:field key="name" id="field.luStatementInfo.name.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.name.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.name.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="name" id="field.luStatementInfo.name.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT" parent="field.luStatementInfo.name.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="name" id="field.luStatementInfo.name.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Name</dict:name>
	<dict:desc>Friendly name for the LU statement.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="name" id="field.luStatementInfo.name.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd" parent="field.luStatementInfo.name.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); A basic single line of text, no embedded carraige returns or tabs limited to 255 -->
<dict:constraintDescriptor id="field.luStatementInfo.name.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.single.line.text"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="name" id="field.luStatementInfo.name.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd" parent="field.luStatementInfo.name.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract"/>

<dict:field key="desc" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="desc" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT" parent="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="desc" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Description</dict:name>
	<dict:desc>Narrative description for the LU statement.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="desc" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd" parent="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract"/>
<!-- Optional; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="desc" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd" parent="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract"/>

<!-- ****************************************************************************************************************************** -->
<!-- object structure for field.luStatementInfo.desc.type.Credit Application Rule for repeated courses.state.(default).richTextInfo -->
<!-- ****************************************************************************************************************************** -->
<!-- Complex type supporting both a plain text and formatted version of a string. -->
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo" parent="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.type.DEFAULT" parent="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.type.DEFAULT.abstract"/>

<!-- *************************************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.desc.type.Credit Application Rule for repeated courses.state.(default).richTextInfo.type.(default).state.(default) -->
<!-- *************************************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.plain"/>
	<dict:fieldRef bean="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.formatted"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo" parent="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.abstract"/>


<dict:field key="plain" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.plain.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.plain.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.plain.cd"/>
</dict:field>
<dict:field key="plain" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.plain" parent="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.plain.abstract"/>
<dict:fieldDescriptor key="plain" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.plain.fd.abstract" abstract="true">
	<dict:name>Plain Text</dict:name>
	<dict:desc>Plain version of the text. This may be used for searching.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="plain" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.plain.fd" parent="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.plain.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Multi-line text field that accepts all printable characters plus tab, carraige-return and linefeed. -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.plain.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.multi.line.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="plain" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.plain.cd" parent="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.plain.cd.abstract"/>

<dict:field key="formatted" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.formatted.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.formatted.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.formatted.cd"/>
</dict:field>
<dict:field key="formatted" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.formatted" parent="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.formatted.abstract"/>
<dict:fieldDescriptor key="formatted" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.formatted.fd.abstract" abstract="true">
	<dict:name>Formatted Text</dict:name>
	<dict:desc>Formatted version of the text.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="formatted" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.formatted.fd" parent="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.formatted.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Text field that accepts all types of characters using some sort of escaping convention along with the ability to specify bolding, font size, color etc. -->
<dict:constraintDescriptor id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.formatted.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.rich.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="formatted" id="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.formatted.cd" parent="field.luStatementInfo.desc.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.richTextInfo.formatted.cd.abstract"/>

<dict:field key="operator" id="field.luStatementInfo.operator.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.operator.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.operator.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="operator" id="field.luStatementInfo.operator.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT" parent="field.luStatementInfo.operator.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="operator" id="field.luStatementInfo.operator.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Operator</dict:name>
	<dict:desc>Logical operator used to assemble statements. Acceptable values are restricted to AND and OR. This operator applies to both the LU statements and requirement components contained within this statement.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="operator" id="field.luStatementInfo.operator.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd" parent="field.luStatementInfo.operator.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Alphanumeric code, hypen and period.; In list of configured lu statement operators (AND and OR) -->
<dict:constraintDescriptor id="field.luStatementInfo.operator.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.code"/>
	<dict:constraintRef bean="constraint.lu.statement.operators"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="operator" id="field.luStatementInfo.operator.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd" parent="field.luStatementInfo.operator.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract"/>

<!-- services has both statement ids and requirement component ids as required but this can't be true.  What is required is that either a statement or requirement component is required so there is a cross field constraint but not both -->
<dict:field key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.luStatementIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.luStatementIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT" parent="field.luStatementInfo.luStatementIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Contained LU Statement Identifiers</dict:name>
	<dict:desc>List of LU statement identifiers.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd" parent="field.luStatementInfo.luStatementIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating; Id of an existing LU Statement -->
<dict:constraintDescriptor id="field.luStatementInfo.luStatementIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
	<dict:constraintRef bean="constraint.related.luStatementd"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="luStatementIds" id="field.luStatementInfo.luStatementIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd" parent="field.luStatementInfo.luStatementIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract"/>

<!-- services has both statement ids and requirement component ids as required but this can't be true.  What is required is that either a statement or requirement component is required so there is a cross field constraint but not both -->
<dict:field key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.reqComponentIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.reqComponentIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT" parent="field.luStatementInfo.reqComponentIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Contained Requirement Component Identifiers</dict:name>
	<dict:desc>List of requirement component identifiers.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd" parent="field.luStatementInfo.reqComponentIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating; Id of an existing requirement component -->
<dict:constraintDescriptor id="field.luStatementInfo.reqComponentIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
	<dict:constraintRef bean="constraint.related.requirementComponentId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="reqComponentIds" id="field.luStatementInfo.reqComponentIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd" parent="field.luStatementInfo.reqComponentIds.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract"/>

<dict:field key="attributes" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="attributes" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="attributes" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Generic/dynamic attributes</dict:name>
	<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="attributes" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract"/>
<!-- Optional; Repeating -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.repeating"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="attributes" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract"/>

<!-- ************************************************************************************************************************************* -->
<!-- object structure for field.luStatementInfo.attributes.type.Credit Application Rule for repeated courses.state.(default).attributeInfo -->
<!-- ************************************************************************************************************************************* -->
<!-- List of key/value pairs, typically used for dynamic attributes. -->
<dict:objectStructure key=".AttributeInfo" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key=".AttributeInfo" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.DEFAULT" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.DEFAULT.abstract"/>

<!-- ********************************************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.Credit Application Rule for repeated courses.state.(default).attributeInfo.type.(default).state.(default) -->
<!-- ********************************************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.fd" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.cd" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.fd" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.cd" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.cd.abstract"/>

<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.EyeColor.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Eye Color</dict:name>
	<dict:desc>Captures the eye color of students expected to take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.EyeColor" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.EyeColor.abstract"/>

<!-- ********************************************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.attributes.type.Credit Application Rule for repeated courses.state.(default).attributeInfo.type.Eye Color.state.(default) -->
<!-- ********************************************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.EyeColor.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.EyeColor.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.EyeColor.state.DEFAULT.cd.abstract"/>

<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.LeftHanded.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Left Handed</dict:name>
	<dict:desc>Captures if the students are expected to be left handed who take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.LeftHanded" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.LeftHanded.abstract"/>

<!-- ************************************************************************************************************************************************************ -->
<!-- fields for field.luStatementInfo.attributes.type.Credit Application Rule for repeated courses.state.(default).attributeInfo.type.Left Handed.state.(default) -->
<!-- ************************************************************************************************************************************************************ -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.LeftHanded.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.LeftHanded.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.LeftHanded.state.DEFAULT.cd.abstract"/>

<!-- This sequence really belongs on both on CLU-LO and LO-LO relationships for Single Use Los - but the most recent version of the services with the relationships as not in use yet, so it has been put here as a temporary solution -->
<dict:type key="kuali.lo.type.SingleUse.dynamic.sequence" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.Sequence.abstract" abstract="true" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.DEFAULT.abstract">
	<dict:name>Sequence</dict:name>
	<dict:desc>Captures the sequence of an LO within a Credit Course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT"/>
</dict:type>
<dict:type key="kuali.lo.type.SingleUse.dynamic.sequence" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.Sequence" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.Sequence.abstract"/>

<!-- ********************************************************************************************************************************************************* -->
<!-- fields for field.luStatementInfo.attributes.type.Credit Application Rule for repeated courses.state.(default).attributeInfo.type.Sequence.state.(default) -->
<!-- ********************************************************************************************************************************************************* -->

<dict:state key="*" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT"/>
	<dict:fieldRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.type.Sequence.state.DEFAULT.abstract"/>


<dict:field key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Value</dict:name>
	<dict:desc>The value for this dynamic attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
	<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="value" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.value.type.Sequence.state.DEFAULT.cd.abstract"/>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd"/>
<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Attribute Type Identifier</dict:name>
	<dict:desc>The identifier for this attribute.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured dynamic field types -->
<dict:constraintDescriptor id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.dynamic.field.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd" parent="field.luStatementInfo.attributes.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.attributeInfo.key.type.Sequence.state.DEFAULT.cd.abstract"/>

<dict:field key="metaInfo" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="metaInfo" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>Create/Update meta info</dict:name>
	<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
	<dict:dataType>complex</dict:dataType>
		<dict:objectStructureRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo"/>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="metaInfo" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract"/>

<!-- ****************************************************************************************************************************** -->
<!-- object structure for field.luStatementInfo.metaInfo.type.Credit Application Rule for repeated courses.state.(default).metaInfo -->
<!-- ****************************************************************************************************************************** -->
<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.abstract" abstract="true">
	<dict:typeRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.type.DEFAULT"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.abstract"/>

<dict:type key="*" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.type.DEFAULT.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo"/>
</dict:type>
<dict:type key="*" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.type.DEFAULT" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.type.DEFAULT.abstract"/>

<!-- *************************************************************************************************************************************************** -->
<!-- fields for field.luStatementInfo.metaInfo.type.Credit Application Rule for repeated courses.state.(default).metaInfo.type.(default).state.(default) -->
<!-- *************************************************************************************************************************************************** -->

<dict:state key="*" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.versionInd"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createTime"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createId"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateTime"/>
	<dict:fieldRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateId"/>
</dict:state>
<dict:state key="*" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.abstract"/>


<dict:field key="versionInd" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.versionInd.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.versionInd.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.versionInd.cd"/>
</dict:field>
<dict:field key="versionInd" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.versionInd" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.versionInd.abstract"/>
<dict:fieldDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.versionInd.fd.abstract" abstract="true">
	<dict:name>Version Indicator</dict:name>
	<dict:desc>An indicator of the version of the thing being described with this meta information. This is set by the service implementation and will be used to determine conflicts in updates.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.versionInd.fd" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.versionInd.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Calculates the version indicator that is used for optimistic locking; Read Only -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.versionInd.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
	<dict:constraintRef bean="constraint.read.only"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="versionInd" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.versionInd.cd" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.versionInd.cd.abstract"/>

<dict:field key="createTime" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createTime.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createTime.cd"/>
</dict:field>
<dict:field key="createTime" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createTime" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createTime.abstract"/>
<dict:fieldDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Created</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was created</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createTime.fd" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Defaults to NOW, when the object is created -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.default.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createTime" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createTime.cd" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createTime.cd.abstract"/>

<dict:field key="createId" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createId.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createId.cd"/>
</dict:field>
<dict:field key="createId" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createId" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createId.abstract"/>
<dict:fieldDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createId.fd.abstract" abstract="true">
	<dict:name>Created By Identifier</dict:name>
	<dict:desc>The principal who created the thing being described with this meta information</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createId.fd" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Defaults to the currently authenticated user -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createId" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createId.cd" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.createId.cd.abstract"/>

<dict:field key="updateTime" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateTime.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateTime.cd"/>
</dict:field>
<dict:field key="updateTime" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateTime" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateTime.abstract"/>
<dict:fieldDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Last Updated</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was last updated. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateTime.fd" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Sets a field to the current time -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.calc.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateTime" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateTime.cd" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateTime.cd.abstract"/>

<dict:field key="updateId" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateId.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateId.cd"/>
</dict:field>
<dict:field key="updateId" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateId" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateId.abstract"/>
<dict:fieldDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateId.fd.abstract" abstract="true">
	<dict:name>Updated By Identifier</dict:name>
	<dict:desc>The principal who last updated the thing being described with this meta information. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateId.fd" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Sets a field to the currently authenticated user -->
<dict:constraintDescriptor id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateId" id="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateId.cd" parent="field.luStatementInfo.metaInfo.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.metaInfo.updateId.cd.abstract"/>

<dict:field key="type" id="field.luStatementInfo.type.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.type.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.type.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="type" id="field.luStatementInfo.type.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT" parent="field.luStatementInfo.type.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="type" id="field.luStatementInfo.type.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Type Identifier</dict:name>
	<dict:desc>Unique identifier for an LU statement type.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="type" id="field.luStatementInfo.type.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd" parent="field.luStatementInfo.type.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of valid lu statement types -->
<dict:constraintDescriptor id="field.luStatementInfo.type.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.lu.statement.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="type" id="field.luStatementInfo.type.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd" parent="field.luStatementInfo.type.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract"/>

<dict:field key="state" id="field.luStatementInfo.state.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.state.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.state.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="state" id="field.luStatementInfo.state.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT" parent="field.luStatementInfo.state.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="state" id="field.luStatementInfo.state.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement State</dict:name>
	<dict:desc>The current status of the LU statement. The values for this field are constrained to those in the luStatementState enumeration. A separate setup operation does not exist for retrieval of the meta data around this value.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="state" id="field.luStatementInfo.state.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd" parent="field.luStatementInfo.state.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali STATE; In list of valid lu statement states -->
<dict:constraintDescriptor id="field.luStatementInfo.state.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.state"/>
	<dict:constraintRef bean="constraint.lu.statement.states"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="state" id="field.luStatementInfo.state.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd" parent="field.luStatementInfo.state.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract"/>

<dict:field key="id" id="field.luStatementInfo.id.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.luStatementInfo.id.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd"/>
	<dict:constraintDescriptorRef bean="field.luStatementInfo.id.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd"/>
</dict:field>
<dict:field key="id" id="field.luStatementInfo.id.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT" parent="field.luStatementInfo.id.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.abstract"/>
<dict:fieldDescriptor key="id" id="field.luStatementInfo.id.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract" abstract="true">
	<dict:name>LU Statement Identifier</dict:name>
	<dict:desc>Unique identifier for a single LU statement record. This is optional, due to the identifier being set at the time of creation. Once the LU statement has been created, this should be seen as required.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor key="id" id="field.luStatementInfo.id.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd" parent="field.luStatementInfo.id.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Kuali ID; calculated by service on add, then read-only. -->
<dict:constraintDescriptor id="field.luStatementInfo.id.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.id"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="id" id="field.luStatementInfo.id.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd" parent="field.luStatementInfo.id.type.CreditApplicationRuleforrepeatedcourses.state.DEFAULT.cd.abstract"/>
</beans>
