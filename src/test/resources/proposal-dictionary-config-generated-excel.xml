<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:dict="http://student.kuali.org/xsd/dictionary-extension"
xsi:schemaLocation="
http://student.kuali.org/xsd/dictionary-extension dictionary-extension.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
">
<!-- *** Automatically Generated ***
on: Tue Feb 02 13:57:52 EST 2010
by: org.kuali.student.dictionary.writer.DictionaryModelWriter
Using:Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls   and: Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls
 -->
import src/test/resources/constraints-dictionary-config-generated-excel.xml
	
	<dict:objectStructure key="org.kuali.student.core.proposal.dto.ProposalInfo">
		<!-- Detailed information about a proposal. -->
		<dict:type key="kuali.proposal.type.course.*">
		<!-- All course proposal types -->
		<!-- This is a grouping of types -->
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				
				<dict:field id="all.course.proposals.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>all course proposals name</dict:name>
						<dict:desc>all course proposals name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.proposerPerson" key="proposerPerson">
					<dict:fieldDescriptor>
						<dict:name>all course proposals proposerPerson</dict:name>
						<dict:desc>all course proposals proposerPerson</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.related.personId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.proposerOrg" key="proposerOrg">
					<dict:fieldDescriptor>
						<dict:name>all course proposals proposerOrg</dict:name>
						<dict:desc>all course proposals proposerOrg</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.related.orgId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.proposalReferenceType" key="proposalReferenceType">
					<dict:fieldDescriptor>
						<dict:name>all course proposals proposalReferenceType</dict:name>
						<dict:desc>all course proposals proposalReferenceType</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.reference.types"/>
							<dict:constraintRef bean="constraint.hard.coded.referenceType.CLU"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.proposalReference" key="proposalReference">
					<dict:fieldDescriptor>
						<dict:name>all course proposals proposalReference</dict:name>
						<dict:desc>all course proposals proposalReference</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.related.cluId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.rationale.draft.private" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all course proposals rationale</dict:name>
						<dict:desc>all course proposals rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.multi.line.text"/>
							<dict:constraintRef bean="constraint.optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.detailDesc" key="detailDesc">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all course proposals detailDesc</dict:name>
						<dict:desc>all course proposals detailDesc</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.multi.line.text"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>all course proposals effectiveDate</dict:name>
						<dict:desc>all course proposals effectiveDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>all course proposals expirationDate</dict:name>
						<dict:desc>all course proposals expirationDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>all course proposals attributes</dict:name>
						<dict:desc>all course proposals attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="all.course.proposals.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>all course proposals metaInfo</dict:name>
						<dict:desc>all course proposals metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="all.course.proposals.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>all course proposals meta versionInd</dict:name>
												<dict:desc>Version number for this all course proposals</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.course.proposals.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>all course proposals meta createTime</dict:name>
												<dict:desc>Date-time this all course proposals was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.course.proposals.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>all course proposals meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this all course proposals</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.course.proposals.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>all course proposals meta updateTime</dict:name>
												<dict:desc>Date-time this  all course proposals was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.course.proposals.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>all course proposals meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this  all course proposals</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>all course proposals type</dict:name>
						<dict:desc>all course proposals type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.proposal.types"/>
							<dict:constraintRef bean="constraint.course.proposal.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>all course proposals state</dict:name>
						<dict:desc>all course proposals state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="all.course.proposals.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>all course proposals internal id</dict:name>
						<dict:desc>all course proposals internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.id"/>
							<dict:constraintRef bean="constraint.hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				
				<dict:field id="all.course.proposals.rationale.draft.public" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all course proposals rationale</dict:name>
						<dict:desc>all course proposals rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.multi.line.text"/>
							<dict:constraintRef bean="constraint.optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
			<!-- NOT IN SIMPLEs -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				
				<dict:field id="all.course.proposals.rationale" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all course proposals rationale</dict:name>
						<dict:desc>all course proposals rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.multi.line.text"/>
							<dict:constraintRef bean="constraint.required"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved -->
			<!-- not sure if we will have to create different declined states for different types of rejections -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before published) -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- we may have to differentiate between 'retired' and proposals that are simply 'older versions' -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- Inactive -->
			<!-- used for proposals created as part of revision history - not sure if we need -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.proposal.type.program.*">
		<!-- All program proposal types -->
		<!-- This is a grouping of program types -->
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				
				<dict:field id="all.program.proposals.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>all program proposals name</dict:name>
						<dict:desc>all program proposals name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.proposerPerson" key="proposerPerson">
					<dict:fieldDescriptor>
						<dict:name>all program proposals proposerPerson</dict:name>
						<dict:desc>all program proposals proposerPerson</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.related.personId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.proposerOrg" key="proposerOrg">
					<dict:fieldDescriptor>
						<dict:name>all program proposals proposerOrg</dict:name>
						<dict:desc>all program proposals proposerOrg</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.related.orgId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.proposalReferenceType" key="proposalReferenceType">
					<dict:fieldDescriptor>
						<dict:name>all program proposals proposalReferenceType</dict:name>
						<dict:desc>all program proposals proposalReferenceType</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.reference.types"/>
							<dict:constraintRef bean="constraint.hard.coded.referenceType.CLU"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.proposalReference" key="proposalReference">
					<dict:fieldDescriptor>
						<dict:name>all program proposals proposalReference</dict:name>
						<dict:desc>all program proposals proposalReference</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.related.cluId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.rationale.draft.private" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all program proposals rationale</dict:name>
						<dict:desc>all program proposals rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.multi.line.text"/>
							<dict:constraintRef bean="constraint.optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.detailDesc" key="detailDesc">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all program proposals detailDesc</dict:name>
						<dict:desc>all program proposals detailDesc</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.multi.line.text"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>all program proposals effectiveDate</dict:name>
						<dict:desc>all program proposals effectiveDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>all program proposals expirationDate</dict:name>
						<dict:desc>all program proposals expirationDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>all program proposals attributes</dict:name>
						<dict:desc>all program proposals attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="all.program.proposals.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>all program proposals metaInfo</dict:name>
						<dict:desc>all program proposals metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="all.program.proposals.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>all program proposals meta versionInd</dict:name>
												<dict:desc>Version number for this all program proposals</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.program.proposals.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>all program proposals meta createTime</dict:name>
												<dict:desc>Date-time this all program proposals was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.program.proposals.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>all program proposals meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this all program proposals</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.program.proposals.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>all program proposals meta updateTime</dict:name>
												<dict:desc>Date-time this  all program proposals was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.program.proposals.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>all program proposals meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this  all program proposals</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>all program proposals type</dict:name>
						<dict:desc>all program proposals type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.proposal.types"/>
							<dict:constraintRef bean="constraint.program.proposal.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.program.proposals.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>all program proposals state</dict:name>
						<dict:desc>all program proposals state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="all.program.proposals.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>all program proposals internal id</dict:name>
						<dict:desc>all program proposals internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.id"/>
							<dict:constraintRef bean="constraint.hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="all.program.proposals.name"/>
				<dict:fieldRef bean="all.program.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.program.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.program.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.program.proposals.proposalReference"/>
				
				<dict:field id="all.program.proposals.rationale.draft.public" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all program proposals rationale</dict:name>
						<dict:desc>all program proposals rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.multi.line.text"/>
							<dict:constraintRef bean="constraint.optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="all.program.proposals.detailDesc"/>
				<dict:fieldRef bean="all.program.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.program.proposals.expirationDate"/>
				<dict:fieldRef bean="all.program.proposals.attributes"/>
				<dict:fieldRef bean="all.program.proposals.metaInfo"/>
				<dict:fieldRef bean="all.program.proposals.type"/>
				<dict:fieldRef bean="all.program.proposals.state"/>
				<dict:fieldRef bean="all.program.proposals.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
			<!-- NOT IN SIMPLEs -->
				<dict:fieldRef bean="all.program.proposals.name"/>
				<dict:fieldRef bean="all.program.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.program.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.program.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.program.proposals.proposalReference"/>
				
				<dict:field id="all.program.proposals.rationale" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all program proposals rationale</dict:name>
						<dict:desc>all program proposals rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.multi.line.text"/>
							<dict:constraintRef bean="constraint.required"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="all.program.proposals.detailDesc"/>
				<dict:fieldRef bean="all.program.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.program.proposals.expirationDate"/>
				<dict:fieldRef bean="all.program.proposals.attributes"/>
				<dict:fieldRef bean="all.program.proposals.metaInfo"/>
				<dict:fieldRef bean="all.program.proposals.type"/>
				<dict:fieldRef bean="all.program.proposals.state"/>
				<dict:fieldRef bean="all.program.proposals.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="all.program.proposals.name"/>
				<dict:fieldRef bean="all.program.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.program.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.program.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.program.proposals.proposalReference"/>
				<dict:fieldRef bean="all.program.proposals.rationale"/>
				<dict:fieldRef bean="all.program.proposals.detailDesc"/>
				<dict:fieldRef bean="all.program.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.program.proposals.expirationDate"/>
				<dict:fieldRef bean="all.program.proposals.attributes"/>
				<dict:fieldRef bean="all.program.proposals.metaInfo"/>
				<dict:fieldRef bean="all.program.proposals.type"/>
				<dict:fieldRef bean="all.program.proposals.state"/>
				<dict:fieldRef bean="all.program.proposals.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved -->
			<!-- not sure if we will have to create different declined states for different types of rejections -->
				<dict:fieldRef bean="all.program.proposals.name"/>
				<dict:fieldRef bean="all.program.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.program.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.program.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.program.proposals.proposalReference"/>
				<dict:fieldRef bean="all.program.proposals.rationale"/>
				<dict:fieldRef bean="all.program.proposals.detailDesc"/>
				<dict:fieldRef bean="all.program.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.program.proposals.expirationDate"/>
				<dict:fieldRef bean="all.program.proposals.attributes"/>
				<dict:fieldRef bean="all.program.proposals.metaInfo"/>
				<dict:fieldRef bean="all.program.proposals.type"/>
				<dict:fieldRef bean="all.program.proposals.state"/>
				<dict:fieldRef bean="all.program.proposals.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before published) -->
				<dict:fieldRef bean="all.program.proposals.name"/>
				<dict:fieldRef bean="all.program.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.program.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.program.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.program.proposals.proposalReference"/>
				<dict:fieldRef bean="all.program.proposals.rationale"/>
				<dict:fieldRef bean="all.program.proposals.detailDesc"/>
				<dict:fieldRef bean="all.program.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.program.proposals.expirationDate"/>
				<dict:fieldRef bean="all.program.proposals.attributes"/>
				<dict:fieldRef bean="all.program.proposals.metaInfo"/>
				<dict:fieldRef bean="all.program.proposals.type"/>
				<dict:fieldRef bean="all.program.proposals.state"/>
				<dict:fieldRef bean="all.program.proposals.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- we may have to differentiate between 'retired' and proposals that are simply 'older versions' -->
				<dict:fieldRef bean="all.program.proposals.name"/>
				<dict:fieldRef bean="all.program.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.program.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.program.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.program.proposals.proposalReference"/>
				<dict:fieldRef bean="all.program.proposals.rationale"/>
				<dict:fieldRef bean="all.program.proposals.detailDesc"/>
				<dict:fieldRef bean="all.program.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.program.proposals.expirationDate"/>
				<dict:fieldRef bean="all.program.proposals.attributes"/>
				<dict:fieldRef bean="all.program.proposals.metaInfo"/>
				<dict:fieldRef bean="all.program.proposals.type"/>
				<dict:fieldRef bean="all.program.proposals.state"/>
				<dict:fieldRef bean="all.program.proposals.internal.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- Inactive -->
			<!-- used for proposals created as part of revision history - not sure if we need -->
				<dict:fieldRef bean="all.program.proposals.name"/>
				<dict:fieldRef bean="all.program.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.program.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.program.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.program.proposals.proposalReference"/>
				<dict:fieldRef bean="all.program.proposals.rationale"/>
				<dict:fieldRef bean="all.program.proposals.detailDesc"/>
				<dict:fieldRef bean="all.program.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.program.proposals.expirationDate"/>
				<dict:fieldRef bean="all.program.proposals.attributes"/>
				<dict:fieldRef bean="all.program.proposals.metaInfo"/>
				<dict:fieldRef bean="all.program.proposals.type"/>
				<dict:fieldRef bean="all.program.proposals.state"/>
				<dict:fieldRef bean="all.program.proposals.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.proposal.type.group">
		<!-- A  group of proposals -->
		<!-- do these really need to be course specific? -->
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				
				<dict:field id="group.proposal.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>group proposal name</dict:name>
						<dict:desc>group proposal name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.single.line.text"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.proposerPerson" key="proposerPerson">
					<dict:fieldDescriptor>
						<dict:name>group proposal proposerPerson</dict:name>
						<dict:desc>group proposal proposerPerson</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.related.personId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.proposerOrg" key="proposerOrg">
					<dict:fieldDescriptor>
						<dict:name>group proposal proposerOrg</dict:name>
						<dict:desc>group proposal proposerOrg</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.related.orgId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.proposalReferenceType" key="proposalReferenceType">
					<dict:fieldDescriptor>
						<dict:name>group proposal proposalReferenceType</dict:name>
						<dict:desc>group proposal proposalReferenceType</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.reference.types"/>
							<dict:constraintRef bean="constraint.hard.coded.referenceType.Proposal"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.proposalReference" key="proposalReference">
					<dict:fieldDescriptor>
						<dict:name>group proposal proposalReference</dict:name>
						<dict:desc>group proposal proposalReference</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.related.proposal"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.rationale.draft.private" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>group proposal rationale</dict:name>
						<dict:desc>group proposal rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.multi.line.text"/>
							<dict:constraintRef bean="constraint.optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.detailDesc" key="detailDesc">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>group proposal detailDesc</dict:name>
						<dict:desc>group proposal detailDesc</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.multi.line.text"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>group proposal effectiveDate</dict:name>
						<dict:desc>group proposal effectiveDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
							<dict:constraintRef bean="constraint.default.today"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>group proposal expirationDate</dict:name>
						<dict:desc>group proposal expirationDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>group proposal attributes</dict:name>
						<dict:desc>group proposal attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="group.proposal.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>group proposal metaInfo</dict:name>
						<dict:desc>group proposal metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="group.proposal.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>create course proposal meta versionInd</dict:name>
												<dict:desc>Version number for this create course proposal</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="group.proposal.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>create course proposal meta createTime</dict:name>
												<dict:desc>Date-time this create course proposal was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="group.proposal.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>create course proposal meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this create course proposal</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="group.proposal.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>create course proposal meta updateTime</dict:name>
												<dict:desc>Date-time this  create course proposal was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="group.proposal.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>create course proposal meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this  create course proposal</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>group proposal type</dict:name>
						<dict:desc>group proposal type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.proposal.types"/>
							<dict:constraintRef bean="constraint.hard.coded.group.proposal"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="group.proposal.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>group proposal state</dict:name>
						<dict:desc>group proposal state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="group.proposal.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>group proposal internal id</dict:name>
						<dict:desc>group proposal internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.id"/>
							<dict:constraintRef bean="constraint.hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="group.proposal.name"/>
				<dict:fieldRef bean="group.proposal.proposerPerson"/>
				<dict:fieldRef bean="group.proposal.proposerOrg"/>
				<dict:fieldRef bean="group.proposal.proposalReferenceType"/>
				<dict:fieldRef bean="group.proposal.proposalReference"/>
				
				<dict:field id="group.proposal.rationale.draft.public" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>group proposal rationale</dict:name>
						<dict:desc>group proposal rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.multi.line.text"/>
							<dict:constraintRef bean="constraint.optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="group.proposal.detailDesc"/>
				<dict:fieldRef bean="group.proposal.effectiveDate"/>
				<dict:fieldRef bean="group.proposal.expirationDate"/>
				<dict:fieldRef bean="group.proposal.attributes"/>
				<dict:fieldRef bean="group.proposal.metaInfo"/>
				<dict:fieldRef bean="group.proposal.type"/>
				<dict:fieldRef bean="group.proposal.state"/>
				<dict:fieldRef bean="group.proposal.internal.id"/>
			</dict:state>
			<dict:state key="submitted">
			<!-- Submitted but not yet approved -->
			<!-- NOT IN SIMPLEs -->
				<dict:fieldRef bean="group.proposal.name"/>
				<dict:fieldRef bean="group.proposal.proposerPerson"/>
				<dict:fieldRef bean="group.proposal.proposerOrg"/>
				<dict:fieldRef bean="group.proposal.proposalReferenceType"/>
				<dict:fieldRef bean="group.proposal.proposalReference"/>
				
				<dict:field id="group.proposal.rationale" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>group proposal rationale</dict:name>
						<dict:desc>group proposal rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.multi.line.text"/>
							<dict:constraintRef bean="constraint.required"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="group.proposal.detailDesc"/>
				<dict:fieldRef bean="group.proposal.effectiveDate"/>
				<dict:fieldRef bean="group.proposal.expirationDate"/>
				<dict:fieldRef bean="group.proposal.attributes"/>
				<dict:fieldRef bean="group.proposal.metaInfo"/>
				<dict:fieldRef bean="group.proposal.type"/>
				<dict:fieldRef bean="group.proposal.state"/>
				<dict:fieldRef bean="group.proposal.internal.id"/>
			</dict:state>
			<dict:state key="approved">
			<!-- Approved -->
				<dict:fieldRef bean="group.proposal.name"/>
				<dict:fieldRef bean="group.proposal.proposerPerson"/>
				<dict:fieldRef bean="group.proposal.proposerOrg"/>
				<dict:fieldRef bean="group.proposal.proposalReferenceType"/>
				<dict:fieldRef bean="group.proposal.proposalReference"/>
				<dict:fieldRef bean="group.proposal.rationale"/>
				<dict:fieldRef bean="group.proposal.detailDesc"/>
				<dict:fieldRef bean="group.proposal.effectiveDate"/>
				<dict:fieldRef bean="group.proposal.expirationDate"/>
				<dict:fieldRef bean="group.proposal.attributes"/>
				<dict:fieldRef bean="group.proposal.metaInfo"/>
				<dict:fieldRef bean="group.proposal.type"/>
				<dict:fieldRef bean="group.proposal.state"/>
				<dict:fieldRef bean="group.proposal.internal.id"/>
			</dict:state>
			<dict:state key="rejected">
			<!-- Not approved -->
			<!-- not sure if we will have to create different declined states for different types of rejections -->
				<dict:fieldRef bean="group.proposal.name"/>
				<dict:fieldRef bean="group.proposal.proposerPerson"/>
				<dict:fieldRef bean="group.proposal.proposerOrg"/>
				<dict:fieldRef bean="group.proposal.proposalReferenceType"/>
				<dict:fieldRef bean="group.proposal.proposalReference"/>
				<dict:fieldRef bean="group.proposal.rationale"/>
				<dict:fieldRef bean="group.proposal.detailDesc"/>
				<dict:fieldRef bean="group.proposal.effectiveDate"/>
				<dict:fieldRef bean="group.proposal.expirationDate"/>
				<dict:fieldRef bean="group.proposal.attributes"/>
				<dict:fieldRef bean="group.proposal.metaInfo"/>
				<dict:fieldRef bean="group.proposal.type"/>
				<dict:fieldRef bean="group.proposal.state"/>
				<dict:fieldRef bean="group.proposal.internal.id"/>
			</dict:state>
			<dict:state key="withdrawn">
			<!-- Withdrawn (anytime before published) -->
				<dict:fieldRef bean="group.proposal.name"/>
				<dict:fieldRef bean="group.proposal.proposerPerson"/>
				<dict:fieldRef bean="group.proposal.proposerOrg"/>
				<dict:fieldRef bean="group.proposal.proposalReferenceType"/>
				<dict:fieldRef bean="group.proposal.proposalReference"/>
				<dict:fieldRef bean="group.proposal.rationale"/>
				<dict:fieldRef bean="group.proposal.detailDesc"/>
				<dict:fieldRef bean="group.proposal.effectiveDate"/>
				<dict:fieldRef bean="group.proposal.expirationDate"/>
				<dict:fieldRef bean="group.proposal.attributes"/>
				<dict:fieldRef bean="group.proposal.metaInfo"/>
				<dict:fieldRef bean="group.proposal.type"/>
				<dict:fieldRef bean="group.proposal.state"/>
				<dict:fieldRef bean="group.proposal.internal.id"/>
			</dict:state>
			<dict:state key="retired">
			<!-- Retired/No longer active -->
			<!-- we may have to differentiate between 'retired' and proposals that are simply 'older versions' -->
				<dict:fieldRef bean="group.proposal.name"/>
				<dict:fieldRef bean="group.proposal.proposerPerson"/>
				<dict:fieldRef bean="group.proposal.proposerOrg"/>
				<dict:fieldRef bean="group.proposal.proposalReferenceType"/>
				<dict:fieldRef bean="group.proposal.proposalReference"/>
				<dict:fieldRef bean="group.proposal.rationale"/>
				<dict:fieldRef bean="group.proposal.detailDesc"/>
				<dict:fieldRef bean="group.proposal.effectiveDate"/>
				<dict:fieldRef bean="group.proposal.expirationDate"/>
				<dict:fieldRef bean="group.proposal.attributes"/>
				<dict:fieldRef bean="group.proposal.metaInfo"/>
				<dict:fieldRef bean="group.proposal.type"/>
				<dict:fieldRef bean="group.proposal.state"/>
				<dict:fieldRef bean="group.proposal.internal.id"/>
			</dict:state>
			<dict:state key="inactive">
			<!-- Inactive -->
			<!-- used for proposals created as part of revision history - not sure if we need -->
				<dict:fieldRef bean="group.proposal.name"/>
				<dict:fieldRef bean="group.proposal.proposerPerson"/>
				<dict:fieldRef bean="group.proposal.proposerOrg"/>
				<dict:fieldRef bean="group.proposal.proposalReferenceType"/>
				<dict:fieldRef bean="group.proposal.proposalReference"/>
				<dict:fieldRef bean="group.proposal.rationale"/>
				<dict:fieldRef bean="group.proposal.detailDesc"/>
				<dict:fieldRef bean="group.proposal.effectiveDate"/>
				<dict:fieldRef bean="group.proposal.expirationDate"/>
				<dict:fieldRef bean="group.proposal.attributes"/>
				<dict:fieldRef bean="group.proposal.metaInfo"/>
				<dict:fieldRef bean="group.proposal.type"/>
				<dict:fieldRef bean="group.proposal.state"/>
				<dict:fieldRef bean="group.proposal.internal.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key="org.kuali.student.core.proposal.dto.ProposalDocRelationInfo">
		<!-- Information about the proposal to document relation. -->
		<dict:type key="kuali.proposal.ProposalDocRelationType.syllabus">
		<!-- a syllabus for the clu being proposed -->
			<dict:state key="Active">
			<!-- proposal Doc Relation is Active -->
			<!-- TODO: Add to simple spec -->
				
				<dict:field id="syllabus.proposalId" key="proposalId">
					<dict:fieldDescriptor>
						<dict:name>syllabus proposalId</dict:name>
						<dict:desc>syllabus proposalId</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.related.proposal"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="syllabus.documentId" key="documentId">
					<dict:fieldDescriptor>
						<dict:name>syllabus documentId</dict:name>
						<dict:desc>syllabus documentId</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.related.document"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="syllabus.title" key="title">
					<dict:fieldDescriptor>
						<dict:name>syllabus title</dict:name>
						<dict:desc>syllabus title</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.single.line.text"/>
							<dict:constraint key="in-line.constraint.for.dictionary.syllabus.title" id="constraint.">
								<dict:minLength>1</dict:minLength>
								<dict:maxLength>100</dict:maxLength>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="syllabus.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>syllabus desc</dict:name>
						<dict:desc>syllabus desc</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="syllabus.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>syllabus desc plain text</dict:name>
												<dict:desc>syllabus desc plain text</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.multi.line.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain" id="constraint.">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.syllabus.desc.plain" id="constraint.">
														<dict:minLength>0</dict:minLength>
														<dict:maxLength>200</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="syllabus.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>syllabus desc formatted</dict:name>
												<dict:desc>syllabus desc formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.optional"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.rich.text"/>
													<dict:constraintRef bean="constraint.hidden"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted" id="constraint.">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.syllabus.desc.formatted" id="constraint.">
														<dict:minLength>0</dict:minLength>
														<dict:maxLength>200</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="syllabus.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>syllabus effectiveDate</dict:name>
						<dict:desc>syllabus effectiveDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="syllabus.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>syllabus expirationDate</dict:name>
						<dict:desc>syllabus expirationDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="syllabus.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>syllabus attributes</dict:name>
						<dict:desc>syllabus attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="syllabus.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>syllabus metaInfo</dict:name>
						<dict:desc>syllabus metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="syllabus.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>syllabus meta versionInd</dict:name>
												<dict:desc>Version number for this syllabus</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="syllabus.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>syllabus meta createTime</dict:name>
												<dict:desc>Date-time this syllabus was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="syllabus.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>syllabus meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this syllabus</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="syllabus.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>syllabus meta updateTime</dict:name>
												<dict:desc>Date-time this  syllabus was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="syllabus.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>syllabus meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this  syllabus</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="syllabus.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>syllabus proposalId</dict:name>
						<dict:desc>syllabus proposalId</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.hard.coded.syllabus"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="syllabus.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>syllabus documentId</dict:name>
						<dict:desc>syllabus documentId</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="syllabus.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>syllabus title</dict:name>
						<dict:desc>syllabus title</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.id"/>
							<dict:constraintRef bean="constraint.hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="Inactive">
			<!-- proposal Doc Relation is Inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="syllabus.proposalId"/>
				<dict:fieldRef bean="syllabus.documentId"/>
				<dict:fieldRef bean="syllabus.title"/>
				<dict:fieldRef bean="syllabus.desc"/>
				<dict:fieldRef bean="syllabus.effectiveDate"/>
				<dict:fieldRef bean="syllabus.expirationDate"/>
				<dict:fieldRef bean="syllabus.attributes"/>
				<dict:fieldRef bean="syllabus.metaInfo"/>
				<dict:fieldRef bean="syllabus.type"/>
				<dict:fieldRef bean="syllabus.state"/>
				<dict:fieldRef bean="syllabus.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.proposal.ProposalDocRelationType.other">
		<!-- supporting documentation does not fit into another category -->
			<dict:state key="Active">
			<!-- proposal Doc Relation is Active -->
			<!-- TODO: Add to simple spec -->
				
				<dict:field id="other.attachment.proposalId" key="proposalId">
					<dict:fieldDescriptor>
						<dict:name>other proposalId</dict:name>
						<dict:desc>other proposalId</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.related.proposal"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="other.attachment.documentId" key="documentId">
					<dict:fieldDescriptor>
						<dict:name>other documentId</dict:name>
						<dict:desc>other documentId</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.related.document"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="other.attachment.title" key="title">
					<dict:fieldDescriptor>
						<dict:name>other title</dict:name>
						<dict:desc>other title</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.single.line.text"/>
							<dict:constraint key="in-line.constraint.for.dictionary.other.attachment.title" id="constraint.">
								<dict:minLength>1</dict:minLength>
								<dict:maxLength>100</dict:maxLength>
								</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="other.attachment.desc" key="desc">
					<dict:fieldDescriptor>
						<dict:name>other desc</dict:name>
						<dict:desc>other desc</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="other.attachment.desc.plain" key="plain">
											<dict:fieldDescriptor>
												<dict:name>other desc plain text</dict:name>
												<dict:desc>other desc plain text</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.multi.line.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain" id="constraint.">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.other.attachment.desc.plain" id="constraint.">
														<dict:minLength>0</dict:minLength>
														<dict:maxLength>200</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="other.attachment.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>other desc formatted</dict:name>
												<dict:desc>other desc formatted</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.optional"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.rich.text"/>
													<dict:constraintRef bean="constraint.hidden"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted" id="constraint.">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.other.attachment.desc.formatted" id="constraint.">
														<dict:minLength>0</dict:minLength>
														<dict:maxLength>200</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="other.attachment.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>other effectiveDate</dict:name>
						<dict:desc>other effectiveDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="other.attachment.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>other expirationDate</dict:name>
						<dict:desc>other expirationDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="other.attachment.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>other attributes</dict:name>
						<dict:desc>other attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.repeating"/>
							<dict:constraintRef bean="constraint.not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="other.attachment.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>other metaInfo</dict:name>
						<dict:desc>other metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="other.attachment.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>other meta versionInd</dict:name>
												<dict:desc>Version number for this other</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="other.attachment.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>other meta createTime</dict:name>
												<dict:desc>Date-time this other was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="other.attachment.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>other meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this other</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="other.attachment.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>other meta updateTime</dict:name>
												<dict:desc>Date-time this  other was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.required"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.date.time"/>
													<dict:constraintRef bean="constraint.calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="other.attachment.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>other meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this  other</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="constraint.read.only"/>
													<dict:constraintRef bean="constraint.single"/>
													<dict:constraintRef bean="constraint.related.principalId"/>
													<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="other.attachment.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>other proposalId</dict:name>
						<dict:desc>other proposalId</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.hard.coded.other.document"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="other.attachment.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>other documentId</dict:name>
						<dict:desc>other documentId</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.required"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="other.attachment.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>other title</dict:name>
						<dict:desc>other title</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="constraint.optional"/>
							<dict:constraintRef bean="constraint.single"/>
							<dict:constraintRef bean="constraint.kuali.id"/>
							<dict:constraintRef bean="constraint.hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="Inactive">
			<!-- proposal Doc Relation is Inactive -->
			<!-- TODO: Add to simple spec -->
				<dict:fieldRef bean="other.attachment.proposalId"/>
				<dict:fieldRef bean="other.attachment.documentId"/>
				<dict:fieldRef bean="other.attachment.title"/>
				<dict:fieldRef bean="other.attachment.desc"/>
				<dict:fieldRef bean="other.attachment.effectiveDate"/>
				<dict:fieldRef bean="other.attachment.expirationDate"/>
				<dict:fieldRef bean="other.attachment.attributes"/>
				<dict:fieldRef bean="other.attachment.metaInfo"/>
				<dict:fieldRef bean="other.attachment.type"/>
				<dict:fieldRef bean="other.attachment.state"/>
				<dict:fieldRef bean="other.attachment.internal.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
</beans>
