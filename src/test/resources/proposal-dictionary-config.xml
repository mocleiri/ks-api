<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:dict="http://student.kuali.org/xsd/dictionary-extension"
xsi:schemaLocation="
http://student.kuali.org/xsd/dictionary-extension dictionary-extension.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
">
<!-- *** Automatically Generated ***
on: Fri Feb 05 10:08:21 EST 2010
by: org.kuali.student.dictionary.writer.DictionaryModelWriter
Using:Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls   and: Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls
 -->
<import resource="constraints-dictionary-config.xml"/>

<!-- Detailed information about a proposal. -->
<dict:objectStructure key="org.kuali.student.core.proposal.dto.ProposalInfo" id="object.proposalInfo.abstract" abstract="true">
	<dict:typeRef bean="object.proposalInfo.type"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.proposal.dto.ProposalInfo" id="object.proposalInfo" parent="object.proposalInfo.abstract"/>

<dict:type key="(default)" id="object.proposalInfo.type.abstract" abstract="true">
	<dict:stateRef bean="object.proposalInfo.state"/>
</dict:type>
<dict:type key="(default)" id="object.proposalInfo.type" parent="object.proposalInfo.type.abstract"/>
<dict:type key="kuali.proposal.type.course.*" id="object.proposalInfo.type.kuali.proposal.type.course._" parent="object.proposalInfo.type.abstract">
	<dict:name>All Course Proposal Types</dict:name>
	<dict:desc>All course proposal types</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.proposal.type.course.create" id="object.proposalInfo.type.kuali.proposal.type.course.create" parent="object.proposalInfo.type.abstract">
	<dict:name>Create Credit Course</dict:name>
	<dict:desc>Proposal to create a new Credit Course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.proposal.type.course.modify" id="object.proposalInfo.type.kuali.proposal.type.course.modify" parent="object.proposalInfo.type.abstract">
	<dict:name>Modify Credit Course</dict:name>
	<dict:desc>Proposal to modify an existing Credit Course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.proposal.type.course.minorModification" id="object.proposalInfo.type.kuali.proposal.type.course.minorModification" parent="object.proposalInfo.type.abstract">
	<dict:name>Minor Modificationto a Credit Course</dict:name>
	<dict:desc>Proposal to make a small change to an existing Credit Course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.proposal.type.course.retire" id="object.proposalInfo.type.kuali.proposal.type.course.retire" parent="object.proposalInfo.type.abstract">
	<dict:name>Retire a Credit Course</dict:name>
	<dict:desc>Proposal to retire an existing Credit Course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.proposal.type.course.reinstate" id="object.proposalInfo.type.kuali.proposal.type.course.reinstate" parent="object.proposalInfo.type.abstract">
	<dict:name>Reinatate a Credit Course</dict:name>
	<dict:desc>Proposal to bring an existing Credit Course out of retirement</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.proposal.type.program.*" id="object.proposalInfo.type.kuali.proposal.type.program._" parent="object.proposalInfo.type.abstract">
	<dict:name>All Program Proposal Types</dict:name>
	<dict:desc>All program proposal types</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.proposal.type.program.create" id="object.proposalInfo.type.kuali.proposal.type.program.create" parent="object.proposalInfo.type.abstract">
	<dict:name>Create Program</dict:name>
	<dict:desc>Proposal to create a new Program</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.proposal.type.group" id="object.proposalInfo.type.kuali.proposal.type.group" parent="object.proposalInfo.type.abstract">
	<dict:name>Grouped</dict:name>
	<dict:desc>A  group of proposals</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>

<dict:state key="(default)" id="object.proposalInfo.state.abstract" abstract="true">
	<dict:fieldRef bean="field.proposalInfo.name"/>
	<dict:fieldRef bean="field.proposalInfo.proposerPerson"/>
	<dict:fieldRef bean="field.proposalInfo.proposerOrg"/>
	<dict:fieldRef bean="field.proposalInfo.proposalReferenceType"/>
	<dict:fieldRef bean="field.proposalInfo.proposalReference"/>
	<dict:fieldRef bean="field.proposalInfo.rationale"/>
	<dict:fieldRef bean="field.proposalInfo.detailDesc"/>
	<dict:fieldRef bean="field.proposalInfo.effectiveDate"/>
	<dict:fieldRef bean="field.proposalInfo.expirationDate"/>
	<dict:fieldRef bean="field.proposalInfo.attributes"/>
	<dict:fieldRef bean="field.proposalInfo.metaInfo"/>
	<dict:fieldRef bean="field.proposalInfo.type"/>
	<dict:fieldRef bean="field.proposalInfo.state"/>
	<dict:fieldRef bean="field.proposalInfo.id"/>
</dict:state>
<dict:state key="(default)" id="object.proposalInfo.state" parent="object.proposalInfo.state.abstract"/>
<dict:state key="draft.private" id="object.proposalInfo.state.draft.private.abstract" abstract="true" parent="object.proposalInfo.state.abstract"/>
<dict:state key="draft.public" id="object.proposalInfo.state.draft.public.abstract" abstract="true" parent="object.proposalInfo.state.abstract"/>
<dict:state key="submitted" id="object.proposalInfo.state.submitted.abstract" abstract="true" parent="object.proposalInfo.state.abstract"/>
<dict:state key="approved" id="object.proposalInfo.state.approved.abstract" abstract="true" parent="object.proposalInfo.state.abstract"/>
<dict:state key="rejected" id="object.proposalInfo.state.rejected.abstract" abstract="true" parent="object.proposalInfo.state.abstract"/>
<dict:state key="withdrawn" id="object.proposalInfo.state.withdrawn.abstract" abstract="true" parent="object.proposalInfo.state.abstract"/>
<dict:state key="retired" id="object.proposalInfo.state.retired.abstract" abstract="true" parent="object.proposalInfo.state.abstract"/>
<dict:state key="inactive" id="object.proposalInfo.state.inactive.abstract" abstract="true" parent="object.proposalInfo.state.abstract"/>

<dict:field key="name" id="field.proposalInfo.name.abstract" abstract="true">
	<dict:fieldDescriptor key="name" id="field.proposalInfo.name.fd.abstract" abstract="true"	/>
		<dict:name>Proposal Name</dict:name>
		<dict:desc>The name or title of the proposal. Any finite sequence of characters with letters, numerals, symbols and punctuation marks. The length can be any natural number between zero or any positive integer.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="name" id="field.proposalInfo.name.fd" parent="field.proposalInfo.name.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="name" id="field.proposalInfo.name" parent="field.proposalInfo.name.abstract">
</dict:field>

<dict:field key="proposerPerson" id="field.proposalInfo.proposerPerson.abstract" abstract="true">
	<dict:fieldDescriptor key="proposerPerson" id="field.proposalInfo.proposerPerson.fd.abstract" abstract="true"	/>
		<dict:name>Proposer Person</dict:name>
		<dict:desc>List of person identifiers. Structure should contain a proposerPerson OR a proposerOrg.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="proposerPerson" id="field.proposalInfo.proposerPerson.fd" parent="field.proposalInfo.proposerPerson.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.repeating"/>
			<dict:constraintRef bean="constraint.related.personId"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="proposerPerson" id="field.proposalInfo.proposerPerson" parent="field.proposalInfo.proposerPerson.abstract">
</dict:field>

<dict:field key="proposerOrg" id="field.proposalInfo.proposerOrg.abstract" abstract="true">
	<dict:fieldDescriptor key="proposerOrg" id="field.proposalInfo.proposerOrg.fd.abstract" abstract="true"	/>
		<dict:name>Proposer Organization</dict:name>
		<dict:desc>List of organization identifiers. Structure should contain a proposerPerson OR a proposerOrg</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="proposerOrg" id="field.proposalInfo.proposerOrg.fd" parent="field.proposalInfo.proposerOrg.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.repeating"/>
			<dict:constraintRef bean="constraint.related.orgId"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="proposerOrg" id="field.proposalInfo.proposerOrg" parent="field.proposalInfo.proposerOrg.abstract">
</dict:field>

<dict:field key="proposalReferenceType" id="field.proposalInfo.proposalReferenceType.abstract" abstract="true">
	<dict:fieldDescriptor key="proposalReferenceType" id="field.proposalInfo.proposalReferenceType.fd.abstract" abstract="true"	/>
		<dict:name>Proposal Reference Type</dict:name>
		<dict:desc>Unique identifier for a reference type.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="proposalReferenceType" id="field.proposalInfo.proposalReferenceType.fd" parent="field.proposalInfo.proposalReferenceType.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.reference.types"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="proposalReferenceType" id="field.proposalInfo.proposalReferenceType" parent="field.proposalInfo.proposalReferenceType.abstract">
</dict:field>

<dict:field key="proposalReference" id="field.proposalInfo.proposalReference.abstract" abstract="true">
	<dict:fieldDescriptor key="proposalReference" id="field.proposalInfo.proposalReference.fd.abstract" abstract="true"	/>
		<dict:name>Proposal Reference</dict:name>
		<dict:desc>List of reference identifiers.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="proposalReference" id="field.proposalInfo.proposalReference.fd" parent="field.proposalInfo.proposalReference.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.repeating"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="proposalReference" id="field.proposalInfo.proposalReference" parent="field.proposalInfo.proposalReference.abstract">
</dict:field>

<!-- Made this optional even though the service says its requried -->
<!-- Made this optional even though the service says its requried -->
<dict:field key="rationale" id="field.proposalInfo.rationale.abstract" abstract="true">
	<dict:fieldDescriptor key="rationale" id="field.proposalInfo.rationale.fd.abstract" abstract="true"	/>
		<dict:name>Rationale</dict:name>
		<dict:desc>Brief explanation of the reason for the proposal</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="rationale" id="field.proposalInfo.rationale.fd" parent="field.proposalInfo.rationale.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.multi.line.text"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="rationale" id="field.proposalInfo.rationale" parent="field.proposalInfo.rationale.abstract">
</dict:field>

<!-- Made this optional even though the service says its requried -->
<!-- Made this optional even though the service says its requried -->
<dict:field key="detailDesc" id="field.proposalInfo.detailDesc.abstract" abstract="true">
	<dict:fieldDescriptor key="detailDesc" id="field.proposalInfo.detailDesc.fd.abstract" abstract="true"	/>
		<dict:name>Detailed Description</dict:name>
		<dict:desc>Detailed description of the proposed changes.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="detailDesc" id="field.proposalInfo.detailDesc.fd" parent="field.proposalInfo.detailDesc.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.multi.line.text"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="detailDesc" id="field.proposalInfo.detailDesc" parent="field.proposalInfo.detailDesc.abstract">
</dict:field>

<dict:field key="effectiveDate" id="field.proposalInfo.effectiveDate.abstract" abstract="true">
	<dict:fieldDescriptor key="effectiveDate" id="field.proposalInfo.effectiveDate.fd.abstract" abstract="true"	/>
		<dict:name>Effective Date</dict:name>
		<dict:desc>Date and time that this proposal became effective. This is a similar concept to the effective date on enumerated values. When an expiration date has been specified, this field must be less than or equal to the expiration date.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="effectiveDate" id="field.proposalInfo.effectiveDate.fd" parent="field.proposalInfo.effectiveDate.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="effectiveDate" id="field.proposalInfo.effectiveDate" parent="field.proposalInfo.effectiveDate.abstract">
</dict:field>

<dict:field key="expirationDate" id="field.proposalInfo.expirationDate.abstract" abstract="true">
	<dict:fieldDescriptor key="expirationDate" id="field.proposalInfo.expirationDate.fd.abstract" abstract="true"	/>
		<dict:name>Expiration Date</dict:name>
		<dict:desc>Date and time that this proposal expires. This is a similar concept to the expiration date on enumerated values. If specified, this should be greater than or equal to the effective date. If this field is not specified, then no expiration date has been currently defined and should automatically be considered greater than the effective date.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="expirationDate" id="field.proposalInfo.expirationDate.fd" parent="field.proposalInfo.expirationDate.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="expirationDate" id="field.proposalInfo.expirationDate" parent="field.proposalInfo.expirationDate.abstract">
</dict:field>

<dict:field key="attributes" id="field.proposalInfo.attributes.abstract" abstract="true">
	<dict:fieldDescriptor key="attributes" id="field.proposalInfo.attributes.fd.abstract" abstract="true"	/>
		<dict:name>Generic/dynamic attributes</dict:name>
		<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="attributes" id="field.proposalInfo.attributes.fd" parent="field.proposalInfo.attributes.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.repeating"/>
	</dict:constraintDescriptor>
	<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="attributes" id="field.proposalInfo.attributes" parent="field.proposalInfo.attributes.abstract">
</dict:field>

<dict:field key="metaInfo" id="field.proposalInfo.metaInfo.abstract" abstract="true">
	<dict:fieldDescriptor key="metaInfo" id="field.proposalInfo.metaInfo.fd.abstract" abstract="true"	/>
		<dict:name>Create/Update meta info</dict:name>
		<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="metaInfo" id="field.proposalInfo.metaInfo.fd" parent="field.proposalInfo.metaInfo.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.meta.data"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="metaInfo" id="field.proposalInfo.metaInfo" parent="field.proposalInfo.metaInfo.abstract">
</dict:field>

<dict:field key="type" id="field.proposalInfo.type.abstract" abstract="true">
	<dict:fieldDescriptor key="type" id="field.proposalInfo.type.fd.abstract" abstract="true"	/>
		<dict:name>Proposal Type</dict:name>
		<dict:desc>Unique identifier for a proposal type.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="type" id="field.proposalInfo.type.fd" parent="field.proposalInfo.type.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.proposal.types"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="type" id="field.proposalInfo.type" parent="field.proposalInfo.type.abstract">
</dict:field>

<dict:field key="state" id="field.proposalInfo.state.abstract" abstract="true">
	<dict:fieldDescriptor key="state" id="field.proposalInfo.state.fd.abstract" abstract="true"	/>
		<dict:name>Proposal State</dict:name>
		<dict:desc>The current status of the proposal. The values for this field are constrained to those in the proposalState enumeration. A separate setup operation does not exist for retrieval of the meta data around this value.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="state" id="field.proposalInfo.state.fd" parent="field.proposalInfo.state.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.state"/>
	</dict:constraintDescriptor>
	<dict:selector>true</dict:selector>
</dict:field>
<dict:field key="state" id="field.proposalInfo.state" parent="field.proposalInfo.state.abstract">
</dict:field>

<dict:field key="id" id="field.proposalInfo.id.abstract" abstract="true">
	<dict:fieldDescriptor key="id" id="field.proposalInfo.id.fd.abstract" abstract="true"	/>
		<dict:name>Proposal Identifier</dict:name>
		<dict:desc>Unique identifier for a Proposal. This is optional, due to the identifier being set at the time of creation. Once the proposal has been created, this should be seen as required.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="id" id="field.proposalInfo.id.fd" parent="field.proposalInfo.id.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.id"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="id" id="field.proposalInfo.id" parent="field.proposalInfo.id.abstract">
</dict:field>

<!-- Information about the proposal to document relation. -->
<dict:objectStructure key="org.kuali.student.core.proposal.dto.ProposalDocRelationInfo" id="object.proposalDocRelationInfo.abstract" abstract="true">
	<dict:typeRef bean="object.proposalDocRelationInfo.type"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.proposal.dto.ProposalDocRelationInfo" id="object.proposalDocRelationInfo" parent="object.proposalDocRelationInfo.abstract"/>

<dict:type key="(default)" id="object.proposalDocRelationInfo.type.abstract" abstract="true">
	<dict:stateRef bean="object.proposalDocRelationInfo.state"/>
</dict:type>
<dict:type key="(default)" id="object.proposalDocRelationInfo.type" parent="object.proposalDocRelationInfo.type.abstract"/>
<dict:type key="kuali.proposal.ProposalDocRelationType.syllabus" id="object.proposalDocRelationInfo.type.kuali.proposal.ProposalDocRelationType.syllabus" parent="object.proposalDocRelationInfo.type.abstract">
	<dict:name>Syllabus</dict:name>
	<dict:desc>a syllabus for the clu being proposed</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.proposal.ProposalDocRelationType.other" id="object.proposalDocRelationInfo.type.kuali.proposal.ProposalDocRelationType.other" parent="object.proposalDocRelationInfo.type.abstract">
	<dict:name>Other</dict:name>
	<dict:desc>supporting documentation does not fit into another category</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.proposal.ProposalDocRelationType.analysis" id="object.proposalDocRelationInfo.type.kuali.proposal.ProposalDocRelationType.analysis" parent="object.proposalDocRelationInfo.type.abstract">
	<dict:name>Analysis</dict:name>
	<dict:desc>various types of analysis to support the proposal</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>

<dict:state key="(default)" id="object.proposalDocRelationInfo.state.abstract" abstract="true">
	<dict:fieldRef bean="field.proposalDocRelationInfo.proposalId"/>
	<dict:fieldRef bean="field.proposalDocRelationInfo.documentId"/>
	<dict:fieldRef bean="field.proposalDocRelationInfo.title"/>
	<dict:fieldRef bean="field.proposalDocRelationInfo.desc"/>
	<dict:fieldRef bean="field.proposalDocRelationInfo.effectiveDate"/>
	<dict:fieldRef bean="field.proposalDocRelationInfo.expirationDate"/>
	<dict:fieldRef bean="field.proposalDocRelationInfo.attributes"/>
	<dict:fieldRef bean="field.proposalDocRelationInfo.metaInfo"/>
	<dict:fieldRef bean="field.proposalDocRelationInfo.type"/>
	<dict:fieldRef bean="field.proposalDocRelationInfo.state"/>
	<dict:fieldRef bean="field.proposalDocRelationInfo.id"/>
</dict:state>
<dict:state key="(default)" id="object.proposalDocRelationInfo.state" parent="object.proposalDocRelationInfo.state.abstract"/>
<dict:state key="Active" id="object.proposalDocRelationInfo.state.Active.abstract" abstract="true" parent="object.proposalDocRelationInfo.state.abstract"/>
<dict:state key="Inactive" id="object.proposalDocRelationInfo.state.Inactive.abstract" abstract="true" parent="object.proposalDocRelationInfo.state.abstract"/>

<dict:field key="proposalId" id="field.proposalDocRelationInfo.proposalId.abstract" abstract="true">
	<dict:fieldDescriptor key="proposalId" id="field.proposalDocRelationInfo.proposalId.fd.abstract" abstract="true"	/>
		<dict:name>Proposal Identifier</dict:name>
		<dict:desc>Unique identifier for a Proposal.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="proposalId" id="field.proposalDocRelationInfo.proposalId.fd" parent="field.proposalDocRelationInfo.proposalId.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.related.proposal"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="proposalId" id="field.proposalDocRelationInfo.proposalId" parent="field.proposalDocRelationInfo.proposalId.abstract">
</dict:field>

<dict:field key="documentId" id="field.proposalDocRelationInfo.documentId.abstract" abstract="true">
	<dict:fieldDescriptor key="documentId" id="field.proposalDocRelationInfo.documentId.fd.abstract" abstract="true"	/>
		<dict:name>Document Identifier</dict:name>
		<dict:desc>Unique identifier for a document.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="documentId" id="field.proposalDocRelationInfo.documentId.fd" parent="field.proposalDocRelationInfo.documentId.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.related.document"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="documentId" id="field.proposalDocRelationInfo.documentId" parent="field.proposalDocRelationInfo.documentId.abstract">
</dict:field>

<dict:field key="title" id="field.proposalDocRelationInfo.title.abstract" abstract="true">
	<dict:fieldDescriptor key="title" id="field.proposalDocRelationInfo.title.fd.abstract" abstract="true"	/>
		<dict:name>Document Title</dict:name>
		<dict:desc>The title of the document usage in the context of the Proposal.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="title" id="field.proposalDocRelationInfo.title.fd" parent="field.proposalDocRelationInfo.title.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="title" id="field.proposalDocRelationInfo.title" parent="field.proposalDocRelationInfo.title.abstract">
</dict:field>

<dict:field key="desc" id="field.proposalDocRelationInfo.desc.abstract" abstract="true">
	<dict:fieldDescriptor key="desc" id="field.proposalDocRelationInfo.desc.fd.abstract" abstract="true"	/>
		<dict:name>Document Description</dict:name>
		<dict:desc>The description of the document usage in the context of the Proposal.</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="desc" id="field.proposalDocRelationInfo.desc.fd" parent="field.proposalDocRelationInfo.desc.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="desc" id="field.proposalDocRelationInfo.desc" parent="field.proposalDocRelationInfo.desc.abstract">
</dict:field>

<dict:field key="effectiveDate" id="field.proposalDocRelationInfo.effectiveDate.abstract" abstract="true">
	<dict:fieldDescriptor key="effectiveDate" id="field.proposalDocRelationInfo.effectiveDate.fd.abstract" abstract="true"	/>
		<dict:name>Effective Date</dict:name>
		<dict:desc>Date and time that this Proposal Doc Relation became effective. This is a similar concept to the effective date on enumerated values. When an expiration date has been specified, this field must be less than or equal to the expiration date.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="effectiveDate" id="field.proposalDocRelationInfo.effectiveDate.fd" parent="field.proposalDocRelationInfo.effectiveDate.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="effectiveDate" id="field.proposalDocRelationInfo.effectiveDate" parent="field.proposalDocRelationInfo.effectiveDate.abstract">
</dict:field>

<dict:field key="expirationDate" id="field.proposalDocRelationInfo.expirationDate.abstract" abstract="true">
	<dict:fieldDescriptor key="expirationDate" id="field.proposalDocRelationInfo.expirationDate.fd.abstract" abstract="true"	/>
		<dict:name>Expiration Date</dict:name>
		<dict:desc>Date and time that this Proposal Doc Relation expires. This is a similar concept to the expiration date on enumerated values. If specified, this should be greater than or equal to the effective date. If this field is not specified, then no expiration date has been currently defined and should automatically be considered greater than the effective date.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="expirationDate" id="field.proposalDocRelationInfo.expirationDate.fd" parent="field.proposalDocRelationInfo.expirationDate.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="expirationDate" id="field.proposalDocRelationInfo.expirationDate" parent="field.proposalDocRelationInfo.expirationDate.abstract">
</dict:field>

<dict:field key="attributes" id="field.proposalDocRelationInfo.attributes.abstract" abstract="true">
	<dict:fieldDescriptor key="attributes" id="field.proposalDocRelationInfo.attributes.fd.abstract" abstract="true"	/>
		<dict:name>Generic/dynamic attributes</dict:name>
		<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="attributes" id="field.proposalDocRelationInfo.attributes.fd" parent="field.proposalDocRelationInfo.attributes.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.repeating"/>
	</dict:constraintDescriptor>
	<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="attributes" id="field.proposalDocRelationInfo.attributes" parent="field.proposalDocRelationInfo.attributes.abstract">
</dict:field>

<dict:field key="metaInfo" id="field.proposalDocRelationInfo.metaInfo.abstract" abstract="true">
	<dict:fieldDescriptor key="metaInfo" id="field.proposalDocRelationInfo.metaInfo.fd.abstract" abstract="true"	/>
		<dict:name>Create/Update meta info</dict:name>
		<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="metaInfo" id="field.proposalDocRelationInfo.metaInfo.fd" parent="field.proposalDocRelationInfo.metaInfo.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.meta.data"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="metaInfo" id="field.proposalDocRelationInfo.metaInfo" parent="field.proposalDocRelationInfo.metaInfo.abstract">
</dict:field>

<dict:field key="type" id="field.proposalDocRelationInfo.type.abstract" abstract="true">
	<dict:fieldDescriptor key="type" id="field.proposalDocRelationInfo.type.fd.abstract" abstract="true"	/>
		<dict:name>Proposal Document Relation Type Key</dict:name>
		<dict:desc>Unique identifier for a proposal document relation type. Describes the type of usage of the document.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="type" id="field.proposalDocRelationInfo.type.fd" parent="field.proposalDocRelationInfo.type.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="type" id="field.proposalDocRelationInfo.type" parent="field.proposalDocRelationInfo.type.abstract">
</dict:field>

<dict:field key="state" id="field.proposalDocRelationInfo.state.abstract" abstract="true">
	<dict:fieldDescriptor key="state" id="field.proposalDocRelationInfo.state.fd.abstract" abstract="true"	/>
		<dict:name>Proposal Document Relation State Key</dict:name>
		<dict:desc>The current status of the Proposal to document relationship. The values for this field are constrained to those in the proposalDocRelationState enumeration. A separate setup operation does not exist for retrieval of the meta data around this value.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="state" id="field.proposalDocRelationInfo.state.fd" parent="field.proposalDocRelationInfo.state.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.state"/>
	</dict:constraintDescriptor>
	<dict:selector>true</dict:selector>
</dict:field>
<dict:field key="state" id="field.proposalDocRelationInfo.state" parent="field.proposalDocRelationInfo.state.abstract">
</dict:field>

<dict:field key="id" id="field.proposalDocRelationInfo.id.abstract" abstract="true">
	<dict:fieldDescriptor key="id" id="field.proposalDocRelationInfo.id.fd.abstract" abstract="true"	/>
		<dict:name>Proposal Document Relation Identifier</dict:name>
		<dict:desc>Unique identifier for a proposal to document relation. This is optional, due to the identifier being set at the time of creation. Once the connection has been created, this should be seen as required.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="id" id="field.proposalDocRelationInfo.id.fd" parent="field.proposalDocRelationInfo.id.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.id"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="id" id="field.proposalDocRelationInfo.id" parent="field.proposalDocRelationInfo.id.abstract">
</dict:field>

<!-- List of key/value pairs, typically used for dynamic attributes. -->
<dict:objectStructure key=".AttributeInfo" id="object.attributeInfo.abstract" abstract="true">
	<dict:typeRef bean="object.attributeInfo.type"/>
</dict:objectStructure>
<dict:objectStructure key=".AttributeInfo" id="object.attributeInfo" parent="object.attributeInfo.abstract"/>

<dict:type key="(default)" id="object.attributeInfo.type.abstract" abstract="true">
	<dict:stateRef bean="object.attributeInfo.state"/>
</dict:type>
<dict:type key="(default)" id="object.attributeInfo.type" parent="object.attributeInfo.type.abstract"/>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color" id="object.attributeInfo.type.kuali.lu.type.CreditCourse.dynamic.eye.color" parent="object.attributeInfo.type.abstract">
	<dict:name>Eye Color</dict:name>
	<dict:desc>Captures the eye color of students expected to take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed" id="object.attributeInfo.type.kuali.lu.type.CreditCourse.dynamic.left.handed" parent="object.attributeInfo.type.abstract">
	<dict:name>Left Handed</dict:name>
	<dict:desc>Captures if the students are expected to be left handed who take this course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>
<dict:type key="kuali.lo.type.SingleUse.dynamic.sequence" id="object.attributeInfo.type.kuali.lo.type.SingleUse.dynamic.sequence" parent="object.attributeInfo.type.abstract">
	<dict:name>Sequence</dict:name>
	<dict:desc>Captures the sequence of an LO within a Credit Course</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>

<dict:state key="(default)" id="object.attributeInfo.state.abstract" abstract="true">
	<dict:fieldRef bean="field.attributeInfo.value"/>
	<dict:fieldRef bean="field.attributeInfo.key"/>
</dict:state>
<dict:state key="(default)" id="object.attributeInfo.state" parent="object.attributeInfo.state.abstract"/>
<dict:state key="(n/a)" id="object.attributeInfo.state.NA.abstract" abstract="true" parent="object.attributeInfo.state.abstract"/>

<dict:field key="value" id="field.attributeInfo.value.abstract" abstract="true">
	<dict:fieldDescriptor key="value" id="field.attributeInfo.value.fd.abstract" abstract="true"	/>
		<dict:name>Attribute Value</dict:name>
		<dict:desc>The value for this dynamic attribute.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="value" id="field.attributeInfo.value.fd" parent="field.attributeInfo.value.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
				<dict:maxLength>(unbounded)</dict:maxLength>
				</dict:constraint>
			<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
				<dict:maxLength>(unbounded)</dict:maxLength>
				</dict:constraint>
	</dict:constraintDescriptor>
	<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.attributeInfo.value" parent="field.attributeInfo.value.abstract">
</dict:field>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.attributeInfo.key.abstract" abstract="true">
	<dict:fieldDescriptor key="key" id="field.attributeInfo.key.fd.abstract" abstract="true"	/>
		<dict:name>Attribute Type Identifier</dict:name>
		<dict:desc>The identifier for this attribute.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="key" id="field.attributeInfo.key.fd" parent="field.attributeInfo.key.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.type"/>
			<dict:constraintRef bean="constraint.dynamic.field.types"/>
	</dict:constraintDescriptor>
	<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.attributeInfo.key" parent="field.attributeInfo.key.abstract">
</dict:field>

<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="object.metaInfo.abstract" abstract="true">
	<dict:typeRef bean="object.metaInfo.type"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="object.metaInfo" parent="object.metaInfo.abstract"/>

<dict:type key="(default)" id="object.metaInfo.type.abstract" abstract="true">
	<dict:stateRef bean="object.metaInfo.state"/>
</dict:type>
<dict:type key="(default)" id="object.metaInfo.type" parent="object.metaInfo.type.abstract"/>
<dict:type key="kuali.not.applicable" id="object.metaInfo.type.kuali.not.applicable" parent="object.metaInfo.type.abstract">
	<dict:name>(n/a)</dict:name>
	<dict:desc>Not applicable</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>

<dict:state key="(default)" id="object.metaInfo.state.abstract" abstract="true">
	<dict:fieldRef bean="field.metaInfo.versionInd"/>
	<dict:fieldRef bean="field.metaInfo.createTime"/>
	<dict:fieldRef bean="field.metaInfo.createId"/>
	<dict:fieldRef bean="field.metaInfo.updateTime"/>
	<dict:fieldRef bean="field.metaInfo.updateId"/>
</dict:state>
<dict:state key="(default)" id="object.metaInfo.state" parent="object.metaInfo.state.abstract"/>
<dict:state key="(n/a)" id="object.metaInfo.state.NA.abstract" abstract="true" parent="object.metaInfo.state.abstract"/>

<dict:field key="versionInd" id="field.metaInfo.versionInd.abstract" abstract="true">
	<dict:fieldDescriptor key="versionInd" id="field.metaInfo.versionInd.fd.abstract" abstract="true"	/>
		<dict:name>Version Indicator</dict:name>
		<dict:desc>An indicator of the version of the thing being described with this meta information. This is set by the service implementation and will be used to determine conflicts in updates.</dict:desc>
		<dict:dataType>string</dict:dataType>
		<dict:readOnly>true</dict:readOnly>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="versionInd" id="field.metaInfo.versionInd.fd" parent="field.metaInfo.versionInd.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
			<dict:constraintRef bean="constraint.read.only"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="versionInd" id="field.metaInfo.versionInd" parent="field.metaInfo.versionInd.abstract">
</dict:field>

<dict:field key="createTime" id="field.metaInfo.createTime.abstract" abstract="true">
	<dict:fieldDescriptor key="createTime" id="field.metaInfo.createTime.fd.abstract" abstract="true"	/>
		<dict:name>Date/Time Created</dict:name>
		<dict:desc>The date and time the thing being described with this meta information was created</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="createTime" id="field.metaInfo.createTime.fd" parent="field.metaInfo.createTime.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
			<dict:constraintRef bean="constraint.default.now"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="createTime" id="field.metaInfo.createTime" parent="field.metaInfo.createTime.abstract">
</dict:field>

<dict:field key="createId" id="field.metaInfo.createId.abstract" abstract="true">
	<dict:fieldDescriptor key="createId" id="field.metaInfo.createId.fd.abstract" abstract="true"	/>
		<dict:name>Created By Identifier</dict:name>
		<dict:desc>The principal who created the thing being described with this meta information</dict:desc>
		<dict:dataType>string</dict:dataType>
		<dict:readOnly>true</dict:readOnly>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="createId" id="field.metaInfo.createId.fd" parent="field.metaInfo.createId.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.read.only"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.related.principalId"/>
			<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="createId" id="field.metaInfo.createId" parent="field.metaInfo.createId.abstract">
</dict:field>

<dict:field key="updateTime" id="field.metaInfo.updateTime.abstract" abstract="true">
	<dict:fieldDescriptor key="updateTime" id="field.metaInfo.updateTime.fd.abstract" abstract="true"	/>
		<dict:name>Date/Time Last Updated</dict:name>
		<dict:desc>The date and time the thing being described with this meta information was last updated. This would be filled in on initial creation as well.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="updateTime" id="field.metaInfo.updateTime.fd" parent="field.metaInfo.updateTime.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
			<dict:constraintRef bean="constraint.calc.now"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="updateTime" id="field.metaInfo.updateTime" parent="field.metaInfo.updateTime.abstract">
</dict:field>

<dict:field key="updateId" id="field.metaInfo.updateId.abstract" abstract="true">
	<dict:fieldDescriptor key="updateId" id="field.metaInfo.updateId.fd.abstract" abstract="true"	/>
		<dict:name>Updated By Identifier</dict:name>
		<dict:desc>The principal who last updated the thing being described with this meta information. This would be filled in on initial creation as well.</dict:desc>
		<dict:dataType>string</dict:dataType>
		<dict:readOnly>true</dict:readOnly>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="updateId" id="field.metaInfo.updateId.fd" parent="field.metaInfo.updateId.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.read.only"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.related.principalId"/>
			<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="updateId" id="field.metaInfo.updateId" parent="field.metaInfo.updateId.abstract">
</dict:field>

<!-- Complex type supporting both a plain text and formatted version of a string. -->
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="object.richTextInfo.abstract" abstract="true">
	<dict:typeRef bean="object.richTextInfo.type"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="object.richTextInfo" parent="object.richTextInfo.abstract"/>

<dict:type key="(default)" id="object.richTextInfo.type.abstract" abstract="true">
	<dict:stateRef bean="object.richTextInfo.state"/>
</dict:type>
<dict:type key="(default)" id="object.richTextInfo.type" parent="object.richTextInfo.type.abstract"/>
<dict:type key="kuali.not.applicable" id="object.richTextInfo.type.kuali.not.applicable" parent="object.richTextInfo.type.abstract">
	<dict:name>(n/a)</dict:name>
	<dict:desc>Not applicable</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
</dict:type>

<dict:state key="(default)" id="object.richTextInfo.state.abstract" abstract="true">
	<dict:fieldRef bean="field.richTextInfo.plain"/>
	<dict:fieldRef bean="field.richTextInfo.formatted"/>
</dict:state>
<dict:state key="(default)" id="object.richTextInfo.state" parent="object.richTextInfo.state.abstract"/>
<dict:state key="(n/a)" id="object.richTextInfo.state.NA.abstract" abstract="true" parent="object.richTextInfo.state.abstract"/>

<dict:field key="plain" id="field.richTextInfo.plain.abstract" abstract="true">
	<dict:fieldDescriptor key="plain" id="field.richTextInfo.plain.fd.abstract" abstract="true"	/>
		<dict:name>Plain Text</dict:name>
		<dict:desc>Plain version of the text. This may be used for searching.</dict:desc>
		<dict:dataType>string</dict:dataType>
		<dict:readOnly>true</dict:readOnly>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="plain" id="field.richTextInfo.plain.fd" parent="field.richTextInfo.plain.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.read.only"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.multi.line.text"/>
			<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
				<dict:maxLength>(unbounded)</dict:maxLength>
				</dict:constraint>
			<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
				<dict:maxLength>(unbounded)</dict:maxLength>
				</dict:constraint>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="plain" id="field.richTextInfo.plain" parent="field.richTextInfo.plain.abstract">
</dict:field>

<dict:field key="formatted" id="field.richTextInfo.formatted.abstract" abstract="true">
	<dict:fieldDescriptor key="formatted" id="field.richTextInfo.formatted.fd.abstract" abstract="true"	/>
		<dict:name>Formatted Text</dict:name>
		<dict:desc>Formatted version of the text.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:fieldDescriptor key="formatted" id="field.richTextInfo.formatted.fd" parent="field.richTextInfo.formatted.fd.abstract"	>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.rich.text"/>
			<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
				<dict:maxLength>(unbounded)</dict:maxLength>
				</dict:constraint>
			<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
				<dict:maxLength>(unbounded)</dict:maxLength>
				</dict:constraint>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="formatted" id="field.richTextInfo.formatted" parent="field.richTextInfo.formatted.abstract">
</dict:field>
</beans>
