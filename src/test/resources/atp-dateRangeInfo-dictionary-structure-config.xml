<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:dict="http://student.kuali.org/xsd/dictionary-extension"
xsi:schemaLocation="
http://student.kuali.org/xsd/dictionary-extension http://student.kuali.org/xsd/dictionary-extension/dictionary-extension.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
">
<!-- *** Automatically Generated ***
by: org.kuali.student.dictionary.writer.dict.DictionaryModelWriter
Using:Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls   and: Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls
 -->

<!-- ***************************************** -->
<!-- object structure for object.dateRangeInfo -->
<!-- ***************************************** -->
<!-- Information about a date range. -->
<dict:objectStructure key="org.kuali.student.core.atp.dto.DateRangeInfo" id="object.dateRangeInfo.abstract" abstract="true">
	<dict:typeRef bean="type.dateRangeInfo"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.atp.dto.DateRangeInfo" id="object.dateRangeInfo" parent="object.dateRangeInfo.abstract"/>

<dict:type key="*" id="type.dateRangeInfo.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="state.dateRangeInfo"/>
</dict:type>
<dict:type key="*" id="type.dateRangeInfo" parent="type.dateRangeInfo.abstract"/>

<!-- ************************************************* -->
<!-- State for state.dateRangeInfo.(default).(default) -->
<!-- ************************************************* -->

<dict:state key="*" id="state.dateRangeInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.daterangeInfo.name"/>
	<dict:fieldRef bean="field.daterangeInfo.desc"/>
	<dict:fieldRef bean="field.daterangeInfo.atpKey"/>
	<dict:fieldRef bean="field.daterangeInfo.startDate"/>
	<dict:fieldRef bean="field.daterangeInfo.endDate"/>
	<dict:fieldRef bean="field.daterangeInfo.metaInfo"/>
	<dict:fieldRef bean="field.daterangeInfo.type"/>
	<dict:fieldRef bean="field.daterangeInfo.state"/>
	<dict:fieldRef bean="field.daterangeInfo.key"/>
</dict:state>
<dict:state key="*" id="state.dateRangeInfo" parent="state.dateRangeInfo.abstract"/>


<dict:field key="name" id="field.daterangeInfo.name.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.daterangeInfo.name.fd"/>
	<dict:constraintDescriptorRef bean="field.daterangeInfo.name.cd"/>
</dict:field>
<dict:field key="name" id="field.daterangeInfo.name" parent="field.daterangeInfo.name.abstract"/>
<dict:fieldDescriptor id="field.daterangeInfo.name.fd.abstract" abstract="true">
	<dict:name>Date Range Name</dict:name>
	<dict:desc>Friendly name of the date range.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.daterangeInfo.name.fd" parent="field.daterangeInfo.name.fd.abstract"/>
<!-- Required; Single valued (non-repeating); A basic single line of text, no embedded carraige returns or tabs limited to 255 -->
<dict:constraintDescriptor id="field.daterangeInfo.name.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.single.line.text"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="name" id="field.daterangeInfo.name.cd" parent="field.daterangeInfo.name.cd.abstract"/>

<dict:field key="desc" id="field.daterangeInfo.desc.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.daterangeInfo.desc.fd"/>
	<dict:constraintDescriptorRef bean="field.daterangeInfo.desc.cd"/>
</dict:field>
<dict:field key="desc" id="field.daterangeInfo.desc" parent="field.daterangeInfo.desc.abstract"/>
<dict:fieldDescriptor id="field.daterangeInfo.desc.fd.abstract" abstract="true">
	<dict:name>Date Range Description</dict:name>
	<dict:desc>Narrative description of the date range.</dict:desc>
	<dict:dataType>Complex</dict:dataType>
		<dict:objectStructureRef bean="object.field.daterangeInfo.desc"/>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.daterangeInfo.desc.fd" parent="field.daterangeInfo.desc.fd.abstract"/>
<!-- Optional; Single valued (non-repeating) -->
<dict:constraintDescriptor id="field.daterangeInfo.desc.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="desc" id="field.daterangeInfo.desc.cd" parent="field.daterangeInfo.desc.cd.abstract"/>

<!-- ************************************************************************ -->
<!-- object structure for object.field.daterangeInfo.desc.(default).(default) -->
<!-- ************************************************************************ -->
<!-- Complex type supporting both a plain text and formatted version of a string. -->
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="object.field.daterangeInfo.desc.abstract" abstract="true">
	<dict:typeRef bean="type.field.daterangeInfo.desc"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="object.field.daterangeInfo.desc" parent="object.field.daterangeInfo.desc.abstract"/>

<dict:type key="*" id="type.field.daterangeInfo.desc.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="state.field.daterangeInfo.desc"/>
</dict:type>
<dict:type key="*" id="type.field.daterangeInfo.desc" parent="type.field.daterangeInfo.desc.abstract"/>

<!-- ******************************************************************************** -->
<!-- State for state.field.daterangeInfo.desc.(default).(default).(default).(default) -->
<!-- ******************************************************************************** -->

<dict:state key="*" id="state.field.daterangeInfo.desc.abstract" abstract="true">
	<dict:fieldRef bean="field.daterangeInfo.desc.plain"/>
	<dict:fieldRef bean="field.daterangeInfo.desc.formatted"/>
</dict:state>
<dict:state key="*" id="state.field.daterangeInfo.desc" parent="state.field.daterangeInfo.desc.abstract"/>


<dict:field key="plain" id="field.daterangeInfo.desc.plain.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.daterangeInfo.desc.plain.fd"/>
	<dict:constraintDescriptorRef bean="field.daterangeInfo.desc.plain.cd"/>
</dict:field>
<dict:field key="plain" id="field.daterangeInfo.desc.plain" parent="field.daterangeInfo.desc.plain.abstract"/>
<dict:fieldDescriptor id="field.daterangeInfo.desc.plain.fd.abstract" abstract="true">
	<dict:name>Plain Text</dict:name>
	<dict:desc>Plain version of the text. This may be used for searching.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.daterangeInfo.desc.plain.fd" parent="field.daterangeInfo.desc.plain.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Multi-line text field that accepts all printable characters plus tab, carraige-return and linefeed. -->
<dict:constraintDescriptor id="field.daterangeInfo.desc.plain.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.multi.line.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="plain" id="field.daterangeInfo.desc.plain.cd" parent="field.daterangeInfo.desc.plain.cd.abstract"/>

<dict:field key="formatted" id="field.daterangeInfo.desc.formatted.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.daterangeInfo.desc.formatted.fd"/>
	<dict:constraintDescriptorRef bean="field.daterangeInfo.desc.formatted.cd"/>
</dict:field>
<dict:field key="formatted" id="field.daterangeInfo.desc.formatted" parent="field.daterangeInfo.desc.formatted.abstract"/>
<dict:fieldDescriptor id="field.daterangeInfo.desc.formatted.fd.abstract" abstract="true">
	<dict:name>Formatted Text</dict:name>
	<dict:desc>Formatted version of the text.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.daterangeInfo.desc.formatted.fd" parent="field.daterangeInfo.desc.formatted.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Text field that accepts all types of characters using some sort of escaping convention along with the ability to specify bolding, font size, color etc. -->
<dict:constraintDescriptor id="field.daterangeInfo.desc.formatted.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.rich.text"/>
	<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
		<dict:maxLength>(unbounded)</dict:maxLength>
		</dict:constraint>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="formatted" id="field.daterangeInfo.desc.formatted.cd" parent="field.daterangeInfo.desc.formatted.cd.abstract"/>

<dict:field key="atpKey" id="field.daterangeInfo.atpKey.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.daterangeInfo.atpKey.fd"/>
	<dict:constraintDescriptorRef bean="field.daterangeInfo.atpKey.cd"/>
</dict:field>
<dict:field key="atpKey" id="field.daterangeInfo.atpKey" parent="field.daterangeInfo.atpKey.abstract"/>
<dict:fieldDescriptor id="field.daterangeInfo.atpKey.fd.abstract" abstract="true">
	<dict:name>Academic Time Period Identifier</dict:name>
	<dict:desc>Unique identifier for an Academic Time Period (ATP).</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.daterangeInfo.atpKey.fd" parent="field.daterangeInfo.atpKey.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali KEY; structured like a type but unique like and ID, used to identify configured objects. -->
<dict:constraintDescriptor id="field.daterangeInfo.atpKey.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.key"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="atpKey" id="field.daterangeInfo.atpKey.cd" parent="field.daterangeInfo.atpKey.cd.abstract"/>

<dict:field key="startDate" id="field.daterangeInfo.startDate.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.daterangeInfo.startDate.fd"/>
	<dict:constraintDescriptorRef bean="field.daterangeInfo.startDate.cd"/>
</dict:field>
<dict:field key="startDate" id="field.daterangeInfo.startDate" parent="field.daterangeInfo.startDate.abstract"/>
<dict:fieldDescriptor id="field.daterangeInfo.startDate.fd.abstract" abstract="true">
	<dict:name>Range Start Date</dict:name>
	<dict:desc>Start date and time for the date range. This must be less than or equal to the end date of this range.</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.daterangeInfo.startDate.fd" parent="field.daterangeInfo.startDate.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Date-Time -->
<dict:constraintDescriptor id="field.daterangeInfo.startDate.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="startDate" id="field.daterangeInfo.startDate.cd" parent="field.daterangeInfo.startDate.cd.abstract"/>

<dict:field key="endDate" id="field.daterangeInfo.endDate.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.daterangeInfo.endDate.fd"/>
	<dict:constraintDescriptorRef bean="field.daterangeInfo.endDate.cd"/>
</dict:field>
<dict:field key="endDate" id="field.daterangeInfo.endDate" parent="field.daterangeInfo.endDate.abstract"/>
<dict:fieldDescriptor id="field.daterangeInfo.endDate.fd.abstract" abstract="true">
	<dict:name>Range End Date</dict:name>
	<dict:desc>End date and time for the date range. This must be greater than or equal to the start date of this range.</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.daterangeInfo.endDate.fd" parent="field.daterangeInfo.endDate.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Date-Time -->
<dict:constraintDescriptor id="field.daterangeInfo.endDate.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="endDate" id="field.daterangeInfo.endDate.cd" parent="field.daterangeInfo.endDate.cd.abstract"/>

<dict:field key="metaInfo" id="field.daterangeInfo.metaInfo.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.daterangeInfo.metaInfo.fd"/>
	<dict:constraintDescriptorRef bean="field.daterangeInfo.metaInfo.cd"/>
</dict:field>
<dict:field key="metaInfo" id="field.daterangeInfo.metaInfo" parent="field.daterangeInfo.metaInfo.abstract"/>
<dict:fieldDescriptor id="field.daterangeInfo.metaInfo.fd.abstract" abstract="true">
	<dict:name>Create/Update meta info</dict:name>
	<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
	<dict:dataType>Complex</dict:dataType>
		<dict:objectStructureRef bean="object.field.daterangeInfo.metaInfo"/>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.daterangeInfo.metaInfo.fd" parent="field.daterangeInfo.metaInfo.fd.abstract"/>
<!-- Optional; Single valued (non-repeating); Kuali Meta Data: calculated by service, read-only; Read Only -->
<dict:constraintDescriptor id="field.daterangeInfo.metaInfo.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.optional"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.meta.data"/>
	<dict:constraintRef bean="constraint.read.only"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="metaInfo" id="field.daterangeInfo.metaInfo.cd" parent="field.daterangeInfo.metaInfo.cd.abstract"/>

<!-- **************************************************************************** -->
<!-- object structure for object.field.daterangeInfo.metaInfo.(default).(default) -->
<!-- **************************************************************************** -->
<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="object.field.daterangeInfo.metaInfo.abstract" abstract="true">
	<dict:typeRef bean="type.field.daterangeInfo.metaInfo"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="object.field.daterangeInfo.metaInfo" parent="object.field.daterangeInfo.metaInfo.abstract"/>

<dict:type key="*" id="type.field.daterangeInfo.metaInfo.abstract" abstract="true">
	<dict:name>(default)</dict:name>
	<dict:desc>Default</dict:desc>
	<dict:effectiveDate>2010-01-01</dict:effectiveDate>
	<dict:stateRef bean="state.field.daterangeInfo.metaInfo"/>
</dict:type>
<dict:type key="*" id="type.field.daterangeInfo.metaInfo" parent="type.field.daterangeInfo.metaInfo.abstract"/>

<!-- ************************************************************************************ -->
<!-- State for state.field.daterangeInfo.metaInfo.(default).(default).(default).(default) -->
<!-- ************************************************************************************ -->

<dict:state key="*" id="state.field.daterangeInfo.metaInfo.abstract" abstract="true">
	<dict:fieldRef bean="field.daterangeInfo.metaInfo.versionInd"/>
	<dict:fieldRef bean="field.daterangeInfo.metaInfo.createTime"/>
	<dict:fieldRef bean="field.daterangeInfo.metaInfo.createId"/>
	<dict:fieldRef bean="field.daterangeInfo.metaInfo.updateTime"/>
	<dict:fieldRef bean="field.daterangeInfo.metaInfo.updateId"/>
</dict:state>
<dict:state key="*" id="state.field.daterangeInfo.metaInfo" parent="state.field.daterangeInfo.metaInfo.abstract"/>


<dict:field key="versionInd" id="field.daterangeInfo.metaInfo.versionInd.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.daterangeInfo.metaInfo.versionInd.fd"/>
	<dict:constraintDescriptorRef bean="field.daterangeInfo.metaInfo.versionInd.cd"/>
</dict:field>
<dict:field key="versionInd" id="field.daterangeInfo.metaInfo.versionInd" parent="field.daterangeInfo.metaInfo.versionInd.abstract"/>
<dict:fieldDescriptor id="field.daterangeInfo.metaInfo.versionInd.fd.abstract" abstract="true">
	<dict:name>Version Indicator</dict:name>
	<dict:desc>An indicator of the version of the thing being described with this meta information. This is set by the service implementation and will be used to determine conflicts in updates.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.daterangeInfo.metaInfo.versionInd.fd" parent="field.daterangeInfo.metaInfo.versionInd.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Calculates the version indicator that is used for optimistic locking; Read Only -->
<dict:constraintDescriptor id="field.daterangeInfo.metaInfo.versionInd.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
	<dict:constraintRef bean="constraint.read.only"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="versionInd" id="field.daterangeInfo.metaInfo.versionInd.cd" parent="field.daterangeInfo.metaInfo.versionInd.cd.abstract"/>

<dict:field key="createTime" id="field.daterangeInfo.metaInfo.createTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.daterangeInfo.metaInfo.createTime.fd"/>
	<dict:constraintDescriptorRef bean="field.daterangeInfo.metaInfo.createTime.cd"/>
</dict:field>
<dict:field key="createTime" id="field.daterangeInfo.metaInfo.createTime" parent="field.daterangeInfo.metaInfo.createTime.abstract"/>
<dict:fieldDescriptor id="field.daterangeInfo.metaInfo.createTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Created</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was created</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.daterangeInfo.metaInfo.createTime.fd" parent="field.daterangeInfo.metaInfo.createTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Defaults to NOW, when the object is created -->
<dict:constraintDescriptor id="field.daterangeInfo.metaInfo.createTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.default.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createTime" id="field.daterangeInfo.metaInfo.createTime.cd" parent="field.daterangeInfo.metaInfo.createTime.cd.abstract"/>

<dict:field key="createId" id="field.daterangeInfo.metaInfo.createId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.daterangeInfo.metaInfo.createId.fd"/>
	<dict:constraintDescriptorRef bean="field.daterangeInfo.metaInfo.createId.cd"/>
</dict:field>
<dict:field key="createId" id="field.daterangeInfo.metaInfo.createId" parent="field.daterangeInfo.metaInfo.createId.abstract"/>
<dict:fieldDescriptor id="field.daterangeInfo.metaInfo.createId.fd.abstract" abstract="true">
	<dict:name>Created By Identifier</dict:name>
	<dict:desc>The principal who created the thing being described with this meta information</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.daterangeInfo.metaInfo.createId.fd" parent="field.daterangeInfo.metaInfo.createId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Defaults to the currently authenticated user -->
<dict:constraintDescriptor id="field.daterangeInfo.metaInfo.createId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="createId" id="field.daterangeInfo.metaInfo.createId.cd" parent="field.daterangeInfo.metaInfo.createId.cd.abstract"/>

<dict:field key="updateTime" id="field.daterangeInfo.metaInfo.updateTime.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.daterangeInfo.metaInfo.updateTime.fd"/>
	<dict:constraintDescriptorRef bean="field.daterangeInfo.metaInfo.updateTime.cd"/>
</dict:field>
<dict:field key="updateTime" id="field.daterangeInfo.metaInfo.updateTime" parent="field.daterangeInfo.metaInfo.updateTime.abstract"/>
<dict:fieldDescriptor id="field.daterangeInfo.metaInfo.updateTime.fd.abstract" abstract="true">
	<dict:name>Date/Time Last Updated</dict:name>
	<dict:desc>The date and time the thing being described with this meta information was last updated. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>dateTime</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.daterangeInfo.metaInfo.updateTime.fd" parent="field.daterangeInfo.metaInfo.updateTime.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Date-Time; Sets a field to the current time -->
<dict:constraintDescriptor id="field.daterangeInfo.metaInfo.updateTime.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.date.time"/>
	<dict:constraintRef bean="constraint.calc.now"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateTime" id="field.daterangeInfo.metaInfo.updateTime.cd" parent="field.daterangeInfo.metaInfo.updateTime.cd.abstract"/>

<dict:field key="updateId" id="field.daterangeInfo.metaInfo.updateId.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.daterangeInfo.metaInfo.updateId.fd"/>
	<dict:constraintDescriptorRef bean="field.daterangeInfo.metaInfo.updateId.cd"/>
</dict:field>
<dict:field key="updateId" id="field.daterangeInfo.metaInfo.updateId" parent="field.daterangeInfo.metaInfo.updateId.abstract"/>
<dict:fieldDescriptor id="field.daterangeInfo.metaInfo.updateId.fd.abstract" abstract="true">
	<dict:name>Updated By Identifier</dict:name>
	<dict:desc>The principal who last updated the thing being described with this meta information. This would be filled in on initial creation as well.</dict:desc>
	<dict:dataType>string</dict:dataType>
	<dict:readOnly>true</dict:readOnly>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.daterangeInfo.metaInfo.updateId.fd" parent="field.daterangeInfo.metaInfo.updateId.fd.abstract"/>
<!-- Read Only; Single valued (non-repeating); Id of an existing PRINCIPAL; Sets a field to the currently authenticated user -->
<dict:constraintDescriptor id="field.daterangeInfo.metaInfo.updateId.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.read.only"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.related.principalId"/>
	<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="updateId" id="field.daterangeInfo.metaInfo.updateId.cd" parent="field.daterangeInfo.metaInfo.updateId.cd.abstract"/>

<dict:field key="type" id="field.daterangeInfo.type.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.daterangeInfo.type.fd"/>
	<dict:constraintDescriptorRef bean="field.daterangeInfo.type.cd"/>
</dict:field>
<dict:field key="type" id="field.daterangeInfo.type" parent="field.daterangeInfo.type.abstract"/>
<dict:fieldDescriptor id="field.daterangeInfo.type.fd.abstract" abstract="true">
	<dict:name>Date Range Type</dict:name>
	<dict:desc>Unique identifier for a date range type.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.daterangeInfo.type.fd" parent="field.daterangeInfo.type.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali TYPE: required on add, then read-only; In list of configured  time period daterange types -->
<dict:constraintDescriptor id="field.daterangeInfo.type.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.type"/>
	<dict:constraintRef bean="constraint.daterange.types"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="type" id="field.daterangeInfo.type.cd" parent="field.daterangeInfo.type.cd.abstract"/>

<dict:field key="state" id="field.daterangeInfo.state.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.daterangeInfo.state.fd"/>
	<dict:constraintDescriptorRef bean="field.daterangeInfo.state.cd"/>
<dict:selector>true</dict:selector>
</dict:field>
<dict:field key="state" id="field.daterangeInfo.state" parent="field.daterangeInfo.state.abstract"/>
<dict:fieldDescriptor id="field.daterangeInfo.state.fd.abstract" abstract="true">
	<dict:name>Date Range State</dict:name>
	<dict:desc>The current status of the date range. The values for this field are constrained to those in the dateRangeState enumeration. A separate setup operation does not exist for retrieval of the meta data around this value.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.daterangeInfo.state.fd" parent="field.daterangeInfo.state.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali STATE -->
<dict:constraintDescriptor id="field.daterangeInfo.state.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.state"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="state" id="field.daterangeInfo.state.cd" parent="field.daterangeInfo.state.cd.abstract"/>

<dict:field key="key" id="field.daterangeInfo.key.abstract" abstract="true">
	<dict:fieldDescriptorRef bean="field.daterangeInfo.key.fd"/>
	<dict:constraintDescriptorRef bean="field.daterangeInfo.key.cd"/>
</dict:field>
<dict:field key="key" id="field.daterangeInfo.key" parent="field.daterangeInfo.key.abstract"/>
<dict:fieldDescriptor id="field.daterangeInfo.key.fd.abstract" abstract="true">
	<dict:name>Date Range Key</dict:name>
	<dict:desc>Unique identifier for a date range.</dict:desc>
	<dict:dataType>string</dict:dataType>
</dict:fieldDescriptor>
<dict:fieldDescriptor id="field.daterangeInfo.key.fd" parent="field.daterangeInfo.key.fd.abstract"/>
<!-- Required; Single valued (non-repeating); Kuali KEY; structured like a type but unique like and ID, used to identify configured objects. -->
<dict:constraintDescriptor id="field.daterangeInfo.key.cd.abstract" abstract="true">
	<dict:constraintRef bean="constraint.required"/>
	<dict:constraintRef bean="constraint.single"/>
	<dict:constraintRef bean="constraint.kuali.key"/>
</dict:constraintDescriptor>
<dict:constraintDescriptor key="key" id="field.daterangeInfo.key.cd" parent="field.daterangeInfo.key.cd.abstract"/>
</beans>
