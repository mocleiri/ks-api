<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns:dict="http://student.kuali.org/xsd/dictionary-extension"
xsi:schemaLocation="
http://student.kuali.org/xsd/dictionary-extension dictionary-extension.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
">
<!-- *** Automatically Generated ***
on: Wed Feb 03 21:19:46 EST 2010
by: org.kuali.student.dictionary.writer.DictionaryModelWriter
Using:Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls   and: Excel Spreadsheet src/test/resources/type-state configuration.xls, Excel Spreadsheet src/test/resources/services.xls
 -->
<import resource="constraints-dictionary-config.xml"/>

<!-- Detailed information about a credit value. -->
<dict:objectStructure key="org.kuali.student.lum.lrc.dto.CreditInfo" id="object.creditInfo.abstract" abstract="true">
	<dict:typeRef bean="object.creditInfo.type"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.lum.lrc.dto.CreditInfo" id="object.creditInfo" parent="object.creditInfo.abstract"/>

<dict:type key="(default)" id="object.creditInfo.type.abstract" abstract="true">
	<dict:stateRef bean="object.creditInfo.state"/>
</dict:type>
<dict:type key="(default)" id="object.creditInfo.type" parent="object.creditInfo.type.abstract"/>

<dict:state key="(default)" id="object.creditInfo.state.abstract" abstract="true">
	<dict:fieldRef bean="field.creditInfo.name"/>
	<dict:fieldRef bean="field.creditInfo.desc"/>
	<dict:fieldRef bean="field.creditInfo.value"/>
	<dict:fieldRef bean="field.creditInfo.effectiveDate"/>
	<dict:fieldRef bean="field.creditInfo.expirationDate"/>
	<dict:fieldRef bean="field.creditInfo.attributes"/>
	<dict:fieldRef bean="field.creditInfo.type"/>
	<dict:fieldRef bean="field.creditInfo.id"/>
</dict:state>
<dict:state key="(default)" id="object.creditInfo.state" parent="creditInfo.state.abstract"/>

<dict:field key="name" id="field.creditInfo.name.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Credit Name</dict:name>
		<dict:desc>Name of this credit. This may have a direct relation to the combination of value and type fields.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.single.line.text"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="name" id="field.creditInfo.name" parent="field.creditInfo.name.abstract">
</dict:field>

<dict:field key="desc" id="field.creditInfo.desc.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Credit Description</dict:name>
		<dict:desc>Description of this credit.</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="desc" id="field.creditInfo.desc" parent="field.creditInfo.desc.abstract">
</dict:field>

<dict:field key="value" id="field.creditInfo.value.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Credit Value</dict:name>
		<dict:desc>The number of the credits. This is typically numeric, but string is used to cover cases such as fractional and unbounded.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.single.line.text"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="value" id="field.creditInfo.value" parent="field.creditInfo.value.abstract">
</dict:field>

<dict:field key="effectiveDate" id="field.creditInfo.effectiveDate.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Effective Date</dict:name>
		<dict:desc>Date and time that this credit value became effective. This is a similar concept to the effective date on enumerated values. When an expiration date has been specified, this field must be less than or equal to the expiration date.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="effectiveDate" id="field.creditInfo.effectiveDate" parent="field.creditInfo.effectiveDate.abstract">
</dict:field>

<dict:field key="expirationDate" id="field.creditInfo.expirationDate.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Expiration Date</dict:name>
		<dict:desc>Date and time that this credit value expires. This is a similar concept to the expiration date on enumerated values. If specified, this should be greater than or equal to the effective date. If this field is not specified, then no expiration date has been currently defined and should automatically be considered greater than the effective date.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="expirationDate" id="field.creditInfo.expirationDate" parent="field.creditInfo.expirationDate.abstract">
</dict:field>

<dict:field key="attributes" id="field.creditInfo.attributes.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Generic/dynamic attributes</dict:name>
		<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
	<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="attributes" id="field.creditInfo.attributes" parent="field.creditInfo.attributes.abstract">
</dict:field>

<dict:field key="type" id="field.creditInfo.type.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Credit Type</dict:name>
		<dict:desc>Unique identifier for a credit type.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="type" id="field.creditInfo.type" parent="field.creditInfo.type.abstract">
</dict:field>

<dict:field key="id" id="field.creditInfo.id.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Credit Identifier</dict:name>
		<dict:desc>Unique identifier for a credit value.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.id"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="id" id="field.creditInfo.id" parent="field.creditInfo.id.abstract">
</dict:field>

<!-- Detailed information about a grade value. -->
<dict:objectStructure key="org.kuali.student.lum.lrc.dto.GradeInfo" id="object.gradeInfo.abstract" abstract="true">
	<dict:typeRef bean="object.gradeInfo.type"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.lum.lrc.dto.GradeInfo" id="object.gradeInfo" parent="object.gradeInfo.abstract"/>

<dict:type key="(default)" id="object.gradeInfo.type.abstract" abstract="true">
	<dict:stateRef bean="object.gradeInfo.state"/>
</dict:type>
<dict:type key="(default)" id="object.gradeInfo.type" parent="object.gradeInfo.type.abstract"/>

<dict:state key="(default)" id="object.gradeInfo.state.abstract" abstract="true">
	<dict:fieldRef bean="field.gradeInfo.name"/>
	<dict:fieldRef bean="field.gradeInfo.value"/>
	<dict:fieldRef bean="field.gradeInfo.scaleKey"/>
	<dict:fieldRef bean="field.gradeInfo.rank"/>
	<dict:fieldRef bean="field.gradeInfo.effectiveDate"/>
	<dict:fieldRef bean="field.gradeInfo.expirationDate"/>
	<dict:fieldRef bean="field.gradeInfo.attributes"/>
	<dict:fieldRef bean="field.gradeInfo.type"/>
	<dict:fieldRef bean="field.gradeInfo.key"/>
</dict:state>
<dict:state key="(default)" id="object.gradeInfo.state" parent="gradeInfo.state.abstract"/>

<dict:field key="name" id="field.gradeInfo.name.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Grade Name</dict:name>
		<dict:desc>Name of the grade. This is likely related to the type, value and/or scale, but this is not required.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.single.line.text"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="name" id="field.gradeInfo.name" parent="field.gradeInfo.name.abstract">
</dict:field>

<dict:field key="value" id="field.gradeInfo.value.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Grade Value</dict:name>
		<dict:desc>Value of the grade. Typically corresponds with the short coded form of the grade (ex. &quot;A&quot;, &quot;4.0&quot;, &quot;97.0%&quot;, etc.)</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.code"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="value" id="field.gradeInfo.value" parent="field.gradeInfo.value.abstract">
</dict:field>

<dict:field key="scaleKey" id="field.gradeInfo.scaleKey.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Scale Identifier</dict:name>
		<dict:desc>Identifier of the scale for this grade value.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.grade.scales"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="scaleKey" id="field.gradeInfo.scaleKey" parent="field.gradeInfo.scaleKey.abstract">
</dict:field>

<dict:field key="rank" id="field.gradeInfo.rank.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Grade Rank</dict:name>
		<dict:desc>Rank of the grade value within the scale. Standards around uniqueness and meaning of value are described in the information about the scale.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="rank" id="field.gradeInfo.rank" parent="field.gradeInfo.rank.abstract">
</dict:field>

<dict:field key="effectiveDate" id="field.gradeInfo.effectiveDate.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Effective Date</dict:name>
		<dict:desc>Date and time that this grade value became effective. This is a similar concept to the effective date on enumerated values. When an expiration date has been specified, this field must be less than or equal to the expiration date.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="effectiveDate" id="field.gradeInfo.effectiveDate" parent="field.gradeInfo.effectiveDate.abstract">
</dict:field>

<dict:field key="expirationDate" id="field.gradeInfo.expirationDate.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Expiration Date</dict:name>
		<dict:desc>Date and time that this grade value expires. This is a similar concept to the expiration date on enumerated values. If specified, this should be greater than or equal to the effective date. If this field is not specified, then no expiration date has been currently defined and should automatically be considered greater than the effective date.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="expirationDate" id="field.gradeInfo.expirationDate" parent="field.gradeInfo.expirationDate.abstract">
</dict:field>

<dict:field key="attributes" id="field.gradeInfo.attributes.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Generic/dynamic attributes</dict:name>
		<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
	<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="attributes" id="field.gradeInfo.attributes" parent="field.gradeInfo.attributes.abstract">
</dict:field>

<dict:field key="type" id="field.gradeInfo.type.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Grade Type</dict:name>
		<dict:desc>Unique identifier for a grade type.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.type"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="type" id="field.gradeInfo.type" parent="field.gradeInfo.type.abstract">
</dict:field>

<dict:field key="key" id="field.gradeInfo.key.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Grade Identifier</dict:name>
		<dict:desc>Unique identifier for a grade value.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.key"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="key" id="field.gradeInfo.key" parent="field.gradeInfo.key.abstract">
</dict:field>

<!-- Detailed information about a result component. -->
<dict:objectStructure key="org.kuali.student.lum.lrc.dto.ResultComponentInfo" id="object.resultComponentInfo.abstract" abstract="true">
	<dict:typeRef bean="object.resultComponentInfo.type"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.lum.lrc.dto.ResultComponentInfo" id="object.resultComponentInfo" parent="object.resultComponentInfo.abstract"/>

<dict:type key="(default)" id="object.resultComponentInfo.type.abstract" abstract="true">
	<dict:stateRef bean="object.resultComponentInfo.state"/>
</dict:type>
<dict:type key="(default)" id="object.resultComponentInfo.type" parent="object.resultComponentInfo.type.abstract"/>

<dict:state key="(default)" id="object.resultComponentInfo.state.abstract" abstract="true">
	<dict:fieldRef bean="field.resultComponentInfo.name"/>
	<dict:fieldRef bean="field.resultComponentInfo.desc"/>
	<dict:fieldRef bean="field.resultComponentInfo.resultValueIds"/>
	<dict:fieldRef bean="field.resultComponentInfo.effectiveDate"/>
	<dict:fieldRef bean="field.resultComponentInfo.expirationDate"/>
	<dict:fieldRef bean="field.resultComponentInfo.attributes"/>
	<dict:fieldRef bean="field.resultComponentInfo.metaInfo"/>
	<dict:fieldRef bean="field.resultComponentInfo.type"/>
	<dict:fieldRef bean="field.resultComponentInfo.state"/>
	<dict:fieldRef bean="field.resultComponentInfo.id"/>
</dict:state>
<dict:state key="(default)" id="object.resultComponentInfo.state" parent="resultComponentInfo.state.abstract"/>

<dict:field key="name" id="field.resultComponentInfo.name.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Result Component Name</dict:name>
		<dict:desc>Friendly name of the result component</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="name" id="field.resultComponentInfo.name" parent="field.resultComponentInfo.name.abstract">
</dict:field>

<dict:field key="desc" id="field.resultComponentInfo.desc.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Result Component Description</dict:name>
		<dict:desc>Narrative description of the result component</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="desc" id="field.resultComponentInfo.desc" parent="field.resultComponentInfo.desc.abstract">
</dict:field>

<dict:field key="resultValueIds" id="field.resultComponentInfo.resultValueIds.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Result Value Identifiers</dict:name>
		<dict:desc>List of result value identifiers. Result values are not unique things themselves, but are instead references to other entities.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.repeating"/>
			<dict:constraintRef bean="constraint.related.resultValueId"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="resultValueIds" id="field.resultComponentInfo.resultValueIds" parent="field.resultComponentInfo.resultValueIds.abstract">
</dict:field>

<dict:field key="effectiveDate" id="field.resultComponentInfo.effectiveDate.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Effective Date</dict:name>
		<dict:desc>Date and time that this result component became effective. This is a similar concept to the effective date on enumerated values. When an expiration date has been specified, this field must be less than or equal to the expiration date.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="effectiveDate" id="field.resultComponentInfo.effectiveDate" parent="field.resultComponentInfo.effectiveDate.abstract">
</dict:field>

<dict:field key="expirationDate" id="field.resultComponentInfo.expirationDate.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Expiration Date</dict:name>
		<dict:desc>Date and time that this result component expires. This is a similar concept to the expiration date on enumerated values. If specified, this should be greater than or equal to the effective date. If this field is not specified, then no expiration date has been currently defined and should automatically be considered greater than the effective date.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="expirationDate" id="field.resultComponentInfo.expirationDate" parent="field.resultComponentInfo.expirationDate.abstract">
</dict:field>

<dict:field key="attributes" id="field.resultComponentInfo.attributes.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Generic/dynamic attributes</dict:name>
		<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.repeating"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="attributes" id="field.resultComponentInfo.attributes" parent="field.resultComponentInfo.attributes.abstract">
</dict:field>

<dict:field key="metaInfo" id="field.resultComponentInfo.metaInfo.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Create/Update meta info</dict:name>
		<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.meta.data"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="metaInfo" id="field.resultComponentInfo.metaInfo" parent="field.resultComponentInfo.metaInfo.abstract">
</dict:field>

<dict:field key="type" id="field.resultComponentInfo.type.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Result Component Type</dict:name>
		<dict:desc>Unique identifier for a result component type.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.type"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="type" id="field.resultComponentInfo.type" parent="field.resultComponentInfo.type.abstract">
</dict:field>

<dict:field key="state" id="field.resultComponentInfo.state.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Result Component State</dict:name>
		<dict:desc>The current status of the result component. The values for this field are constrained to those in the state enumeration. A separate setup operation does not exist for retrieval of the meta data around this value.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.state"/>
	</dict:constraintDescriptor>
	<dict:selector>true</dict:selector>
</dict:field>
<dict:field key="state" id="field.resultComponentInfo.state" parent="field.resultComponentInfo.state.abstract">
</dict:field>

<dict:field key="id" id="field.resultComponentInfo.id.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Result Component Id</dict:name>
		<dict:desc>Unique identifier for a result component. This is optional, due to the identifier being set at the time of creation. Once the result component has been created, this should be seen as required.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.id"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="id" id="field.resultComponentInfo.id" parent="field.resultComponentInfo.id.abstract">
</dict:field>

<!-- Detailed information about a learning result definition. -->
<dict:objectStructure key=".LrDefinitionInfo" id="object.lrDefinitionInfo.abstract" abstract="true">
	<dict:typeRef bean="object.lrDefinitionInfo.type"/>
</dict:objectStructure>
<dict:objectStructure key=".LrDefinitionInfo" id="object.lrDefinitionInfo" parent="object.lrDefinitionInfo.abstract"/>

<dict:type key="(default)" id="object.lrDefinitionInfo.type.abstract" abstract="true">
	<dict:stateRef bean="object.lrDefinitionInfo.state"/>
</dict:type>
<dict:type key="(default)" id="object.lrDefinitionInfo.type" parent="object.lrDefinitionInfo.type.abstract"/>

<dict:state key="(default)" id="object.lrDefinitionInfo.state.abstract" abstract="true">
	<dict:fieldRef bean="field.lrDefinitionInfo.name"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.desc"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.lrType"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.lrScale"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.value"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.operator"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.attributes"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.metaInfo"/>
	<dict:fieldRef bean="field.lrDefinitionInfo.lrDefinitionId"/>
</dict:state>
<dict:state key="(default)" id="object.lrDefinitionInfo.state" parent="lrDefinitionInfo.state.abstract"/>

<dict:field key="name" id="field.lrDefinitionInfo.name.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Learning Result Definition Name</dict:name>
		<dict:desc>Friendly name for the learning result definition.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.single.line.text"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="name" id="field.lrDefinitionInfo.name" parent="field.lrDefinitionInfo.name.abstract">
</dict:field>

<dict:field key="desc" id="field.lrDefinitionInfo.desc.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Learning Result Definition Description</dict:name>
		<dict:desc>Any finite sequence of characters with letters, numerals, symbols and punctuation marks. The length can be any natural number between zero or any positive integer.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.multi.line.text"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="desc" id="field.lrDefinitionInfo.desc" parent="field.lrDefinitionInfo.desc.abstract">
</dict:field>

<dict:field key="lrType" id="field.lrDefinitionInfo.lrType.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Learning Result Type</dict:name>
		<dict:desc>Unique identifier for a learning result type. This is immutable once set.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.type"/>
			<dict:constraintRef bean="constraint.lrd.types"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="lrType" id="field.lrDefinitionInfo.lrType" parent="field.lrDefinitionInfo.lrType.abstract">
</dict:field>

<!-- The lrScaleTypeKey as a type is deprected so I am not sure if it is really in use or if it should really point to a different type "scaleKey"?  

This field does not make sense. The GradeKey points to the GradeInfo object that tells us what the scale is -->
<!-- The lrScaleTypeKey as a type is deprected so I am not sure if it is really in use or if it should really point to a different type "scaleKey"?  

This field does not make sense. The GradeKey points to the GradeInfo object that tells us what the scale is -->
<dict:field key="lrScale" id="field.lrDefinitionInfo.lrScale.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Learning Result Scale</dict:name>
		<dict:desc>Unique identifier for a learning result scale type. This is immutable once set.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.type"/>
			<dict:constraintRef bean="constraint.learning.result.scale.types"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="lrScale" id="field.lrDefinitionInfo.lrScale" parent="field.lrDefinitionInfo.lrScale.abstract">
</dict:field>

<!-- Isn't this really an ID or KEY that points to either a GradeInfo or a CreditInfo or a CredentialInfo object similar to resultComponentInfo.resultValueIds? -->
<!-- Isn't this really an ID or KEY that points to either a GradeInfo or a CreditInfo or a CredentialInfo object similar to resultComponentInfo.resultValueIds? -->
<dict:field key="value" id="field.lrDefinitionInfo.value.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Learning Result Value</dict:name>
		<dict:desc>Value for the learning result.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="value" id="field.lrDefinitionInfo.value" parent="field.lrDefinitionInfo.value.abstract">
</dict:field>

<dict:field key="operator" id="field.lrDefinitionInfo.operator.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>operator</dict:name>
		<dict:desc>The operator to use with the value, such as &gt;= (greater than or equal to)</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.code"/>
			<dict:constraintRef bean="constraint.lrd.operators"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="operator" id="field.lrDefinitionInfo.operator" parent="field.lrDefinitionInfo.operator.abstract">
</dict:field>

<dict:field key="attributes" id="field.lrDefinitionInfo.attributes.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Generic/dynamic attributes</dict:name>
		<dict:desc>List of key/value pairs, typically used for dynamic attributes.</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.repeating"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="attributes" id="field.lrDefinitionInfo.attributes" parent="field.lrDefinitionInfo.attributes.abstract">
</dict:field>

<dict:field key="metaInfo" id="field.lrDefinitionInfo.metaInfo.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Create/Update meta info</dict:name>
		<dict:desc>Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations.</dict:desc>
		<dict:dataType>complex</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.meta.data"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="metaInfo" id="field.lrDefinitionInfo.metaInfo" parent="field.lrDefinitionInfo.metaInfo.abstract">
</dict:field>

<dict:field key="lrDefinitionId" id="field.lrDefinitionInfo.lrDefinitionId.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Learning Result Definition Id</dict:name>
		<dict:desc>Unique identifier for a learning result definition record. This is optional, due to the identifier being set at the time of creation. Once the result definition has been created, this should be seen as required.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.id"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="lrDefinitionId" id="field.lrDefinitionInfo.lrDefinitionId" parent="field.lrDefinitionInfo.lrDefinitionId.abstract">
</dict:field>

<!-- Complex type supporting both a plain text and formatted version of a string. -->
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="object.richTextInfo.abstract" abstract="true">
	<dict:typeRef bean="object.richTextInfo.type"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.RichTextInfo" id="object.richTextInfo" parent="object.richTextInfo.abstract"/>

<dict:type key="(default)" id="object.richTextInfo.type.abstract" abstract="true">
	<dict:stateRef bean="object.richTextInfo.state"/>
</dict:type>
<dict:type key="(default)" id="object.richTextInfo.type" parent="object.richTextInfo.type.abstract"/>

<dict:state key="(default)" id="object.richTextInfo.state.abstract" abstract="true">
	<dict:fieldRef bean="field.richTextInfo.plain"/>
	<dict:fieldRef bean="field.richTextInfo.formatted"/>
</dict:state>
<dict:state key="(default)" id="object.richTextInfo.state" parent="richTextInfo.state.abstract"/>

<dict:field key="plain" id="field.richTextInfo.plain.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Plain Text</dict:name>
		<dict:desc>Plain version of the text. This may be used for searching.</dict:desc>
		<dict:dataType>string</dict:dataType>
		<dict:readOnly>true</dict:readOnly>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.read.only"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.multi.line.text"/>
			<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
				<dict:maxLength>(unbounded)</dict:maxLength>
				</dict:constraint>
			<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
				<dict:maxLength>(unbounded)</dict:maxLength>
				</dict:constraint>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="plain" id="field.richTextInfo.plain" parent="field.richTextInfo.plain.abstract">
</dict:field>

<dict:field key="formatted" id="field.richTextInfo.formatted.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Formatted Text</dict:name>
		<dict:desc>Formatted version of the text.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.optional"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.rich.text"/>
			<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
				<dict:maxLength>(unbounded)</dict:maxLength>
				</dict:constraint>
			<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
				<dict:maxLength>(unbounded)</dict:maxLength>
				</dict:constraint>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="formatted" id="field.richTextInfo.formatted" parent="field.richTextInfo.formatted.abstract">
</dict:field>

<!-- List of key/value pairs, typically used for dynamic attributes. -->
<dict:objectStructure key=".AttributeInfo" id="object.attributeInfo.abstract" abstract="true">
	<dict:typeRef bean="object.attributeInfo.type"/>
</dict:objectStructure>
<dict:objectStructure key=".AttributeInfo" id="object.attributeInfo" parent="object.attributeInfo.abstract"/>

<dict:type key="(default)" id="object.attributeInfo.type.abstract" abstract="true">
	<dict:stateRef bean="object.attributeInfo.state"/>
</dict:type>
<dict:type key="(default)" id="object.attributeInfo.type" parent="object.attributeInfo.type.abstract"/>

<dict:state key="(default)" id="object.attributeInfo.state.abstract" abstract="true">
	<dict:fieldRef bean="field.attributeInfo.value"/>
	<dict:fieldRef bean="field.attributeInfo.key"/>
</dict:state>
<dict:state key="(default)" id="object.attributeInfo.state" parent="attributeInfo.state.abstract"/>

<dict:field key="value" id="field.attributeInfo.value.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Attribute Value</dict:name>
		<dict:desc>The value for this dynamic attribute.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
				<dict:maxLength>(unbounded)</dict:maxLength>
				</dict:constraint>
			<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
				<dict:maxLength>(unbounded)</dict:maxLength>
				</dict:constraint>
	</dict:constraintDescriptor>
	<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="value" id="field.attributeInfo.value" parent="field.attributeInfo.value.abstract">
</dict:field>

<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
<dict:field key="key" id="field.attributeInfo.key.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Attribute Type Identifier</dict:name>
		<dict:desc>The identifier for this attribute.</dict:desc>
		<dict:dataType>string</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.kuali.type"/>
			<dict:constraintRef bean="constraint.dynamic.field.types"/>
	</dict:constraintDescriptor>
	<dict:dynamic>true</dict:dynamic>
</dict:field>
<dict:field key="key" id="field.attributeInfo.key" parent="field.attributeInfo.key.abstract">
</dict:field>

<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="object.metaInfo.abstract" abstract="true">
	<dict:typeRef bean="object.metaInfo.type"/>
</dict:objectStructure>
<dict:objectStructure key="org.kuali.student.core.dto.MetaInfo" id="object.metaInfo" parent="object.metaInfo.abstract"/>

<dict:type key="(default)" id="object.metaInfo.type.abstract" abstract="true">
	<dict:stateRef bean="object.metaInfo.state"/>
</dict:type>
<dict:type key="(default)" id="object.metaInfo.type" parent="object.metaInfo.type.abstract"/>

<dict:state key="(default)" id="object.metaInfo.state.abstract" abstract="true">
	<dict:fieldRef bean="field.metaInfo.versionInd"/>
	<dict:fieldRef bean="field.metaInfo.createTime"/>
	<dict:fieldRef bean="field.metaInfo.createId"/>
	<dict:fieldRef bean="field.metaInfo.updateTime"/>
	<dict:fieldRef bean="field.metaInfo.updateId"/>
</dict:state>
<dict:state key="(default)" id="object.metaInfo.state" parent="metaInfo.state.abstract"/>

<dict:field key="versionInd" id="field.metaInfo.versionInd.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Version Indicator</dict:name>
		<dict:desc>An indicator of the version of the thing being described with this meta information. This is set by the service implementation and will be used to determine conflicts in updates.</dict:desc>
		<dict:dataType>string</dict:dataType>
		<dict:readOnly>true</dict:readOnly>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.calc.meta.versionInd"/>
			<dict:constraintRef bean="constraint.read.only"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="versionInd" id="field.metaInfo.versionInd" parent="field.metaInfo.versionInd.abstract">
</dict:field>

<dict:field key="createTime" id="field.metaInfo.createTime.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Date/Time Created</dict:name>
		<dict:desc>The date and time the thing being described with this meta information was created</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
			<dict:constraintRef bean="constraint.default.now"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="createTime" id="field.metaInfo.createTime" parent="field.metaInfo.createTime.abstract">
</dict:field>

<dict:field key="createId" id="field.metaInfo.createId.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Created By Identifier</dict:name>
		<dict:desc>The principal who created the thing being described with this meta information</dict:desc>
		<dict:dataType>string</dict:dataType>
		<dict:readOnly>true</dict:readOnly>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.read.only"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.related.principalId"/>
			<dict:constraintRef bean="constraint.default.authenicated.principalId"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="createId" id="field.metaInfo.createId" parent="field.metaInfo.createId.abstract">
</dict:field>

<dict:field key="updateTime" id="field.metaInfo.updateTime.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Date/Time Last Updated</dict:name>
		<dict:desc>The date and time the thing being described with this meta information was last updated. This would be filled in on initial creation as well.</dict:desc>
		<dict:dataType>dateTime</dict:dataType>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.required"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.date.time"/>
			<dict:constraintRef bean="constraint.calc.now"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="updateTime" id="field.metaInfo.updateTime" parent="field.metaInfo.updateTime.abstract">
</dict:field>

<dict:field key="updateId" id="field.metaInfo.updateId.abstract" abstract="true">
	<dict:fieldDescriptor>
		<dict:name>Updated By Identifier</dict:name>
		<dict:desc>The principal who last updated the thing being described with this meta information. This would be filled in on initial creation as well.</dict:desc>
		<dict:dataType>string</dict:dataType>
		<dict:readOnly>true</dict:readOnly>
	</dict:fieldDescriptor>
	<dict:constraintDescriptor>
			<dict:constraintRef bean="constraint.read.only"/>
			<dict:constraintRef bean="constraint.single"/>
			<dict:constraintRef bean="constraint.related.principalId"/>
			<dict:constraintRef bean="constraint.calc.authenicated.principalId"/>
	</dict:constraintDescriptor>
</dict:field>
<dict:field key="updateId" id="field.metaInfo.updateId" parent="field.metaInfo.updateId.abstract">
</dict:field>
</beans>
