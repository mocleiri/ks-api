<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dict="http://student.kuali.org/xsd/dictionary-extension"
	xsi:schemaLocation="
http://student.kuali.org/xsd/dictionary-extension http://student.kuali.org/xsd/dictionary-extension/dictionary-extension.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
">
	<dict:constraint key="calc.course.no" id="calc.course.no">
		<dict:minOccurs>0</dict:minOccurs>
	</dict:constraint>

	<dict:constraint key="calc.copy.course.official.subjectArea" id="calc.copy.course.official.subjectArea">
		<dict:minOccurs>0</dict:minOccurs>
	</dict:constraint>

	<dict:constraint key="calc.copy.course.official.numberPart" id="calc.copy.course.official.numberPart">
		<dict:minOccurs>0</dict:minOccurs>
	</dict:constraint>

	<dict:constraint key="calc.plain.text" id="calc.plain.text">
		<dict:minOccurs>0</dict:minOccurs>
	</dict:constraint>

	<dict:constraint key="calc.meta.versionInd" id="calc.meta.versionInd">
		<dict:minOccurs>0</dict:minOccurs>
	</dict:constraint>

	<dict:constraint key="calc.now" id="calc.now">
		<dict:minOccurs>0</dict:minOccurs>
	</dict:constraint>

	<dict:constraint key="calc.authenicated.principalId" id="calc.authenicated.principalId">
		<dict:minOccurs>0</dict:minOccurs>
	</dict:constraint>

	<dict:constraint key="read.only" id="read.only">
		<dict:minOccurs>0</dict:minOccurs>
	</dict:constraint>

	<dict:constraint key="hidden" id="hidden">
		<dict:minOccurs>0</dict:minOccurs>
	</dict:constraint>

	<dict:constraint key="default.active" id="default.active">
		<dict:minOccurs>0</dict:minOccurs>
	</dict:constraint>

	<dict:constraint key="default.true" id="default.true">
		<dict:minOccurs>0</dict:minOccurs>
	</dict:constraint>

	<dict:constraint key="default.authenicated.principalId" id="default.authenicated.principalId">
		<dict:minOccurs>0</dict:minOccurs>
	</dict:constraint>

	<dict:constraint key="default.now" id="default.now">
		<dict:minOccurs>0</dict:minOccurs>
	</dict:constraint>

	<dict:constraint key="related.resultComponentId" id="related.resultComponentId">
		<dict:minOccurs>0</dict:minOccurs>
	</dict:constraint>

	<dict:constraint key="related.resultValueId" id="related.resultValueId">
		<dict:minOccurs>0</dict:minOccurs>
	</dict:constraint>

	<dict:constraint key="required" id="required" serverSide="false">
		<!-- Required -->
		<dict:minOccurs>1</dict:minOccurs>
	</dict:constraint>

	<dict:constraint key="optional" id="optional" serverSide="false">
		<!-- Optional -->
		<!-- Used to override a previous required constraint.  Also implied by the absence of a required constraint -->
		<dict:minOccurs>0</dict:minOccurs>
		</dict:constraint>

	<dict:constraint key="not.used" id="not.used" serverSide="false">
		<!-- Not Used -->
		<dict:minOccurs>0</dict:minOccurs>
		<dict:maxOccurs>0</dict:maxOccurs>
		</dict:constraint>

	<dict:constraint key="repeating" id="repeating" serverSide="false">
		<!-- Repeating -->
		<!-- Nine 9's get translated as "(unbounded)" -->
		<dict:maxOccurs>(unbounded)</dict:maxOccurs>
		</dict:constraint>

	<dict:constraint key="single" id="single" serverSide="false">
		<!-- Single valued (non-repeating) -->
		<!-- Used to override a repeating constraint -->
		<dict:maxOccurs>1</dict:maxOccurs>
		</dict:constraint>

	<dict:constraint key="code" id="code" serverSide="false">
		<!-- Alphanumeric code, hypen and period. -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="code.uppercase" id="code.uppercase" serverSide="false">
		<!-- uppercase alphanumeric code, hypen and period. -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[A-Z0-9.-]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="code.lowercase" id="code.lowercase" serverSide="false">
		<!-- lowercase alphanumeric code, hypen and period. -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[a-z0-9.-]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="single.line.text" id="single.line.text" serverSide="false">
		<!-- A basic single line of text, no embedded carraige returns or tabs limited to 255 -->
		<!-- old reg ex was "[A-Za-z0-9.-;;'&%$#@!]* -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>255</dict:maxLength>
<!-- 
		<dict:validChars>
 		<dict:value>regex:[\p{Print} ]*</dict:value> 
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="letter" id="letter" serverSide="false">
		<!-- letters only -->
		<dict:validChars>
		<dict:value>regex:[A-Za-z]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="size.one" id="size.one" serverSide="false">
		<!-- Only one character -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>1</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="size.two" id="size.two" serverSide="false">
		<!-- Two characters both must be filled out. -->
		<dict:minLength>2</dict:minLength>
		<dict:maxLength>2</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="size.up.to.two" id="size.up.to.two" serverSide="false">
		<!-- Up to 2 characters long -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>2</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="no.linefeeds" id="no.linefeeds" serverSide="false">
		<!-- Any character EXCEPT carraige returns and line feeds -->
<!-- 
		<dict:validChars>
		<dict:value>regex:[^\n\r]*</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="no.tabs" id="no.tabs" serverSide="false">
		<!-- Any character EXCEPT a tab -->
<!-- 
		<dict:validChars>
		<dict:value>regex:[^\t]*</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="multi.line.text" id="multi.line.text" serverSide="false">
		<!-- Multi-line text field that accepts all printable characters plus tab, carraige-return and linefeed. -->
		<!-- old reg ex was [A-Za-z0-9.-;;'&%$#@!\n\r\t]* -->
		<dict:minLength>1</dict:minLength>
<!-- 	
    	<dict:validChars>
		<dict:value>regex:[\p{Print}\p{Blank}\n\r]*</dict:value> 
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="rich.text" id="rich.text" serverSide="false">
		<!-- Text field that accepts all types of characters using some sort of escaping convention along with the ability to specify bolding, font size, color etc. -->
		<!-- Not sure if characterset for rich text is the same for regular text but just interpretted differently.  I.e. html is plain text interpreted differently. -->
		<dict:minLength>1</dict:minLength>
<!-- 
		<dict:validChars>
 		<dict:value>regex:[\p{Print}\p{Blank}\n\r]*</dict:value> 
		</dict:validChars>
		-->
		</dict:constraint>

	<dict:constraint key="date" id="date" serverSide="false">
		<!-- Date -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=760 (but not sure) -->
		<dict:minLength>10</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="date.time" id="date.time" serverSide="false">
		<!-- Date-Time -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=1966 (but not sure) -->
		<dict:minLength>19</dict:minLength>
		<dict:maxLength>19</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="integer" id="integer" serverSide="false">
		<!-- Integer -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=14 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
<!-- 
		<dict:validChars>
  		<dict:value>regex:^(\+|-)?\d+$</dict:value> 
		</dict:validChars>
		-->
		</dict:constraint>

	<dict:constraint key="non-negative.integer" id="non-negative.integer" serverSide="false">
		<!-- Non-Negative Integer -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=13 -->
		<dict:minValue>0</dict:minValue>
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
<!-- 
		<dict:validChars>
    		<dict:value>regex:^\d+$</dict:value> 
		</dict:validChars>
		-->
		</dict:constraint>

	<dict:constraint key="decimal" id="decimal" serverSide="false">
		<!-- decimal number -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=117 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
<!-- 
		<dict:validChars>
    	<dict:value>regex:^[-+]?\d+(\.\d+)?$</dict:value> 
		</dict:validChars>
		-->
		</dict:constraint>

	<dict:constraint key="non.negative.decimal" id="non.negative.decimal" serverSide="false">
		<!-- non-negative decimal number -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=117 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
<!-- 
	<dict:validChars>
		<dict:value>regex:^[-+]?\d+(\.\d+)?$</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="amount" id="amount" serverSide="false">
		<!-- Amount field -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=131 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
<!--
 		<dict:validChars>
		<dict:value>regex:^\$?\d+(\.(\d{2}))?$</dict:value>
		</dict:validChars>
	-->
		</dict:constraint>

	<dict:constraint key="url" id="url" serverSide="false">
		<!-- Uniform Resource Locator -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=96 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>2083</dict:maxLength>
		<!-- 
		<dict:validChars>
		<dict:value>regex:(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&amp;amp;:/~\+#]*[\w\-\@?^=%&amp;amp;/~\+#])?</dict:value>
		</dict:validChars>
		-->
		</dict:constraint>

	<dict:constraint key="boolean" id="boolean" serverSide="false">
		<!-- True or False -->
		<!-- http://regexlib.com/REDetails.aspx?regexp_id=905 -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>5</dict:maxLength>
		<!-- 
		<dict:validChars>
		<dict:value>regex:[Ff]+(alse)?|[Tt]+(rue)</dict:value>
		</dict:validChars>
		-->
		</dict:constraint>

	<dict:constraint key="kuali.id" id="kuali.id" className="Special Class to do this?" serverSide="true">
		<!-- Kuali ID; calculated by service on add, then read-only. -->
		<!-- MinOccur on ID's of 1 may not work because it is missing on the create -->
		<dict:minOccurs>1</dict:minOccurs>
		<dict:maxOccurs>1</dict:maxOccurs>
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="kuali.key" id="kuali.key" className="Special Class to do this?" serverSide="true">
		<!-- Kuali KEY; structured like a type but unique like and ID, used to identify configured objects. -->
		<dict:minOccurs>1</dict:minOccurs>
		<dict:maxOccurs>1</dict:maxOccurs>
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="kuali.type" id="kuali.type" serverSide="true">
		<!-- Kuali TYPE: required on add, then read-only -->
		<dict:minOccurs>1</dict:minOccurs>
		<dict:maxOccurs>1</dict:maxOccurs>
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="kuali.state" id="kuali.state" serverSide="true">
		<!-- Kuali STATE -->
		<dict:minOccurs>1</dict:minOccurs>
		<dict:maxOccurs>1</dict:maxOccurs>
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="kuali.meta.data" id="kuali.meta.data" className="Special Class to do this?" serverSide="true">
		<!-- Kuali Meta Data: calculated by service, read-only -->
		<!-- MinOccur on Meta data structures may not 1 not work because it is not supplied  on the create -->
		<dict:minOccurs>1</dict:minOccurs>
		<dict:maxOccurs>1</dict:maxOccurs>
		</dict:constraint>

	<dict:constraint key="related.cluId" id="related.cluId" className="org.kuali.constraint.CluIdExists" serverSide="true">
		<!-- Id of an existing CLU -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="related.clu.set.id" id="related.clu.set.id" className="org.kuali.constraint.CluSetIdExists" serverSide="true">
		<!-- Id of an existing CLU Set Id -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="related.orgId" id="related.orgId" className="org.kuali.constraint.OrgIdExists" serverSide="true">
		<!-- Id of an existing ORG -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="related.principalId" id="related.principalId" className="org.kuali.constraint.PrincipaldExists" serverSide="true">
		<!-- Id of an existing PRINCIPAL -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="related.personId" id="related.personId" className="org.kuali.constraint.PersonIddExists" serverSide="true">
		<!-- Id of an existing PERSON -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="related.gradekey" id="related.gradekey" className="lu.kuali.constrain.gradeExists" serverSide="true">
		<!-- Key of an existing Grade -->
		<!-- Requires special logic to check that the key supplied actuall exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="related.creditkey" id="related.creditkey" className="lu.kuali.constrain.creditExists" serverSide="true">
		<!-- Key of an existing Credit -->
		<!-- Requires special logic to check that the key supplied actuall exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="related.credentialkey" id="related.credentialkey" className="lu.kuali.constrain.credentialExists" serverSide="true">
		<!-- Key of an existin Credential -->
		<!-- Requires special logic to check that the key supplied actuall exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[A-Za-z0-9.-]*</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="related.proposal" id="related.proposal" className="proposal.kuali.constraint.ProposalIdExists" serverSide="true">
		<!-- Id of an existing PROPOSAL -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="related.document" id="related.document" className="document.kuali.constraint.DocumentIdExists" serverSide="true">
		<!-- Id of an existing DOCUMENT -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="lu.types" id="lu.types" serverSide="false">
		<!-- In list of configured learning unit types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.identifier.types" id="lu.identifier.types" serverSide="false">
		<!-- In list of configured clu identifier types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.identifier.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.activity.types" id="lu.activity.types" serverSide="false">
		<!-- In a list of configured activity LuTypes -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.activity.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="duration.types" id="duration.types" serverSide="false">
		<!-- In list of configured duration types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.durationTypes">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="instructional.format.types" id="instructional.format.types" serverSide="false">
		<!-- In list of configured instructional formats -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:lookup search="kuali.enum.type.instructionalFormatTypes">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="season.types" id="season.types" serverSide="false">
		<!-- In list of configured seasons -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.seasonTypes">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="atp.types" id="atp.types" serverSide="false">
		<!-- In list of configured  time period types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.atpTypes">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="dynamic.field.types" id="dynamic.field.types" serverSide="false">
		<!-- In list of configured dynamic field types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.dynamicFieldTypes">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.lu.relation.types" id="lu.lu.relation.types" serverSide="false">
		<!-- In list of configured lul-lu relation types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.lu.relation.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.code.types" id="lu.code.types" serverSide="false">
		<!-- In list of configured classification codes used for LU -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.code.type">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="currency.types" id="currency.types" serverSide="false">
		<!-- In list of configured currency types -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.currency.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lo.types" id="lo.types" serverSide="false">
		<!-- In list of confured lo types -->
		<!-- TO DO: add to SimpleS -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lo.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lo.hierarchies" id="lo.hierarchies" serverSide="false">
		<!-- In list of configured lo hierarchies -->
		<!-- TO DO: add to SimpleS -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lo.hierarchies">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="resultUsage.types" id="resultUsage.types" serverSide="false">
		<!-- In list of confured resultUsage types -->
		<!-- TO DO: add to Simple Spec -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.resultUsage.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="proposal.types" id="proposal.types" serverSide="false">
		<!-- In a list of configured proposal types -->
		<!-- TO DO: add to SimpleS -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.proposal.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="course.proposal.types" id="course.proposal.types" serverSide="false">
		<!-- In a list of configured course proposal types -->
		<!-- TO DO: add to SimpleS -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.course.proposal.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="reference.types" id="reference.types" serverSide="false">
		<!-- In a list of configured reference types -->
		<!-- TO DO: add to SimpleS -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>60</dict:maxLength>
		<dict:lookup search="kuali.enum.type.reference.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.states" id="lu.states" serverSide="false">
		<!-- In list of configured learning unit states -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.states">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.identifier.states" id="lu.identifier.states" serverSide="false">
		<!-- In list of configured clu identifier states -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:lookup search="kuali.enum.type.lu.identifier.states">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="subject.areas" id="subject.areas" serverSide="false">
		<!-- In list of configured subject areas -->
		<dict:minLength>4</dict:minLength>
		<dict:maxLength>4</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[A-Z]*</dict:value>
		</dict:validChars>
		<dict:lookup search="kuali.enum.type.subjectArea">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="available.course.numbers" id="available.course.numbers" serverSide="false">
		<!-- In list of configured available course numbers -->
		<dict:minLength>3</dict:minLength>
		<dict:maxLength>3</dict:maxLength>
		<dict:validChars>
		<dict:value>regex:[0-9]*</dict:value>
		</dict:validChars>
		<dict:lookup search="kuali.enum.type.availableNumbers">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="offering.campuses" id="offering.campuses" serverSide="false">
		<!-- In list of configured offering campuses -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>30</dict:maxLength>
		<dict:lookup search="kuali.enum.type.offeringCampuses">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="unit.types" id="unit.types" serverSide="false">
		<!-- In list of configured unit types -->
		<!-- Although called a type, this is not a formal type in kuali student like an lu type, for example it may be changeable after being added. -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:lookup search="kuali.enum.type.validUnitTypes">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="eye.colors" id="eye.colors" serverSide="false">
		<!-- In a list of configured eye colors -->
		<!-- Blue, Brown, Green, Hazel, etc -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>10</dict:maxLength>
		<dict:lookup search="kuali.enum.type.validEyeColors">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="grade.scales" id="grade.scales" serverSide="false">
		<!-- In a list of configured grading scales -->
		<dict:lookup search="kuali.enum.type.grade.scales">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="effective.date.atps" id="effective.date.atps" serverSide="false">
		<!-- In a list of configured ATPs -->
		<!-- Not entirely sure what to call this. There is also a kuali.enum.type.EffectiveDateATPs defined for the which is backed by this enumeration (its further constrained) but I don't know that it needs to be represented that way. -->
		<dict:lookup search="kuali.enum.type.ATPsByDate">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="hard.coded.type.credit.course" id="hard.coded.type.credit.course" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "kuali.lu.type.CreditCourse" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.CreditCourse</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.type.credit.course.format.shell" id="hard.coded.type.credit.course.format.shell">
		<!-- Must be "kuali.lu.type.CreditCourseFormatShell" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.CreditCourseFormatShell</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.official" id="hard.coded.official" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "kuali.lu.type.CreditCourse.identifier.official" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.CreditCourse\.identifier\.official</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.active" id="hard.coded.active" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "active" -->
		<dict:validChars>
		<dict:value>regex:active</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.cross-listed" id="hard.coded.cross-listed" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "kuali.lu.type.CreditCourse.identifier.cross-listed" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.CreditCourse\.identifier\.cross-listed</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.co-located" id="hard.coded.co-located" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "kuali.lu.relation.type.co-located" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.relation\.type\.co-located</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.lulurelation.courseformat" id="hard.coded.lulurelation.courseformat" serverSide="true">
		<!-- Must be "kuali.lu.lu.relation.type.hasCourseFormat" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kulai\.lu\.lu\.relation\.type\.hasCourseFormat</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.version" id="hard.coded.version" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "kuali.lu.type.CreditCourse.identifier.version" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.CreditCourse\.identifier\.version</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.zero" id="hard.coded.zero" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be 0 -->
		<dict:validChars>
		<dict:value>regex:0</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.one" id="hard.coded.one" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be 1 -->
		<dict:validChars>
		<dict:value>regex:1</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.true" id="hard.coded.true" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be TRUE -->
		<dict:validChars>
		<dict:value>regex:true</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.false" id="hard.coded.false" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be FALSE -->
		<dict:validChars>
		<dict:value>regex:false</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.eye.color" id="hard.coded.eye.color" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "kuali.lu.type.CreditCourse.dynamic.eye.color" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.CreditCourse\.dynamic\.eye\.color</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.left.handed" id="hard.coded.left.handed" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "kuali.lu.type.CreditCourse.dynamic.left.handed" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.lu\.type\.CreditCourse\.dynamic\.left\.handed</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.informal.lo" id="hard.coded.informal.lo" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- must be "kuali.lo.type.informal" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.lo\.type\.informal</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.Instructor-defined.lo.hierarchy" id="hard.coded.Instructor-defined.lo.hierarchy" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "kuali.loHierarchy.key.instructor" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.loHierarchy\.key\.instructor</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.credit.awarded.resultUsage" id="hard.coded.credit.awarded.resultUsage" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- must be "Kuali.resultUsageType.CreditAwarded" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:Kuali\.resultUsageType\.CreditAwarded</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.fixed.credit" id="hard.coded.fixed.credit" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "kuali.resultComponentType.credit.degree.fixed" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.resultComponentType\.credit\.degree\.fixed</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.variable.credit" id="hard.coded.variable.credit" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "kuali.resultComponentType.credit.degree.range" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.resultComponentType\.credit\.degree\.range</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.final.grade" id="hard.coded.final.grade" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be"kuali.resultComponentType.finalGrade" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.resultComponentType\.finalGrade</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.academic.credit" id="hard.coded.academic.credit" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "kuali.creditType.credit.degree" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.creditType\.credit\.degree</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.final.qualitative.result.Usage" id="hard.coded.final.qualitative.result.Usage" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "kuali.resultComponentType.finalQualitative" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.resultComponentType\.finalQualitative</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.final.grad.awarded.resultUsage" id="hard.coded.final.grad.awarded.resultUsage" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "Must be "kuali.resultUsageType.finalGradeAwarded"" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.resultUsageType\.finalGradeAwarded</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.letter.grade" id="hard.coded.letter.grade" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "kuali.gradeType.Letter" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.gradeType\.Letter</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.pass-fail.grade" id="hard.coded.pass-fail.grade" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "kuali.gradeType.Pass-Fail" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.gradeType\.Pass-Fail</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.final.qualitative" id="hard.coded.final.qualitative" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be"kuali.resultComponentType.finalQualitative" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.resultComponentType\.finalQualitative</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.referenceType.CLU" id="hard.coded.referenceType.CLU" className="proposal.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "kuali.referenceType.CLU" -->
		<dict:validChars>
		<dict:value>regex:kuali.referenceType.CLU</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.referenceType.Proposal" id="hard.coded.referenceType.Proposal" className="proposal.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "kuali.referenceType.proposal" -->
		<dict:validChars>
		<dict:value>regex:kuali.referenceType.proposal</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.group.proposal" id="hard.coded.group.proposal" className="proposal.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be "kuali.proposal.type.group" -->
		<dict:validChars>
		<dict:value>regex:kuali.proposal.type.group</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.syllabus" id="hard.coded.syllabus" className="proposal.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be"kuali.proposal.ProposalDocRelationType.syllabus" -->
		<dict:validChars>
		<dict:value>regex:kuali.proposal.ProposalDocRelationType.syllabus</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.other.document" id="hard.coded.other.document" className="proposal.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be"kuali.proposal.ProposalDocRelationType.other" -->
		<dict:validChars>
		<dict:value>regex:kuali.proposal.ProposalDocRelationType.other</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.file" id="hard.coded.file" className="document.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be"kuali.document.type.file" -->
		<dict:validChars>
		<dict:value>regex:kuali.document.type.file</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="hard.coded.course.proposal.doc.category" id="hard.coded.course.proposal.doc.category" className="document.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be"kuali.document.category.courseProposal.Doc.Category" -->
		<dict:validChars>
		<dict:value>regex:kuali.document.category.courseProposal.Doc.Category</dict:value>
		</dict:validChars>
		</dict:constraint>

	<dict:constraint key="has.course.format.relation.lu.types" id="has.course.format.relation.lu.types" serverSide="false">
		<!-- constrains the required LuType of the clu referenced by cluCluRelationInfo.cluID for a Has Course Format relation -->
		<!-- TO DO: add the enumeration to simples -->
		<dict:lookup search="kuali.enum.type.validLuTypesForLuLuRelationType">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="is.course.format.relation.lu.types" id="is.course.format.relation.lu.types" serverSide="false">
		<!-- constrains the required LuType of clu referenced by cluCluRelationInfo.relatedCluId for a has course format relation -->
		<!-- TO DO: add the enumeration to simples -->
		<dict:lookup search="kuali.enum.type.validRelatedLuTypesForLuLuRelationType">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="contains.relation.lu.types" id="contains.relation.lu.types" serverSide="false">
		<!-- constrains the required LuType of the clu referenced by cluCluRelationInfo.cluID for a "Contains" relation -->
		<!-- TO DO: add the enumeration to simples -->
		<dict:lookup search="kuali.enum.type.validLuTypesForLuLuRelationType">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="contained.by.relation.lu.types" id="contained.by.relation.lu.types" serverSide="false">
		<!-- constrains the required LuType of the clu referenced by cluCluRelationInfo.relatedCluID for a "Contain" relation -->
		<!-- TO DO: add the enumeration to simples -->
		<dict:lookup search="kuali.enum.type.validRelatedLuTypesForLuLuRelationType">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="valid.duration.types" id="valid.duration.types" serverSide="false">
		<!-- In a list of duration types configured by LuType -->
		<dict:lookup search="kuali.enum.type.ValidDurationTypes">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="valid.atp.types" id="valid.atp.types">
		<!-- In a list of atp types configured by LuType -->
		<!-- TO DO: add this enumeration to the simples -->
		<dict:lookup search="kuali.enum.type.validAtpTypes">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.statement.operators" id="lu.statement.operators" serverSide="false">
		<!-- In list of configured lu statement operators (AND and OR) -->
		<!-- Hard coded to be AND or OR -->
		<dict:lookup search="kuali.enum.type.lu.statement.operators">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.statement.types" id="lu.statement.types" serverSide="false">
		<!-- In list of valid lu statement types -->
		<!-- See LuStatementInfo types defined on the Types tab -->
		<dict:lookup search="kuali.enum.type.lu.statement.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.statement.states" id="lu.statement.states" serverSide="false">
		<!-- In list of valid lu statement states -->
		<!-- See LuStatementInfo states defined on the States tab -->
		<dict:lookup search="kuali.enum.type.lu.statement.states">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="related.luStatementd" id="related.luStatementd" className="org.kuali.constraint.LuStatementIdExists" serverSide="true">
		<!-- Id of an existing LU Statement -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="related.requirementComponentId" id="related.requirementComponentId" className="org.kuali.constraint.RequirementComponentIdExists" serverSide="true">
		<!-- Id of an existing requirement component -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="lu.requirement.component.types" id="lu.requirement.component.types" serverSide="false">
		<!-- In list of valid lu requirement component types -->
		<!-- See reqComponentInfo types defined on the Types tab -->
		<dict:lookup search="kuali.enum.type.lu.requirement.component.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="dictionary.field.descriptor.field.types" id="dictionary.field.descriptor.field.types" serverSide="false">
		<!-- In list of valid data types fof fields that are supported by the validator -->
		<!-- Valid values are: complex, string, date, dateTime, boolean, integer, & long -->
		<dict:lookup search="kuali.enum.type.dictionary.field.descriptor.field.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="dictionary.enumeration.keys" id="dictionary.enumeration.keys" serverSide="false">
		<!-- In list of the keys for all valid enumerations known to the system -->
		<!-- See the lookup column of this spreadsheet!!!!! -->
		<dict:lookup search="kuali.enum.type.dictionary.enumeration.type.keys">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="dictionary.enumeration.context.keys" id="dictionary.enumeration.context.keys" serverSide="false">
		<!-- In list of the keys for all valid enumeration contexts known to the system -->
		<!-- See the lookupContext column of this spreadsheet!!!!! -->
		<dict:lookup search="kuali.enum.type.dictionary.enumeration.context.type.keys">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.requirement.component.states" id="lu.requirement.component.states" serverSide="false">
		<!-- In list of valid lu requirement component states -->
		<!-- See reqComponentInfo states defined on the States tab -->
		<dict:lookup search="kuali.enum.type.lu.requirement.component.states">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lu.requirement.component.field.keys" id="lu.requirement.component.field.keys" serverSide="false">
		<!-- In list of valid lu requirement component field keys -->
		<!-- See the reqCompFieldTypeInfo keys defined on the Types tab -->
		<dict:lookup search="kuali.enum.type.lu.requirement.component.field.keys">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="search.types" id="search.types" serverSide="false">
		<!-- In list of valid search types -->
		<!-- See all the searches defined in the simple specs -->
		<dict:lookup search="kuali.enum.type.search.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="query.param.value.types" id="query.param.value.types" serverSide="false">
		<!-- In list of valid query parameter types for searches -->
		<!-- See all the searches defined in the simple specs -->
		<dict:lookup search="kuali.enum.type.query.param.value.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lrd.types" id="lrd.types" serverSide="false">
		<!-- In list of valid learning result definition types -->
		<!-- See the lrd types defined in this spreadsheet -->
		<dict:lookup search="kuali.enum.type.lrc.lrd.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="learning.result.scale.types" id="learning.result.scale.types" serverSide="false">
		<!-- In list of valid learning result scale types -->
		<!-- See the scale types defined in this spreadsheet -->
		<dict:lookup search="kuali.enum.type.lrc.scale.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="lrd.operators" id="lrd.operators" serverSide="false">
		<!-- In list of configured learning result definition operators (=, >, < etc) -->
		<!-- Hard coded to be equal_to, not_equal_to, greater_than, less_than, greater_than_or_equal_to, less_than_or_equal_to -->
		<dict:lookup search="kuali.enum.type.lrd.operators">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="related.lrdId" id="related.lrdId" className="org.kuali.constraint.LearningResultDefinitionIdExists" serverSide="true">
		<!-- Id of an existing learning result definition -->
		<!-- Requires special logic to check that the ID supplied actually exists -->
		<dict:minLength>1</dict:minLength>
		<dict:maxLength>36</dict:maxLength>
		</dict:constraint>

	<dict:constraint key="hard.coded.credit.course.clu" id="hard.coded.credit.course.clu" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be"kuali.reqCompFieldType.credit.course" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.reqCompFieldType\.credit\.course</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.credit.course.clu.set" id="hard.coded.credit.course.clu.set" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be"kuali.reqCompFieldType.credit.course.set" -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.reqCompFieldType\.credit\.course\.set</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.required.count" id="hard.coded.required.count" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be"kuali.reqCompFieldType.requiredCount" -->
<!-- 
    	<dict:validChars>
		<dict:value>regex:kuali\.reqCompFieldType\.requiredCount</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.lrd.credit.course.final.grade" id="hard.coded.lrd.credit.course.final.grade" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be"kuali.reqCompFieldType. -->
<!-- 
    	<dict:validChars>
		<dict:value>regex:kuali\.reqCompFieldType\.lrd\.credit\.course\.final\.grade</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.overall.gpa" id="hard.coded.overall.gpa" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be"kuali.reqCompFieldType. -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.reqCompFieldType\.overall\.gpa</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.overall.totalCredits" id="hard.coded.overall.totalCredits" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be"kuali.reqCompFieldType. -->
<!-- 
	<dict:validChars>
		<dict:value>regex:kuali\.reqCompFieldType\.overall\.totalCredits</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.operator" id="hard.coded.operator" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be"kuali.reqCompFieldType. -->
<!-- 
		<dict:validChars>
		<dict:value>regex:kuali\.reqCompFieldType\.operator</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="hard.coded.countType" id="hard.coded.countType" className="org.kuali.constraint.HardCodedValue" serverSide="true">
		<!-- Must be"kuali.reqCompFieldType. -->
<!--
 		<dict:validChars>
		<dict:value>regex:kuali\.reqCompFieldType\.countType</dict:value>
		</dict:validChars>
-->
		</dict:constraint>

	<dict:constraint key="clu.set.types" id="clu.set.types" serverSide="false">
		<!-- In list of valid clu set types -->
		<!-- See cluSetInfo states defined on the Types tab -->
		<dict:lookup search="kuali.enum.type.lu.clu.set.types">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="clu.set.states" id="clu.set.states" serverSide="false">
		<!-- In list of valid clu set states -->
		<!-- See cluSetInfo states defined on the States tab -->
		<dict:lookup search="kuali.enum.type.lu.clu.set.states">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>

	<dict:constraint key="valid.credit.course.clu.set.search.types" id="valid.credit.course.clu.set.search.types" serverSide="false">
		<!-- In list of search times that return credit courses or clu sets of credit courses -->
		<!-- Has just one value for now and that is "kuali.lu.searchTypes.CoursesForDynamicCLUSet" but that will expand in the future. -->
		<dict:lookup search="kuali.enum.search.type.credit.course">
		<dict:lookupKey field="(none)" mapsTo="(none)"/>
		</dict:lookup>
		</dict:constraint>
	
	<dict:objectStructure key="cluInfo">
		<!-- Detailed information about a single CLU. -->
		<dict:type key="kuali.lu.type.CreditCourse">
		<!-- A course offered for academic credit -->
		<!-- Subject, Academic Course -->
			<dict:state key="template">
			<!-- A template holds configuration for defaults for creating a new course -->
				
				<dict:field id="course.official" key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>course no</dict:name>
						<dict:desc>course no</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="cluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										
										<dict:field id="course.official.no" key="code">
											<dict:fieldDescriptor>
												<dict:name>course official no</dict:name>
												<dict:desc>course number</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="calc.course.no"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.transcriptTitle" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course official transcriptTitle</dict:name>
												<dict:desc>transcript title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<!-- 
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraint key="in-line.constraint.for.dictionary.course.official.transcriptTitle">
														<dict:maxLength>20</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.catalogTitle" key="longName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course official catalogTitle</dict:name>
												<dict:desc>catalog title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<!-- 
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraint key="in-line.constraint.for.dictionary.course.official.catalogTitle">
														<dict:maxLength>60</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.level" key="level">
											<dict:fieldDescriptor>
												<dict:name>course official level</dict:name>
												<dict:desc>level</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.subjectArea" key="division">
											<dict:fieldDescriptor>
												<dict:name>course official subjectArea</dict:name>
												<dict:desc>subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.numberPart" key="suffixCode">
											<dict:fieldDescriptor>
												<dict:name>course official numberPart</dict:name>
												<dict:desc>number part of the course number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="available.course.numbers"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.version" key="variation">
											<dict:fieldDescriptor>
												<dict:name>course official version</dict:name>
												<dict:desc>version code</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.adminOrg" key="orgId">
											<dict:fieldDescriptor>
												<dict:name>course official adminOrg</dict:name>
												<dict:desc>dept</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.orgId"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.type" key="type">
											<!-- Required when first adding but read-only thereafter -->
											<dict:fieldDescriptor>
												<dict:name>course official type</dict:name>
												<dict:desc>official</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="lu.identifier.types"/>
													<dict:constraintRef bean="hard.coded.official"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.state" key="state">
											<dict:fieldDescriptor>
												<dict:name>course official state</dict:name>
												<dict:desc>state</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.state"/>
													<dict:constraintRef bean="lu.identifier.states"/>
													<dict:constraintRef bean="hard.coded.active"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.internal.id" key="id">
											<!-- should be blank when first adding but required thereafter for updates -->
											<dict:fieldDescriptor>
												<dict:name>course official internalId</dict:name>
												<dict:desc>internal id of this id</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.id"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.official.no"/>
										<dict:fieldRef bean="course.official.transcriptTitle"/>
										<dict:fieldRef bean="course.official.catalogTitle"/>
										<dict:fieldRef bean="course.official.level"/>
										<dict:fieldRef bean="course.official.subjectArea"/>
										<dict:fieldRef bean="course.official.numberPart"/>
										<dict:fieldRef bean="course.official.version"/>
										<dict:fieldRef bean="course.official.adminOrg"/>
										<dict:fieldRef bean="course.official.type"/>
										<dict:fieldRef bean="course.official.state"/>
										<dict:fieldRef bean="course.official.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
					       <!-- 
							<dict:constraintRef bean="required"/>
							-->
							<dict:constraintRef bean="single"/>
							<dict:constraint key="exactly.one.official.identifier" id="exactly.one.official.identifier">
							<dict:typeStateCase>
								<dict:typeStateWhen type="kuali.lu.type.CreditCourse.identifier.official">
								<!-- For a Credit Course, constrains that the type of the identifier for the official identifier is always "official" -->
									<dict:minOccurs>1</dict:minOccurs>
									<dict:maxOccurs>1</dict:maxOccurs>
								</dict:typeStateWhen>
							</dict:typeStateCase>
							</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.alternateIdentifiers" key="alternateIdentifiers">
					<dict:fieldDescriptor>
						<dict:name>course alternateIdentifiers</dict:name>
						<dict:desc>course alternate ids</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="cluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.cross-listed">
								<!-- This identifier holds the cross-listed identifiers for this course -->
								<!-- (MIT's meaning of joint) -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										
										<dict:field id="course.cross-listed.no" key="code">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed no</dict:name>
												<dict:desc>cross-listed number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="calc.course.no"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.transcriptTitle" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course cross-listed transcriptTitle</dict:name>
												<dict:desc>not used</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<!-- 
													<dict:constraintRef bean="single.line.text"/>
													-->
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.catalogTitle" key="longName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course cross-listed catalogTitle</dict:name>
												<dict:desc>not used</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<!-- 
													<dict:constraintRef bean="single.line.text"/>
													-->
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.level" key="level">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed level</dict:name>
												<dict:desc>not used</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.subjectArea" key="division">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed subjectArea</dict:name>
												<dict:desc>cross-listed subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.numberPart" key="suffixCode">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed numberPart</dict:name>
												<dict:desc>number part of cross-listed number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="available.course.numbers"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.version" key="variation">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed version</dict:name>
												<dict:desc>not used</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.adminOrg" key="orgId">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed adminOrg</dict:name>
												<dict:desc>cross-listed department</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.orgId"/>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.type" key="type">
											<!-- Required when first adding but read-only thereafter -->
											<dict:fieldDescriptor>
												<dict:name>course cross-listed type</dict:name>
												<dict:desc>cross-listed</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="lu.identifier.types"/>
													<dict:constraintRef bean="hard.coded.cross-listed"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.state" key="state">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed state</dict:name>
												<dict:desc>state</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.state"/>
													<dict:constraintRef bean="lu.identifier.states"/>
													<dict:constraintRef bean="default.active"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.internal.id" key="id">
											<!-- should be blank when first adding but required thereafter for updates -->
											<dict:fieldDescriptor>
												<dict:name>course cross-listed internalId</dict:name>
												<dict:desc>internal id of cross-listed id</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.id"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.cross-listed.no"/>
										<dict:fieldRef bean="course.cross-listed.transcriptTitle"/>
										<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
										<dict:fieldRef bean="course.cross-listed.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea"/>
										<dict:fieldRef bean="course.cross-listed.numberPart"/>
										<dict:fieldRef bean="course.cross-listed.version"/>
										<dict:fieldRef bean="course.cross-listed.adminOrg"/>
										<dict:fieldRef bean="course.cross-listed.type"/>
										<dict:fieldRef bean="course.cross-listed.state"/>
										<dict:fieldRef bean="course.cross-listed.internal.id"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!-- This identifier holds the version information for courses that have multiple versions -->
								<!-- Variation -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										
										<dict:field id="course.version.no" key="code">
											<!-- calculated by concatenating the subject Area, numberPart and version code. -->
											<dict:fieldDescriptor>
												<dict:name>course version no</dict:name>
												<dict:desc>version number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="calc.course.no"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.transcriptTitle" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course version transcriptTitle</dict:name>
												<dict:desc>Version Title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<!-- 
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraint key="in-line.constraint.for.dictionary.course.version.transcriptTitle">
														<dict:maxLength>20</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.catalogTitle" key="longName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course version catalogTitle</dict:name>
												<dict:desc>not used</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<!-- 
													<dict:constraintRef bean="single.line.text"/>
													-->
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.level" key="level">
											<dict:fieldDescriptor>
												<dict:name>course version level</dict:name>
												<dict:desc>not used</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.subjectArea" key="division">
											<!-- set to the official number's subjectArea -->
											<dict:fieldDescriptor>
												<dict:name>course version subjectArea</dict:name>
												<dict:desc>subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="calc.copy.course.official.subjectArea"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.numberPart" key="suffixCode">
											<!-- set to the official number's numberPart -->
											<dict:fieldDescriptor>
												<dict:name>course version numberPart</dict:name>
												<dict:desc>number part of course number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="calc.copy.course.official.numberPart"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.version" key="variation">
											<dict:fieldDescriptor>
												<dict:name>course version version</dict:name>
												<dict:desc>version code</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="code.uppercase"/>
													<dict:constraintRef bean="letter"/>
													<dict:constraintRef bean="size.one"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.adminOrg" key="orgId">
											<dict:fieldDescriptor>
												<dict:name>course version adminOrg</dict:name>
												<dict:desc>not used</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.orgId"/>
													<dict:constraintRef bean="not.used"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.type" key="type">
											<!-- Required when first adding but read-only thereafter -->
											<dict:fieldDescriptor>
												<dict:name>course version type</dict:name>
												<dict:desc>version</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="lu.identifier.types"/>
													<dict:constraintRef bean="hard.coded.version"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.state" key="state">
											<dict:fieldDescriptor>
												<dict:name>course version state</dict:name>
												<dict:desc>state</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.state"/>
													<dict:constraintRef bean="lu.identifier.states"/>
													<dict:constraintRef bean="hard.coded.active"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.internal.id" key="id">
											<!-- should be blank when first adding but required thereafter for updates -->
											<dict:fieldDescriptor>
												<dict:name>course version internalId</dict:name>
												<dict:desc>internal id of this course version</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.id"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.version.no"/>
										<dict:fieldRef bean="course.version.transcriptTitle"/>
										<dict:fieldRef bean="course.version.catalogTitle"/>
										<dict:fieldRef bean="course.version.level"/>
										<dict:fieldRef bean="course.version.subjectArea"/>
										<dict:fieldRef bean="course.version.numberPart"/>
										<dict:fieldRef bean="course.version.version"/>
										<dict:fieldRef bean="course.version.adminOrg"/>
										<dict:fieldRef bean="course.version.type"/>
										<dict:fieldRef bean="course.version.state"/>
										<dict:fieldRef bean="course.version.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraint key="zero.or.more.cross-listed.identifiers.zero.or.more.version.identifiers" id="zero.or.more.cross-listed.identifiers.zero.or.more.version.identifiers">
							<dict:typeStateCase>
								<dict:typeStateWhen type="kuali.lu.type.CreditCourse.identifier.cross-listed">
								<!-- For a Credit Course, constrains that there be zero or more cross-listed identfiers -->
									<dict:minOccurs>0</dict:minOccurs>
									<dict:maxOccurs>(unbounded)</dict:maxOccurs>
								</dict:typeStateWhen>
								<dict:typeStateWhen type="kuali.lu.type.CreditCourse.identifier.version">
								<!-- For a Credit Course, constrains that there be zero or more version identifiers -->
									<dict:minOccurs>0</dict:minOccurs>
									<dict:maxOccurs>(unbounded)</dict:maxOccurs>
								</dict:typeStateWhen>
							</dict:typeStateCase>
							</dict:constraint>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.academicSubjectOrgs" key="academicSubjectOrgs">
					<dict:fieldDescriptor>
						<dict:name>course academicSubjectOrgs</dict:name>
						<dict:desc>course ademicSubjectOrgs</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<!-- <dict:constraintRef bean="not.used"/> -->
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.studySubjectArea" key="studySubjectArea">
					<dict:fieldDescriptor>
						<dict:name>course studySubjectArea</dict:name>
						<dict:desc>course studySubjectArea</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="code"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.desc.template" key="desc">
					<dict:fieldDescriptor>
						<dict:name>course desc</dict:name>
						<dict:desc>dscription</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="richTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.desc.plain" key="plain">
											<!-- calculated by stripping out formatting -->
											<dict:fieldDescriptor>
												<dict:name>course desc plain</dict:name>
												<dict:desc>plain text version description of course</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.desc.plain">
														<dict:maxLength>14000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.desc.formatted" key="formatted">
											<dict:fieldDescriptor>
												<dict:name>course desc formatted</dict:name>
												<dict:desc>rich text version of the course description</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.desc.formatted">
														<dict:maxLength>14000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.rationale" key="marketingDesc">
					<!-- Rationale is stored in the Marketing Description for now -->
					<dict:fieldDescriptor>
						<dict:name>course rationale</dict:name>
						<dict:desc>rationale</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="richTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.rationale.plain" key="plain">
											<!-- calculated by stripping out formatting -->
											<dict:fieldDescriptor>
												<dict:name>course rationale plain</dict:name>
												<dict:desc>plain text version of rationale</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.rationale.plain">
														<dict:maxLength>14000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.rationale.formatted" key="formatted">
											<!-- the rationale is stored in the marketing description for now -->
											<dict:fieldDescriptor>
												<dict:name>course rationale formatted</dict:name>
												<dict:desc>rich text version of rationale</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.rationale.formatted">
														<dict:maxLength>14000</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<!-- 
							<dict:constraintRef bean="required"/>
							-->
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.campusLocation" key="campusLocationList">
					<dict:fieldDescriptor>
						<dict:name>course campusLocation</dict:name>
						<dict:desc>campus location</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="code"/>
							<!-- 
							<dict:constraintRef bean="required"/>
							-->
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.accreditation" key="accreditation">
					<dict:fieldDescriptor>
						<dict:name>course accreditation</dict:name>
						<dict:desc>course accreditation</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.primaryAdminOrg" key="primaryAdminOrg">
					<dict:fieldDescriptor>
						<dict:name>course primaryAdminOrg</dict:name>
						<dict:desc>department</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="adminOrgInfo">
								<!-- Information about an organization acting in administrative capacity for a learning unit. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.primaryAdminOrg.Id" key="orgId">
											<dict:fieldDescriptor>
												<dict:name>course primaryAdminOrg Id</dict:name>
												<dict:desc>Org Id of the primary administrative department</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.orgId"/>
											</dict:constraintDescriptor>
											<dict:selector>true</dict:selector>
										</dict:field>
										
										<dict:field id="course.primaryAdminOrg.attributes" key="attributes">
											<dict:fieldDescriptor>
												<dict:name>course primaryAdminOrg attributes</dict:name>
												<dict:desc>dynamic attributes qualifying the primary admin org</dict:desc>
												<dict:dataType>complex</dict:dataType>
													
													<dict:objectStructure key="attributeInfo">
														<!-- List of key/value pairs, typically used for dynamic attributes. -->
														<dict:type key="kuali.lu.type.CreditCourse.dynamic.left.handed">
														<!-- Captures if the students are expected to be left handed who take this course -->
															<dict:state key="(n/a)">
															<!-- Not applicable -->
																
																<dict:field id="course.primaryAdminOrg.attributes.left.handed.key" key="key">
																	<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
																	<dict:fieldDescriptor>
																		<dict:name>course primaryAdminOrg attributes left handed key</dict:name>
																		<dict:desc>Key to capture if the students are expected to be left handed who take this course</dict:desc>
																		<dict:dataType>string</dict:dataType>
																		<dict:readOnly>true</dict:readOnly>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<!-- 
																			<dict:constraintRef bean="required"/>
																			-->
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="kuali.type"/>
																			<dict:constraintRef bean="dynamic.field.types"/>
																			<dict:constraintRef bean="hard.coded.left.handed"/>
																			<dict:constraintRef bean="read.only"/>
																	</dict:constraintDescriptor>
																	<dict:dynamic>true</dict:dynamic>
																</dict:field>
																
																<dict:field id="course.primaryAdminOrg.attributes.left.handed.value" key="value">
																	<dict:fieldDescriptor>
																		<dict:name>course primaryAdminOrg attributes left handed value</dict:name>
																		<dict:desc>Value of the students are expected to be left handed who take this course</dict:desc>
																		<dict:dataType>string</dict:dataType>
																	</dict:fieldDescriptor>
																	<dict:constraintDescriptor>
																			<!-- 
																			<dict:constraintRef bean="required"/>
																			-->
																			<dict:constraintRef bean="single"/>
																			<dict:constraintRef bean="boolean"/>
																			<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
																				<dict:maxLength>(unbounded)</dict:maxLength>
																				</dict:constraint>
																	</dict:constraintDescriptor>
																	<dict:dynamic>true</dict:dynamic>
																</dict:field>
															</dict:state>
														</dict:type>
													</dict:objectStructure>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="repeating"/>
													<dict:constraintRef bean="single"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.primaryAdminOrg.attributes">
														<dict:maxOccurs>20</dict:maxOccurs>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<!-- 
							<dict:constraintRef bean="required"/>
							-->
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.alternateAdminOrgs" key="alternateAdminOrgs">
					<dict:fieldDescriptor>
						<dict:name>course alternateAdminOrgs</dict:name>
						<dict:desc>not used</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.primaryInstructor" key="primaryInstructor">
					<dict:fieldDescriptor>
						<dict:name>course primaryInstructor</dict:name>
						<dict:desc>course primaryInstructor</dict:desc>
						<dict:dataType>complex</dict:dataType>
						<dict:objectStructure key="cluInstructorInfo">
							<dict:type key="kuali.not.applicable">
								<dict:state key="(n/a)">
										<dict:field id="course.primaryInstructor.Id" key="personId">
											<dict:fieldDescriptor>
												<dict:name>course primaryInstructor Id</dict:name>
												<dict:desc>person Id of the primary instructor</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
										</dict:field>									
								</dict:state>
							</dict:type>
						</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.instructors" key="instructors">
					<dict:fieldDescriptor>
						<dict:name>course instructors</dict:name>
						<dict:desc>course instructors</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.expectedFirstAtp" key="expectedFirstAtp">
					<dict:fieldDescriptor>
						<dict:name>course expectedFirstAtp</dict:name>
						<dict:desc>course expectedFirstAtp</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="atp.types"/>
							<!-- 
							<dict:constraintRef bean="required"/>
							-->
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>course effectiveDate</dict:name>
						<dict:desc>first date can be offered</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<!-- 
							<dict:constraintRef bean="required"/>
							-->
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>course expirationDate</dict:name>
						<dict:desc>last date can be offerred</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.total.contact.hours" key="intensity">
					<!-- This doesn't exist on the UI but I know that someone soon will want to have the system calculate the total contact hours for the course and this is where that calculation should be stored -->
					<dict:fieldDescriptor>
						<dict:name>course contact hours</dict:name>
						<dict:desc>contact hours</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.duration" key="stdDuration">
					<dict:fieldDescriptor>
						<dict:name>course duration</dict:name>
						<dict:desc>duration</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="timeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.duration.units" key="atpDurationTypeKey">
											<!-- services has this flagged as mandatory but don't think it shoujld be because in a draft state a user may specify the units but not yet specify the amount -->
											<dict:fieldDescriptor>
												<dict:name>course duration units</dict:name>
												<dict:desc>Units in which the duration of the course is expressed</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="duration.types"/>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="valid.duration.types"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.duration.no" key="timeQuantity">
											<!-- services has this flagged as mandatory but don't think it shoujld be because in a draft state a user may specify the amount but not yet specify the units because they are unsure but we still need to save -->
											<!-- How do we add a min and max VALUE limit (not min and max size and occurrence) -->
											<dict:fieldDescriptor>
												<dict:name>course duration no</dict:name>
												<dict:desc>number of the duration units</dict:desc>
												<dict:dataType>integer</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="integer"/>
													<dict:constraintRef bean="hard.coded.one"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<!-- 
							<dict:constraintRef bean="required"/>
							-->
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.canCreateLui" key="canCreateLui">
					<dict:fieldDescriptor>
						<dict:name>course canCreateLui</dict:name>
						<dict:desc>course canCreateLui</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.referenceURL" key="referenceURL">
					<dict:fieldDescriptor>
						<dict:name>course referenceURL</dict:name>
						<dict:desc>course referenceURL</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="url"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.luCodes" key="luCodes">
					<dict:fieldDescriptor>
						<dict:name>course luCodes</dict:name>
						<dict:desc>course luCodes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.publishingInfo" key="publishingInfo">
					<dict:fieldDescriptor>
						<dict:name>course publishingInfo</dict:name>
						<dict:desc>course publishingInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.nextReviewPeriod" key="nextReviewPeriod">
					<dict:fieldDescriptor>
						<dict:name>course nextReviewPeriod</dict:name>
						<dict:desc>course nextReviewPeriod</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="atp.types"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.isEnrollable" key="isEnrollable">
					<!-- defaults to TRUE -->
					<dict:fieldDescriptor>
						<dict:name>course isEnrollable</dict:name>
						<dict:desc>course isEnrollable</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<!-- 
							<dict:constraintRef bean="required"/>
							-->
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="default.true"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.seasons" key="offeredAtpTypes">
					<!-- Services has this as an atpKeyList but that is just a list of Strings so I didn't create the sub-structure -->
					<dict:fieldDescriptor>
						<dict:name>course seasons</dict:name>
						<dict:desc>seasons offered</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="atp.types"/>
							<!-- 
							<dict:constraintRef bean="required"/>
							-->
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.hasEarlyDropDeadline" key="hasEarlyDropDeadline">
					<dict:fieldDescriptor>
						<dict:name>course hasEarlyDropDeadline</dict:name>
						<dict:desc>course hasEarlyDropDeadline</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.defaultEnrollmentEstimate" key="defaultEnrollmentEstimate">
					<dict:fieldDescriptor>
						<dict:name>course defaultEnrollmentEstimate</dict:name>
						<dict:desc>course defaultEnrollmentEstimate</dict:desc>
						<dict:dataType>integer</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="non-negative.integer"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.defaultMaximumEnrollment" key="defaultMaximumEnrollment">
					<dict:fieldDescriptor>
						<dict:name>course defaultMaximumEnrollment</dict:name>
						<dict:desc>course defaultMaximumEnrollment</dict:desc>
						<dict:dataType>integer</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="non-negative.integer"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.isHazardousForDisabledStudents" key="isHazardousForDisabledStudents">
					<dict:fieldDescriptor>
						<dict:name>course isHazardousForDisabledStudents</dict:name>
						<dict:desc>course isHazardousForDisabledStudents</dict:desc>
						<dict:dataType>boolean</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="boolean"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.feeInfo" key="feeInfo">
					<dict:fieldDescriptor>
						<dict:name>course feeInfo</dict:name>
						<dict:desc>course feeInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.accountingInfo" key="accountingInfo">
					<dict:fieldDescriptor>
						<dict:name>course accountingInfo</dict:name>
						<dict:desc>course accountingInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.dynamic.attributes" key="attributes">
					<!-- Services has this as an attributeInfoList but that is just a list of the attributeInfo substructure so I did't create the intermediary list sub-structure -->
					<dict:fieldDescriptor>
						<dict:name>course dynamic attributes</dict:name>
						<dict:desc>Eye color and Left Handed</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="attributeInfo">
								<!-- List of key/value pairs, typically used for dynamic attributes. -->
								<dict:type key="kuali.lu.type.CreditCourse.dynamic.eye.color">
								<!-- Captures the eye color of students expected to take this course -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.attributes.eye.color.key" key="key">
											<!-- Shouldn't this be a "type" not a "key"?  I type describes the value, a key is just a pointer. -->
											<dict:fieldDescriptor>
												<dict:name>course attributes eye color key</dict:name>
												<dict:desc>Key to capture the eye color of students expected to take this course</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="kuali.type"/>
													<dict:constraintRef bean="dynamic.field.types"/>
													<dict:constraintRef bean="hard.coded.eye.color"/>
													<dict:constraintRef bean="read.only"/>
											</dict:constraintDescriptor>
											<dict:dynamic>true</dict:dynamic>
										</dict:field>
										
										<dict:field id="course.attributes.eye.color.value" key="value">
											<dict:fieldDescriptor>
												<dict:name>course attributes eye color value</dict:name>
												<dict:desc>Value of the eye color of students expected to take this course</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="eye.colors"/>
													<dict:constraint key="in-line.constraint.for.field.attributeInfo.value">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
											<dict:dynamic>true</dict:dynamic>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.meta" key="metaInfo">
					<!-- must be empty on create but required on update -->
					<dict:fieldDescriptor>
						<dict:name>course meta</dict:name>
						<dict:desc>audit trail info</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="metaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>course meta versionInd</dict:name>
												<dict:desc>Version number for this course info</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="required"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>course meta createTime</dict:name>
												<dict:desc>Date-time this course was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>course meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this course</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>course meta updateTime</dict:name>
												<dict:desc>Date-time this course was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>course meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this course</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.type" key="type">
					<!-- Requierd on the create but read-only after that -->
					<dict:fieldDescriptor>
						<dict:name>course type</dict:name>
						<dict:desc>type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<!-- 
							<dict:constraintRef bean="required"/>
							-->
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.type"/>
							<dict:constraintRef bean="lu.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>course state</dict:name>
						<dict:desc>state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<!-- 
							<dict:constraintRef bean="required"/>
							-->
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
							<dict:constraintRef bean="lu.states"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="course.internal.id" key="id">
					<!-- must be empty on create but required on update -->
					<dict:fieldDescriptor>
						<dict:name>course internalId</dict:name>
						<dict:desc>internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
						<dict:readOnly>true</dict:readOnly>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="read.only"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="draft">
			<!-- Entered as draft but not yet submitted -->
				
				<dict:field key="officialIdentifier">
					<dict:fieldDescriptor>
						<dict:name>course no</dict:name>
						<dict:desc>course no</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="cluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.official">
								<!-- This identifier holds the official identifier for this course -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.official.no"/>
										
										<dict:field id="course.official.transcriptTitle.draft" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course official transcriptTitle</dict:name>
												<dict:desc>transcript title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<!-- 
													<dict:constraintRef bean="single.line.text"/>
													-->
													<dict:constraintRef bean="optional"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.official.transcriptTitle.draft">
														<dict:maxLength>250</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.catalogTitle.draft" key="longName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course official catalogTitle</dict:name>
												<dict:desc>catalog title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<!-- 
													<dict:constraintRef bean="single.line.text"/>
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraint key="in-line.constraint.for.dictionary.course.official.catalogTitle.draft">
														<dict:maxLength>250</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.official.level"/>
										
										<dict:field id="course.official.subjectArea.draft" key="division">
											<dict:fieldDescriptor>
												<dict:name>course official subjectArea</dict:name>
												<dict:desc>subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.official.numberPart.draft" key="suffixCode">
											<dict:fieldDescriptor>
												<dict:name>course official numberPart</dict:name>
												<dict:desc>number part of the course number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="available.course.numbers"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.official.version"/>
										<dict:fieldRef bean="course.official.adminOrg"/>
										<dict:fieldRef bean="course.official.type"/>
										<dict:fieldRef bean="course.official.state"/>
										<dict:fieldRef bean="course.official.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.official.no"/>
										<dict:fieldRef bean="course.official.transcriptTitle.draft"/>
										<dict:fieldRef bean="course.official.catalogTitle.draft"/>
										<dict:fieldRef bean="course.official.level"/>
										<dict:fieldRef bean="course.official.subjectArea.draft"/>
										<dict:fieldRef bean="course.official.numberPart.draft"/>
										<dict:fieldRef bean="course.official.version"/>
										<dict:fieldRef bean="course.official.adminOrg"/>
										<dict:fieldRef bean="course.official.type"/>
										<dict:fieldRef bean="course.official.state"/>
										<dict:fieldRef bean="course.official.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<!-- 
							<dict:constraintRef bean="required"/>
							-->
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="exactly.one.official.identifier"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field key="alternateIdentifiers">
					<dict:fieldDescriptor>
						<dict:name>course alternateIdentifiers</dict:name>
						<dict:desc>course alternate ids</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="cluIdentifierInfo">
								<!-- Detailed information about the human readable form of a CLU Identifier -->
								<dict:type key="kuali.lu.type.CreditCourse.identifier.cross-listed">
								<!-- This identifier holds the cross-listed identifiers for this course -->
								<!-- (MIT's meaning of joint) -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.cross-listed.no"/>
										
										<dict:field id="course.version.transcriptTitle.draft" key="shortName">
											<!-- services says this is mandatory but that might only be true if the type is "official" on other types of ID's such as cross-listed doesn't have any name associated with it -->
											<dict:fieldDescriptor>
												<dict:name>course version transcriptTitle</dict:name>
												<dict:desc>Version Title</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<!-- 
													<dict:constraintRef bean="single.line.text"/>
													-->
													<dict:constraintRef bean="optional"/>
													<dict:constraint key="in-line.constraint.for.dictionary.course.version.transcriptTitle.draft">
														<dict:maxLength>250</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
										<dict:fieldRef bean="course.cross-listed.level"/>
										
										<dict:field id="course.cross-listed.subjectArea.draft" key="division">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed subjectArea</dict:name>
												<dict:desc>cross-listed subject area</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="subject.areas"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.numberPart.draft" key="suffixCode">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed numberPart</dict:name>
												<dict:desc>number part of cross-listed number</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="available.course.numbers"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.version.version.draft" key="variation">
											<dict:fieldDescriptor>
												<dict:name>course version version</dict:name>
												<dict:desc>version code</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="code"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="code.uppercase"/>
													<dict:constraintRef bean="letter"/>
													<dict:constraintRef bean="size.one"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.cross-listed.adminOrg.draft" key="orgId">
											<dict:fieldDescriptor>
												<dict:name>course cross-listed adminOrg</dict:name>
												<dict:desc>cross-listed department</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.orgId"/>
													<dict:constraintRef bean="optional"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.cross-listed.type"/>
										<dict:fieldRef bean="course.cross-listed.state"/>
										<dict:fieldRef bean="course.cross-listed.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.cross-listed.no"/>
										<dict:fieldRef bean="course.version.transcriptTitle.draft"/>
										<dict:fieldRef bean="course.cross-listed.catalogTitle"/>
										<dict:fieldRef bean="course.cross-listed.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea.draft"/>
										<dict:fieldRef bean="course.cross-listed.numberPart.draft"/>
										<dict:fieldRef bean="course.version.version.draft"/>
										<dict:fieldRef bean="course.cross-listed.adminOrg.draft"/>
										<dict:fieldRef bean="course.cross-listed.type"/>
										<dict:fieldRef bean="course.cross-listed.state"/>
										<dict:fieldRef bean="course.cross-listed.internal.id"/>
									</dict:state>
								</dict:type>
								<dict:type key="kuali.lu.type.CreditCourse.identifier.version">
								<!-- This identifier holds the version information for courses that have multiple versions -->
								<!-- Variation -->
									<dict:state key="active">
									<!-- Identifier is active -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.version.no"/>
										<dict:fieldRef bean="course.version.transcriptTitle.draft"/>
										<dict:fieldRef bean="course.version.catalogTitle"/>
										<dict:fieldRef bean="course.version.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea.draft"/>
										<dict:fieldRef bean="course.cross-listed.numberPart.draft"/>
										<dict:fieldRef bean="course.version.version.draft"/>
										<dict:fieldRef bean="course.cross-listed.adminOrg.draft"/>
										<dict:fieldRef bean="course.version.type"/>
										<dict:fieldRef bean="course.version.state"/>
										<dict:fieldRef bean="course.version.internal.id"/>
									</dict:state>
									<dict:state key="inactive">
									<!-- Identifier is inactive -->
									<!-- TODO: Add to simple spec -->
										<dict:fieldRef bean="course.version.no"/>
										<dict:fieldRef bean="course.version.transcriptTitle.draft"/>
										<dict:fieldRef bean="course.version.catalogTitle"/>
										<dict:fieldRef bean="course.version.level"/>
										<dict:fieldRef bean="course.cross-listed.subjectArea.draft"/>
										<dict:fieldRef bean="course.cross-listed.numberPart.draft"/>
										<dict:fieldRef bean="course.version.version.draft"/>
										<dict:fieldRef bean="course.cross-listed.adminOrg.draft"/>
										<dict:fieldRef bean="course.version.type"/>
										<dict:fieldRef bean="course.version.state"/>
										<dict:fieldRef bean="course.version.internal.id"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="zero.or.more.cross-listed.identifiers.zero.or.more.version.identifiers"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.academicSubjectOrgs"/>
				<dict:fieldRef bean="course.studySubjectArea"/>
				
				<dict:field id="course.desc.draft" key="desc">
					<dict:fieldDescriptor>
						<dict:name>course desc</dict:name>
						<dict:desc>dscription</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="richTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.desc.plain.draft" key="plain">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>course desc plain</dict:name>
												<dict:desc>plain text version description of course</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.desc.plain.draft">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.desc.formatted.draft" key="formatted">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>course desc formatted</dict:name>
												<dict:desc>rich text version of the course description</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.desc.formatted.draft">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.rationale.draft" key="marketingDesc">
					<!-- Rationale is stored in the Marketing Description for now -->
					<dict:fieldDescriptor>
						<dict:name>course rationale</dict:name>
						<dict:desc>rationale</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="richTextInfo">
								<!-- Complex type supporting both a plain text and formatted version of a string. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.rationale.plain.draft" key="plain">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>course rationale plain</dict:name>
												<dict:desc>plain text version of rationale</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="multi.line.text"/>
													<dict:constraintRef bean="hidden"/>
													<dict:constraintRef bean="calc.plain.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.plain">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.rationale.plain.draft">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="course.rationale.formatted.draft" key="formatted">
											<!-- Nine 9's gets translated to (unbounded) -->
											<dict:fieldDescriptor>
												<dict:name>course rationale formatted</dict:name>
												<dict:desc>rich text version of rationale</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="rich.text"/>
													<dict:constraint key="in-line.constraint.for.field.richTextInfo.formatted">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
													<dict:constraint key="in-line.constraint.for.dictionary.course.rationale.formatted.draft">
														<dict:maxLength>(unbounded)</dict:maxLength>
														</dict:constraint>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="course.campusLocation.draft" key="campusLocationList">
					<dict:fieldDescriptor>
						<dict:name>course campusLocation</dict:name>
						<dict:desc>campus location</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="code"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.accreditation"/>
				<dict:fieldRef bean="course.primaryAdminOrg"/>
				<dict:fieldRef bean="course.alternateAdminOrgs"/>
				<dict:fieldRef bean="course.primaryInstructor"/>
				<dict:fieldRef bean="course.instructors"/>
				<dict:fieldRef bean="course.expectedFirstAtp"/>
				<dict:fieldRef bean="course.effectiveDate"/>
				<dict:fieldRef bean="course.expirationDate"/>
				<dict:fieldRef bean="course.total.contact.hours"/>
				
				<dict:field id="course.duration.draft" key="stdDuration">
					<dict:fieldDescriptor>
						<dict:name>course duration</dict:name>
						<dict:desc>duration</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="timeAmountInfo">
								<!-- Detailed information about an amount of time including both the type of units and the quantity. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="course.duration.units.draft" key="atpDurationTypeKey">
											<!-- services has this flagged as mandatory but don't think it shoujld be because in a draft state a user may specify the units but not yet specify the amount -->
											<dict:fieldDescriptor>
												<dict:name>course duration units</dict:name>
												<dict:desc>Units in which the duration of the course is expressed</dict:desc>
												<dict:dataType>string</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="duration.types"/>
													<dict:constraintRef bean="optional"/>
													<dict:constraintRef bean="valid.duration.types"/>
											</dict:constraintDescriptor>
										</dict:field>
										<dict:fieldRef bean="course.duration.no"/>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.canCreateLui"/>
				<dict:fieldRef bean="course.referenceURL"/>
				<dict:fieldRef bean="course.luCodes"/>
				<dict:fieldRef bean="course.publishingInfo"/>
				<dict:fieldRef bean="course.nextReviewPeriod"/>
				<dict:fieldRef bean="course.isEnrollable"/>
				
				<dict:field id="course.seasons.draft" key="offeredAtpTypes">
					<!-- Services has this as an atpKeyList but that is just a list of Strings so I didn't create the sub-structure -->
					<dict:fieldDescriptor>
						<dict:name>course seasons</dict:name>
						<dict:desc>seasons offered</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="atp.types"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="course.hasEarlyDropDeadline"/>
				<dict:fieldRef bean="course.defaultEnrollmentEstimate"/>
				<dict:fieldRef bean="course.defaultMaximumEnrollment"/>
				<dict:fieldRef bean="course.isHazardousForDisabledStudents"/>
				<dict:fieldRef bean="course.feeInfo"/>
				<dict:fieldRef bean="course.accountingInfo"/>
				<dict:fieldRef bean="course.dynamic.attributes"/>
				<dict:fieldRef bean="course.meta"/>
				<dict:fieldRef bean="course.type"/>
				<dict:fieldRef bean="course.state"/>
				<dict:fieldRef bean="course.internal.id"/>
			</dict:state>					
		</dict:type>
	</dict:objectStructure>
	
	<dict:objectStructure key="proposalInfo">
		<!-- Detailed information about a proposal. -->
		<dict:type key="kuali.proposal.type.course.modify">
		<!-- Proposal to modify an existing Credit Course -->
		<!-- do these really need to be course specific? -->
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				
				<dict:field id="all.course.proposals.name" key="name">
					<dict:fieldDescriptor>
						<dict:name>all course proposals name</dict:name>
						<dict:desc>all course proposals name</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor> 
							<dict:constraintRef bean="required"/>
							<!--
							<dict:constraintRef bean="single.line.text"/>
							-->
							<dict:constraintRef bean="single"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.proposerPerson" key="proposerPerson">
					<dict:fieldDescriptor>
						<dict:name>all course proposals proposerPerson</dict:name>
						<dict:desc>all course proposals proposerPerson</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="required"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.personId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.proposerOrg" key="proposerOrg">
					<dict:fieldDescriptor>
						<dict:name>all course proposals proposerOrg</dict:name>
						<dict:desc>all course proposals proposerOrg</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<!-- 
							<dict:constraintRef bean="required"/>
							-->
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.orgId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.proposalReferenceType" key="proposalReferenceType">
					<dict:fieldDescriptor>
						<dict:name>all course proposals proposalReferenceType</dict:name>
						<dict:desc>all course proposals proposalReferenceType</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<!-- 
							<dict:constraintRef bean="required"/>
							-->
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="reference.types"/>
							<dict:constraintRef bean="hard.coded.referenceType.CLU"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.proposalReference" key="proposalReference">
					<dict:fieldDescriptor>
						<dict:name>all course proposals proposalReference</dict:name>
						<dict:desc>all course proposals proposalReference</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<!-- 
							<dict:constraintRef bean="required"/>
							-->
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="related.cluId"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.rationale.draft.private" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all course proposals rationale</dict:name>
						<dict:desc>all course proposals rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="multi.line.text"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.detailDesc" key="detailDesc">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all course proposals detailDesc</dict:name>
						<dict:desc>all course proposals detailDesc</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="multi.line.text"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.effectiveDate" key="effectiveDate">
					<dict:fieldDescriptor>
						<dict:name>all course proposals effectiveDate</dict:name>
						<dict:desc>all course proposals effectiveDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<!-- 
							<dict:constraintRef bean="required"/>
							-->
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.expirationDate" key="expirationDate">
					<dict:fieldDescriptor>
						<dict:name>all course proposals expirationDate</dict:name>
						<dict:desc>all course proposals expirationDate</dict:desc>
						<dict:dataType>dateTime</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="date.time"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.attributes" key="attributes">
					<dict:fieldDescriptor>
						<dict:name>all course proposals attributes</dict:name>
						<dict:desc>all course proposals attributes</dict:desc>
						<dict:dataType>complex</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="repeating"/>
							<dict:constraintRef bean="not.used"/>
					</dict:constraintDescriptor>
					<dict:dynamic>true</dict:dynamic>
				</dict:field>
				
				<dict:field id="all.course.proposals.metaInfo" key="metaInfo">
					<dict:fieldDescriptor>
						<dict:name>all course proposals metaInfo</dict:name>
						<dict:desc>all course proposals metaInfo</dict:desc>
						<dict:dataType>complex</dict:dataType>
							
							<dict:objectStructure key="metaInfo">
								<!-- Create and last update info for the structure. This is optional and treated as read only since the data is set by the internals of the service during maintenance operations. -->
								<dict:type key="kuali.not.applicable">
								<!-- Not applicable -->
								<!-- (n/a) -->
									<dict:state key="(n/a)">
									<!-- Not applicable -->
										
										<dict:field id="all.course.proposals.meta.versionInd" key="versionInd">
											<dict:fieldDescriptor>
												<dict:name>all course proposals meta versionInd</dict:name>
												<dict:desc>Version number for this all course proposals</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="calc.meta.versionInd"/>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="hidden"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.course.proposals.meta.createTime" key="createTime">
											<dict:fieldDescriptor>
												<dict:name>all course proposals meta createTime</dict:name>
												<dict:desc>Date-time this all course proposals was created</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="default.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.course.proposals.meta.createId" key="createId">
											<dict:fieldDescriptor>
												<dict:name>all course proposals meta createId</dict:name>
												<dict:desc>Principal of the persion who first created this all course proposals</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="default.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.course.proposals.meta.updateTime" key="updateTime">
											<dict:fieldDescriptor>
												<dict:name>all course proposals meta updateTime</dict:name>
												<dict:desc>Date-time this  all course proposals was last updated</dict:desc>
												<dict:dataType>dateTime</dict:dataType>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<!-- 
													<dict:constraintRef bean="required"/>
													-->
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="date.time"/>
													<dict:constraintRef bean="calc.now"/>
											</dict:constraintDescriptor>
										</dict:field>
										
										<dict:field id="all.course.proposals.meta.updateId" key="updateId">
											<dict:fieldDescriptor>
												<dict:name>all course proposals meta updateId</dict:name>
												<dict:desc>Principal of the persion who last updated this  all course proposals</dict:desc>
												<dict:dataType>string</dict:dataType>
												<dict:readOnly>true</dict:readOnly>
											</dict:fieldDescriptor>
											<dict:constraintDescriptor>
													<dict:constraintRef bean="read.only"/>
													<dict:constraintRef bean="single"/>
													<dict:constraintRef bean="related.principalId"/>
													<dict:constraintRef bean="calc.authenicated.principalId"/>
											</dict:constraintDescriptor>
										</dict:field>
									</dict:state>
								</dict:type>
							</dict:objectStructure>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.meta.data"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.type" key="type">
					<dict:fieldDescriptor>
						<dict:name>all course proposals type</dict:name>
						<dict:desc>all course proposals type</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<!-- 
							<dict:constraintRef bean="required"/>
							-->
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="proposal.types"/>
							<dict:constraintRef bean="course.proposal.types"/>
					</dict:constraintDescriptor>
				</dict:field>
				
				<dict:field id="all.course.proposals.state" key="state">
					<dict:fieldDescriptor>
						<dict:name>all course proposals state</dict:name>
						<dict:desc>all course proposals state</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<!-- 
							<dict:constraintRef bean="required"/>
							-->
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.state"/>
					</dict:constraintDescriptor>
					<dict:selector>true</dict:selector>
				</dict:field>
				
				<dict:field id="all.course.proposals.internal.id" key="id">
					<dict:fieldDescriptor>
						<dict:name>all course proposals internal id</dict:name>
						<dict:desc>all course proposals internal id</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="kuali.id"/>
							<dict:constraintRef bean="hidden"/>
					</dict:constraintDescriptor>
				</dict:field>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				
				<dict:field id="all.course.proposals.rationale.draft.public" key="rationale">
					<!-- Made this optional even though the service says its requried -->
					<dict:fieldDescriptor>
						<dict:name>all course proposals rationale</dict:name>
						<dict:desc>all course proposals rationale</dict:desc>
						<dict:dataType>string</dict:dataType>
					</dict:fieldDescriptor>
					<dict:constraintDescriptor>
							<dict:constraintRef bean="optional"/>
							<dict:constraintRef bean="single"/>
							<dict:constraintRef bean="multi.line.text"/>
							<dict:constraintRef bean="optional"/>
					</dict:constraintDescriptor>
				</dict:field>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
		</dict:type>
		<dict:type key="kuali.proposal.type.course.create">
		<!-- Proposal to create a new Credit Course -->
		<!-- changed keys - need CHANGE IN SMPLES -->
			<dict:state key="draft.private">
			<!-- Exploratory/Private scratch pad -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale.draft.private"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
			<dict:state key="draft.public">
			<!-- Entered as draft but not yet submitted -->
				<dict:fieldRef bean="all.course.proposals.name"/>
				<dict:fieldRef bean="all.course.proposals.proposerPerson"/>
				<dict:fieldRef bean="all.course.proposals.proposerOrg"/>
				<dict:fieldRef bean="all.course.proposals.proposalReferenceType"/>
				<dict:fieldRef bean="all.course.proposals.proposalReference"/>
				<dict:fieldRef bean="all.course.proposals.rationale.draft.public"/>
				<dict:fieldRef bean="all.course.proposals.detailDesc"/>
				<dict:fieldRef bean="all.course.proposals.effectiveDate"/>
				<dict:fieldRef bean="all.course.proposals.expirationDate"/>
				<dict:fieldRef bean="all.course.proposals.attributes"/>
				<dict:fieldRef bean="all.course.proposals.metaInfo"/>
				<dict:fieldRef bean="all.course.proposals.type"/>
				<dict:fieldRef bean="all.course.proposals.state"/>
				<dict:fieldRef bean="all.course.proposals.internal.id"/>
			</dict:state>
		</dict:type>
	</dict:objectStructure>
	
</beans>